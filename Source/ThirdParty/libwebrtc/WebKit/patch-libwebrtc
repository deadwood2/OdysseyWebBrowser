diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/datachannelinterface.h b/Source/ThirdParty/libwebrtc/Source/webrtc/api/datachannelinterface.h
index 92bdee2c0dc..48aa38cdbcb 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/datachannelinterface.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/datachannelinterface.h
@@ -91,7 +91,7 @@ class DataChannelObserver {
   //  A data buffer was successfully received.
   virtual void OnMessage(const DataBuffer& buffer) = 0;
   // The data channel's buffered_amount has changed.
-  virtual void OnBufferedAmountChange(uint64_t previous_amount) {}
+  virtual void OnBufferedAmountChange(uint64_t) {}
 
  protected:
   virtual ~DataChannelObserver() {}
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/jsep.h b/Source/ThirdParty/libwebrtc/Source/webrtc/api/jsep.h
index aa6e9a13546..3a7abf07c85 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/jsep.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/jsep.h
@@ -25,6 +25,7 @@
 #include <string>
 #include <vector>
 
+#include "webrtc/base/export.h"
 #include "webrtc/base/refcount.h"
 
 namespace cricket {
@@ -70,7 +71,7 @@ class IceCandidateInterface {
 // Creates a IceCandidateInterface based on SDP string.
 // Returns null if the sdp string can't be parsed.
 // |error| may be null.
-IceCandidateInterface* CreateIceCandidate(const std::string& sdp_mid,
+WEBRTC_DYLIB_EXPORT IceCandidateInterface* CreateIceCandidate(const std::string& sdp_mid,
                                           int sdp_mline_index,
                                           const std::string& sdp,
                                           SdpParseError* error);
@@ -92,7 +93,7 @@ class IceCandidateCollection {
 // and is therefore not expected to be thread safe.
 //
 // An instance can be created by CreateSessionDescription.
-class SessionDescriptionInterface {
+class WEBRTC_DYLIB_EXPORT SessionDescriptionInterface {
  public:
   // Supported types:
   static const char kOffer[];
@@ -126,7 +127,7 @@ class SessionDescriptionInterface {
   //
   // Returns the number of candidates removed.
   virtual size_t RemoveCandidates(
-      const std::vector<cricket::Candidate>& candidates) { return 0; }
+      const std::vector<cricket::Candidate>&) { return 0; }
 
   // Returns the number of m= sections in the session description.
   virtual size_t number_of_mediasections() const = 0;
@@ -143,7 +144,7 @@ class SessionDescriptionInterface {
 // Creates a SessionDescriptionInterface based on the SDP string and the type.
 // Returns null if the sdp string can't be parsed or the type is unsupported.
 // |error| may be null.
-SessionDescriptionInterface* CreateSessionDescription(const std::string& type,
+WEBRTC_DYLIB_EXPORT SessionDescriptionInterface* CreateSessionDescription(const std::string& type,
                                                       const std::string& sdp,
                                                       SdpParseError* error);
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediastreaminterface.h b/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediastreaminterface.h
index 937bb67ae91..34f52e92123 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediastreaminterface.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediastreaminterface.h
@@ -156,14 +156,14 @@ class VideoTrackInterface
 
   // Register a video sink for this track. Used to connect the track to the
   // underlying video engine.
-  void AddOrUpdateSink(rtc::VideoSinkInterface<VideoFrame>* sink,
-                       const rtc::VideoSinkWants& wants) override {}
-  void RemoveSink(rtc::VideoSinkInterface<VideoFrame>* sink) override {}
+  void AddOrUpdateSink(rtc::VideoSinkInterface<VideoFrame>*,
+                       const rtc::VideoSinkWants&) override {}
+  void RemoveSink(rtc::VideoSinkInterface<VideoFrame>*) override {}
 
   virtual VideoTrackSourceInterface* GetSource() const = 0;
 
   virtual ContentHint content_hint() const { return ContentHint::kNone; }
-  virtual void set_content_hint(ContentHint hint) {}
+  virtual void set_content_hint(ContentHint) {}
 
  protected:
   virtual ~VideoTrackInterface() {}
@@ -200,15 +200,15 @@ class AudioSourceInterface : public MediaSourceInterface {
   // Sets the volume of the source. |volume| is in  the range of [0, 10].
   // TODO(tommi): This method should be on the track and ideally volume should
   // be applied in the track in a way that does not affect clones of the track.
-  virtual void SetVolume(double volume) {}
+  virtual void SetVolume(double) {}
 
   // Registers/unregisters observers to the audio source.
-  virtual void RegisterAudioObserver(AudioObserver* observer) {}
-  virtual void UnregisterAudioObserver(AudioObserver* observer) {}
+  virtual void RegisterAudioObserver(AudioObserver*) {}
+  virtual void UnregisterAudioObserver(AudioObserver*) {}
 
   // TODO(tommi): Make pure virtual.
-  virtual void AddSink(AudioTrackSinkInterface* sink) {}
-  virtual void RemoveSink(AudioTrackSinkInterface* sink) {}
+  virtual void AddSink(AudioTrackSinkInterface*) {}
+  virtual void RemoveSink(AudioTrackSinkInterface*) {}
 };
 
 // Interface of the audio processor used by the audio track to collect
@@ -260,7 +260,7 @@ class AudioTrackInterface : public MediaStreamTrackInterface {
   // Return true on success, otherwise false.
   // TODO(deadbeef): Change the interface to int GetSignalLevel() and pure
   // virtual after it's implemented in chromium.
-  virtual bool GetSignalLevel(int* level) { return false; }
+  virtual bool GetSignalLevel(int*) { return false; }
 
   // Get the audio processor used by the audio track. Return null if the track
   // does not have any processor.
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediatypes.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediatypes.cc
index 2e3538dad82..55289faba3a 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediatypes.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediatypes.cc
@@ -28,7 +28,7 @@ std::string MediaTypeToString(MediaType type) {
     case MEDIA_TYPE_DATA:
       return kMediaTypeData;
   }
-  FATAL();
+  RTC_FATAL();
   // Not reachable; avoids compile warning.
   return "";
 }
@@ -41,7 +41,7 @@ MediaType MediaTypeFromString(const std::string& type_str) {
   } else if (type_str == kMediaTypeData) {
     return MEDIA_TYPE_DATA;
   }
-  FATAL();
+  RTC_FATAL();
   // Not reachable; avoids compile warning.
   return static_cast<MediaType>(-1);
 }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediatypes.h b/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediatypes.h
index ec3a70a5e83..dab060d44d2 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediatypes.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediatypes.h
@@ -11,6 +11,8 @@
 #ifndef WEBRTC_API_MEDIATYPES_H_
 #define WEBRTC_API_MEDIATYPES_H_
 
+#include "webrtc/base/export.h"
+
 #include <string>
 
 namespace cricket {
@@ -21,7 +23,7 @@ enum MediaType {
   MEDIA_TYPE_DATA
 };
 
-std::string MediaTypeToString(MediaType type);
+WEBRTC_DYLIB_EXPORT std::string MediaTypeToString(MediaType type);
 // Aborts on invalid string. Only expected to be used on strings that are
 // guaranteed to be valid, such as MediaStreamTrackInterface::kind().
 MediaType MediaTypeFromString(const std::string& type_str);
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/peerconnectioninterface.h b/Source/ThirdParty/libwebrtc/Source/webrtc/api/peerconnectioninterface.h
index ee0121246de..0b76abf9bd5 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/peerconnectioninterface.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/peerconnectioninterface.h
@@ -84,6 +84,7 @@
 #include "webrtc/api/stats/rtcstatscollectorcallback.h"
 #include "webrtc/api/statstypes.h"
 #include "webrtc/api/umametrics.h"
+#include "webrtc/base/export.h"
 #include "webrtc/base/fileutils.h"
 #include "webrtc/base/network.h"
 #include "webrtc/base/rtccertificate.h"
@@ -567,8 +568,8 @@ class PeerConnectionInterface : public rtc::RefCountInterface {
   // |stream_id| is used to populate the msid attribute; if empty, one will
   // be generated automatically.
   virtual rtc::scoped_refptr<RtpSenderInterface> CreateSender(
-      const std::string& kind,
-      const std::string& stream_id) {
+      const std::string&,
+      const std::string&) {
     return rtc::scoped_refptr<RtpSenderInterface>();
   }
 
@@ -602,7 +603,7 @@ class PeerConnectionInterface : public rtc::RefCountInterface {
   // TODO(hbos): Default implementation that does nothing only exists as to not
   // break third party projects. As soon as they have been updated this should
   // be changed to "= 0;".
-  virtual void GetStats(RTCStatsCollectorCallback* callback) {}
+  virtual void GetStats(RTCStatsCollectorCallback*) {}
 
   // Create a data channel with the provided config, or default config if none
   // is provided. Note that an offer/answer negotiation is still necessary
@@ -643,23 +644,23 @@ class PeerConnectionInterface : public rtc::RefCountInterface {
 
   // Create a new offer.
   // The CreateSessionDescriptionObserver callback will be called when done.
-  virtual void CreateOffer(CreateSessionDescriptionObserver* observer,
-                           const MediaConstraintsInterface* constraints) {}
+  virtual void CreateOffer(CreateSessionDescriptionObserver*,
+                           const MediaConstraintsInterface*) {}
 
   // TODO(jiayl): remove the default impl and the old interface when chromium
   // code is updated.
-  virtual void CreateOffer(CreateSessionDescriptionObserver* observer,
-                           const RTCOfferAnswerOptions& options) {}
+  virtual void CreateOffer(CreateSessionDescriptionObserver*,
+                           const RTCOfferAnswerOptions&) {}
 
   // Create an answer to an offer.
   // The CreateSessionDescriptionObserver callback will be called when done.
-  virtual void CreateAnswer(CreateSessionDescriptionObserver* observer,
-                            const RTCOfferAnswerOptions& options) {}
+  virtual void CreateAnswer(CreateSessionDescriptionObserver*,
+                            const RTCOfferAnswerOptions&) {}
   // Deprecated - use version above.
   // TODO(hta): Remove and remove default implementations when all callers
   // are updated.
-  virtual void CreateAnswer(CreateSessionDescriptionObserver* observer,
-                            const MediaConstraintsInterface* constraints) {}
+  virtual void CreateAnswer(CreateSessionDescriptionObserver*,
+                            const MediaConstraintsInterface*) {}
 
   // Sets the local session description.
   // The PeerConnection takes the ownership of |desc| even if it fails.
@@ -675,11 +676,11 @@ class PeerConnectionInterface : public rtc::RefCountInterface {
                                     SessionDescriptionInterface* desc) = 0;
   // Deprecated; Replaced by SetConfiguration.
   // TODO(deadbeef): Remove once Chrome is moved over to SetConfiguration.
-  virtual bool UpdateIce(const IceServers& configuration,
-                         const MediaConstraintsInterface* constraints) {
+  virtual bool UpdateIce(const IceServers&,
+                         const MediaConstraintsInterface*) {
     return false;
   }
-  virtual bool UpdateIce(const IceServers& configuration) { return false; }
+  virtual bool UpdateIce(const IceServers&) { return false; }
 
   // TODO(deadbeef): Make this pure virtual once all Chrome subclasses of
   // PeerConnectionInterface implement it.
@@ -711,14 +712,14 @@ class PeerConnectionInterface : public rtc::RefCountInterface {
   // TODO(deadbeef): Make this pure virtual once all Chrome subclasses of
   // PeerConnectionInterface implement it.
   virtual bool SetConfiguration(
-      const PeerConnectionInterface::RTCConfiguration& config,
-      RTCError* error) {
+      const PeerConnectionInterface::RTCConfiguration&,
+      RTCError*) {
     return false;
   }
   // Version without error output param for backwards compatibility.
   // TODO(deadbeef): Remove once chromium is updated.
   virtual bool SetConfiguration(
-      const PeerConnectionInterface::RTCConfiguration& config) {
+      const PeerConnectionInterface::RTCConfiguration&) {
     return false;
   }
 
@@ -732,7 +733,7 @@ class PeerConnectionInterface : public rtc::RefCountInterface {
   // continual gathering, to avoid an ever-growing list of candidates as
   // networks come and go.
   virtual bool RemoveIceCandidates(
-      const std::vector<cricket::Candidate>& candidates) {
+      const std::vector<cricket::Candidate>&) {
     return false;
   }
 
@@ -755,7 +756,7 @@ class PeerConnectionInterface : public rtc::RefCountInterface {
   //
   // Setting |current_bitrate_bps| will reset the current bitrate estimate
   // to the provided value.
-  virtual RTCError SetBitrate(const BitrateParameters& bitrate) {
+  virtual RTCError SetBitrate(const BitrateParameters&) {
     return RTCError::OK();
   }
 
@@ -770,8 +771,8 @@ class PeerConnectionInterface : public rtc::RefCountInterface {
   // automatically after 10 minutes have passed, or when the StopRtcEventLog
   // function is called.
   // TODO(ivoc): Make this pure virtual when Chrome is updated.
-  virtual bool StartRtcEventLog(rtc::PlatformFile file,
-                                int64_t max_size_bytes) {
+  virtual bool StartRtcEventLog(rtc::PlatformFile,
+                                int64_t) {
     return false;
   }
 
@@ -844,17 +845,17 @@ class PeerConnectionObserver {
   // TODO(honghaiz): Make this a pure virtual method when all its subclasses
   // implement it.
   virtual void OnIceCandidatesRemoved(
-      const std::vector<cricket::Candidate>& candidates) {}
+      const std::vector<cricket::Candidate>&) {}
 
   // Called when the ICE connection receiving status changes.
-  virtual void OnIceConnectionReceivingChange(bool receiving) {}
+  virtual void OnIceConnectionReceivingChange(bool) {}
 
   // Called when a track is added to streams.
   // TODO(zhihuang) Make this a pure virtual method when all its subclasses
   // implement it.
   virtual void OnAddTrack(
-      rtc::scoped_refptr<RtpReceiverInterface> receiver,
-      const std::vector<rtc::scoped_refptr<MediaStreamInterface>>& streams) {}
+      rtc::scoped_refptr<RtpReceiverInterface>,
+      const std::vector<rtc::scoped_refptr<MediaStreamInterface>>&) {}
 
  protected:
   // Dtor protected as objects shouldn't be deleted via this interface.
@@ -957,7 +958,7 @@ class PeerConnectionFactoryInterface : public rtc::RefCountInterface {
   // TODO(deadbeef): Make pure virtual once downstream mock PC factory classes
   // are updated.
   virtual rtc::scoped_refptr<VideoTrackSourceInterface> CreateVideoSource(
-      std::unique_ptr<cricket::VideoCapturer> capturer) {
+      std::unique_ptr<cricket::VideoCapturer>) {
     return nullptr;
   }
 
@@ -968,8 +969,8 @@ class PeerConnectionFactoryInterface : public rtc::RefCountInterface {
   // |constraints| is only used for the invocation of this method, and can
   // safely be destroyed afterwards.
   virtual rtc::scoped_refptr<VideoTrackSourceInterface> CreateVideoSource(
-      std::unique_ptr<cricket::VideoCapturer> capturer,
-      const MediaConstraintsInterface* constraints) {
+      std::unique_ptr<cricket::VideoCapturer>,
+      const MediaConstraintsInterface*) {
     return nullptr;
   }
 
@@ -1072,7 +1073,7 @@ rtc::scoped_refptr<PeerConnectionFactoryInterface> CreatePeerConnectionFactory(
 
 // Deprecated variant of the above.
 // TODO(kwiberg): Remove.
-rtc::scoped_refptr<PeerConnectionFactoryInterface> CreatePeerConnectionFactory(
+WEBRTC_DYLIB_EXPORT rtc::scoped_refptr<PeerConnectionFactoryInterface> CreatePeerConnectionFactory(
     rtc::Thread* network_thread,
     rtc::Thread* worker_thread,
     rtc::Thread* signaling_thread,
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/rtcerror.h b/Source/ThirdParty/libwebrtc/Source/webrtc/api/rtcerror.h
index 5cb123227d4..9732dd3fab4 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/rtcerror.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/rtcerror.h
@@ -16,6 +16,7 @@
 #include <utility>  // For std::move.
 
 #include "webrtc/base/checks.h"
+#include "webrtc/base/export.h"
 #include "webrtc/base/logging.h"
 
 namespace webrtc {
@@ -106,7 +107,7 @@ class RTCError {
   // Identical to default constructed error.
   //
   // Preferred over the default constructor for code readability.
-  static RTCError OK();
+  WEBRTC_DYLIB_EXPORT static RTCError OK();
 
   // Error type.
   RTCErrorType type() const { return type_; }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/stats/rtcstats.h b/Source/ThirdParty/libwebrtc/Source/webrtc/api/stats/rtcstats.h
index b3afee06956..a9068bbe1f6 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/stats/rtcstats.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/stats/rtcstats.h
@@ -18,6 +18,7 @@
 #include <vector>
 
 #include "webrtc/base/checks.h"
+#include "webrtc/base/export.h"
 
 namespace webrtc {
 
@@ -74,7 +75,7 @@ class RTCStats {
 
   // Creates a human readable string representation of the stats object, listing
   // all of its members (names and values).
-  std::string ToString() const;
+  WEBRTC_DYLIB_EXPORT std::string ToString() const;
 
   // Downcasts the stats object to an |RTCStats| subclass |T|. DCHECKs that the
   // object is of type |T|.
@@ -140,7 +141,7 @@ class RTCStats {
 //
 #define WEBRTC_RTCSTATS_DECL()                                                 \
  public:                                                                       \
-  static const char kType[];                                                   \
+  WEBRTC_DYLIB_EXPORT static const char kType[];                                                   \
                                                                                \
   std::unique_ptr<webrtc::RTCStats> copy() const override;                     \
   const char* type() const override;                                           \
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/stats/rtcstatsreport.h b/Source/ThirdParty/libwebrtc/Source/webrtc/api/stats/rtcstatsreport.h
index 6d9ae6df2ac..7e80aed3427 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/stats/rtcstatsreport.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/stats/rtcstatsreport.h
@@ -17,6 +17,7 @@
 #include <vector>
 
 #include "webrtc/api/stats/rtcstats.h"
+#include "webrtc/base/export.h"
 #include "webrtc/base/refcount.h"
 #include "webrtc/base/scoped_ref_ptr.h"
 
@@ -24,7 +25,7 @@ namespace webrtc {
 
 // A collection of stats.
 // This is accessible as a map from |RTCStats::id| to |RTCStats|.
-class RTCStatsReport : public rtc::RefCountInterface {
+class WEBRTC_DYLIB_EXPORT RTCStatsReport : public rtc::RefCountInterface {
  public:
   typedef std::map<std::string, std::unique_ptr<const RTCStats>> StatsMap;
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/umametrics.h b/Source/ThirdParty/libwebrtc/Source/webrtc/api/umametrics.h
index 89994476a9a..07802c88dda 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/umametrics.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/umametrics.h
@@ -116,9 +116,9 @@ class MetricsObserverInterface : public rtc::RefCountInterface {
   // |type| is the type of the enum counter to be incremented. |counter|
   // is the particular counter in that type. |counter_max| is the next sequence
   // number after the highest counter.
-  virtual void IncrementEnumCounter(PeerConnectionEnumCounterType type,
-                                    int counter,
-                                    int counter_max) {}
+  virtual void IncrementEnumCounter(PeerConnectionEnumCounterType,
+                                    int,
+                                    int) {}
 
   // This is used to handle sparse counters like SSL cipher suites.
   // TODO(guoweis): Remove the implementation once the dependency's interface
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/i420_buffer.h b/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/i420_buffer.h
index 31014a31f0b..d0f979a9993 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/i420_buffer.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/i420_buffer.h
@@ -15,6 +15,7 @@
 
 #include "webrtc/api/video/video_rotation.h"
 #include "webrtc/api/video/video_frame_buffer.h"
+#include "webrtc/base/export.h"
 #include "webrtc/system_wrappers/include/aligned_malloc.h"
 
 namespace webrtc {
@@ -43,7 +44,7 @@ class I420Buffer : public I420BufferInterface {
       const uint8_t* data_v, int stride_v);
 
   // Returns a rotated copy of |src|.
-  static rtc::scoped_refptr<I420Buffer> Rotate(const I420BufferInterface& src,
+  WEBRTC_DYLIB_EXPORT static rtc::scoped_refptr<I420Buffer> Rotate(const I420BufferInterface& src,
                                                VideoRotation rotation);
   // Deprecated.
   static rtc::scoped_refptr<I420Buffer> Rotate(const VideoFrameBuffer& src,
@@ -52,7 +53,7 @@ class I420Buffer : public I420BufferInterface {
   }
 
   // Sets the buffer to all black.
-  static void SetBlack(I420Buffer* buffer);
+  WEBRTC_DYLIB_EXPORT static void SetBlack(I420Buffer* buffer);
 
   // Sets all three planes to all zeros. Used to work around for
   // quirks in memory checkers
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_frame.h b/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_frame.h
index 3ee381b0914..8f427f5368c 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_frame.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_frame.h
@@ -15,10 +15,11 @@
 
 #include "webrtc/api/video/video_rotation.h"
 #include "webrtc/api/video/video_frame_buffer.h"
+#include "webrtc/base/export.h"
 
 namespace webrtc {
 
-class VideoFrame {
+class WEBRTC_DYLIB_EXPORT VideoFrame {
  public:
   // TODO(nisse): This constructor is consistent with the now deleted
   // cricket::WebRtcVideoFrame. We should consider whether or not we
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_frame_buffer.h b/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_frame_buffer.h
index fa711d85e1b..064cc179876 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_frame_buffer.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_frame_buffer.h
@@ -13,6 +13,7 @@
 
 #include <stdint.h>
 
+#include "webrtc/base/export.h"
 #include "webrtc/base/refcount.h"
 #include "webrtc/base/scoped_ref_ptr.h"
 
@@ -36,7 +37,7 @@ class I444BufferInterface;
 // performance by providing an optimized path without intermediate conversions.
 // Frame metadata such as rotation and timestamp are stored in
 // webrtc::VideoFrame, and not here.
-class VideoFrameBuffer : public rtc::RefCountInterface {
+class WEBRTC_DYLIB_EXPORT VideoFrameBuffer : public rtc::RefCountInterface {
  public:
   // New frame buffer types will be added conservatively when there is an
   // opportunity to optimize the path between some pair of video source and
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_decoder.h b/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_decoder.h
index ea531e4c1a1..10045e0fd94 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_decoder.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_decoder.h
@@ -36,7 +36,7 @@ class DecodedImageCallback {
   // decode time excluding waiting time for any previous pending frame to
   // return. This is necessary for breaking positive feedback in the delay
   // estimation when the decoder has a single output buffer.
-  virtual int32_t Decoded(VideoFrame& decodedImage, int64_t decode_time_ms) {
+  virtual int32_t Decoded(VideoFrame& decodedImage, int64_t /* decode_time_ms */) {
     // The default implementation ignores custom decode time value.
     return Decoded(decodedImage);
   }
@@ -44,16 +44,16 @@ class DecodedImageCallback {
   // updated.
   virtual void Decoded(VideoFrame& decodedImage,
                        rtc::Optional<int32_t> decode_time_ms,
-                       rtc::Optional<uint8_t> qp) {
+                       rtc::Optional<uint8_t> /* qp */) {
     Decoded(decodedImage,
             decode_time_ms ? static_cast<int32_t>(*decode_time_ms) : -1);
   }
 
-  virtual int32_t ReceivedDecodedReferenceFrame(const uint64_t pictureId) {
+  virtual int32_t ReceivedDecodedReferenceFrame(const uint64_t /* pictureId */) {
     return -1;
   }
 
-  virtual int32_t ReceivedDecodedFrame(const uint64_t pictureId) { return -1; }
+  virtual int32_t ReceivedDecodedFrame(const uint64_t /* pictureId */) { return -1; }
 };
 
 class VideoDecoder {
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder.h b/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder.h
index 0c95dfab1f5..a84aab4cdc5 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder.h
@@ -166,7 +166,7 @@ class VideoEncoder {
   //          - framerate       : The target frame rate
   //
   // Return value                : WEBRTC_VIDEO_CODEC_OK if OK, < 0 otherwise.
-  virtual int32_t SetRates(uint32_t bitrate, uint32_t framerate) {
+  virtual int32_t SetRates(uint32_t /* bitrate */, uint32_t /* framerate */) {
     RTC_NOTREACHED() << "SetRate(uint32_t, uint32_t) is deprecated.";
     return -1;
   }
@@ -184,7 +184,7 @@ class VideoEncoder {
     return ScalingSettings(false);
   }
 
-  virtual int32_t SetPeriodicKeyFrames(bool enable) { return -1; }
+  virtual int32_t SetPeriodicKeyFrames(bool /* enable */) { return -1; }
   virtual bool SupportsNativeHandle() const { return false; }
   virtual const char* ImplementationName() const { return "unknown"; }
 };
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/array_view.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/array_view.h
index 7a0bb28954d..0b77d905ed3 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/array_view.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/array_view.h
@@ -88,7 +88,7 @@ class ArrayViewBase {
   static_assert(Size > 0, "ArrayView size must be variable or non-negative");
 
  public:
-  ArrayViewBase(T* data, size_t size) : data_(data) {}
+  ArrayViewBase(T* data, size_t) : data_(data) {}
 
   static constexpr size_t size() { return Size; }
   static constexpr bool empty() { return false; }
@@ -105,7 +105,7 @@ class ArrayViewBase {
 template <typename T>
 class ArrayViewBase<T, 0> {
  public:
-  explicit ArrayViewBase(T* data, size_t size) {}
+  explicit ArrayViewBase(T*, size_t) {}
 
   static constexpr size_t size() { return 0; }
   static constexpr bool empty() { return true; }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/asyncpacketsocket.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/asyncpacketsocket.h
index a5409479511..06779ada31e 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/asyncpacketsocket.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/asyncpacketsocket.h
@@ -13,6 +13,7 @@
 
 #include "webrtc/base/constructormagic.h"
 #include "webrtc/base/dscp.h"
+#include "webrtc/base/export.h"
 #include "webrtc/base/sigslot.h"
 #include "webrtc/base/socket.h"
 #include "webrtc/base/timeutils.h"
@@ -22,7 +23,7 @@ namespace rtc {
 // This structure holds the info needed to update the packet send time header
 // extension, including the information needed to update the authentication tag
 // after changing the value.
-struct PacketTimeUpdateParams {
+struct WEBRTC_DYLIB_EXPORT PacketTimeUpdateParams {
   PacketTimeUpdateParams();
   ~PacketTimeUpdateParams();
 
@@ -65,7 +66,7 @@ inline PacketTime CreatePacketTime(int64_t not_before) {
 
 // Provides the ability to receive packets asynchronously. Sends are not
 // buffered since it is acceptable to drop packets under high load.
-class AsyncPacketSocket : public sigslot::has_slots<> {
+class WEBRTC_DYLIB_EXPORT AsyncPacketSocket : public sigslot::has_slots<> {
  public:
   enum State {
     STATE_CLOSED,
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/asyncresolverinterface.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/asyncresolverinterface.h
index 75c36abbf4d..f90c2125d0e 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/asyncresolverinterface.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/asyncresolverinterface.h
@@ -11,13 +11,14 @@
 #ifndef WEBRTC_BASE_ASYNCRESOLVERINTERFACE_H_
 #define WEBRTC_BASE_ASYNCRESOLVERINTERFACE_H_
 
+#include "webrtc/base/export.h"
 #include "webrtc/base/sigslot.h"
 #include "webrtc/base/socketaddress.h"
 
 namespace rtc {
 
 // This interface defines the methods to resolve the address asynchronously.
-class AsyncResolverInterface {
+class WEBRTC_DYLIB_EXPORT AsyncResolverInterface {
  public:
   AsyncResolverInterface();
   virtual ~AsyncResolverInterface();
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/checks.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/checks.h
index c15a08c2c52..f4472f1d1ec 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/checks.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/checks.h
@@ -37,6 +37,7 @@ NO_RETURN void rtc_FatalMessage(const char* file, int line, const char* msg);
 #include <string>
 
 #include "webrtc/base/safe_compare.h"
+#include "webrtc/base/export.h"
 
 // The macros here print a message to stderr and abort under various
 // conditions. All will accept additional stream messages. For example:
@@ -73,7 +74,7 @@ NO_RETURN void rtc_FatalMessage(const char* file, int line, const char* msg);
 //   messages if the condition doesn't hold. Prefer them to raw RTC_CHECK and
 //   RTC_DCHECK.
 //
-// - FATAL() aborts unconditionally.
+// - RTC_FATAL() aborts unconditionally.
 //
 // TODO(ajm): Ideally, checks.h would be combined with logging.h, but
 // consolidation with system_wrappers/logging.h should happen first.
@@ -135,13 +136,12 @@ std::string* MakeCheckOpString(const t1& v1, const t2& v2, const char* names) {
 }
 
 // MSVC doesn't like complex extern templates and DLLs.
-#if !defined(COMPILER_MSVC)
+#if 0
 // Commonly used instantiations of MakeCheckOpString<>. Explicitly instantiated
 // in logging.cc.
 extern template std::string* MakeCheckOpString<int, int>(
     const int&, const int&, const char* names);
-extern template
-std::string* MakeCheckOpString<unsigned long, unsigned long>(
+extern template std::string* MakeCheckOpString<unsigned long, unsigned long>(
     const unsigned long&, const unsigned long&, const char* names);
 extern template
 std::string* MakeCheckOpString<unsigned long, unsigned int>(
@@ -221,13 +221,13 @@ class FatalMessageVoidify {
 #define RTC_UNREACHABLE_CODE_HIT false
 #define RTC_NOTREACHED() RTC_DCHECK(RTC_UNREACHABLE_CODE_HIT)
 
-#define FATAL() rtc::FatalMessage(__FILE__, __LINE__).stream()
+#define RTC_FATAL() rtc::FatalMessage(__FILE__, __LINE__).stream()
 // TODO(ajm): Consider adding RTC_NOTIMPLEMENTED macro when
 // base/logging.h and system_wrappers/logging.h are consolidated such that we
 // can match the Chromium behavior.
 
 // Like a stripped-down LogMessage from logging.h, except that it aborts.
-class FatalMessage {
+class WEBRTC_DYLIB_EXPORT FatalMessage {
  public:
   FatalMessage(const char* file, int line);
   // Used for RTC_CHECK_EQ(), etc. Takes ownership of the given string.
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/copyonwritebuffer.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/copyonwritebuffer.h
index fe3f5619d13..0cd66535dd7 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/copyonwritebuffer.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/copyonwritebuffer.h
@@ -16,12 +16,13 @@
 
 #include "webrtc/base/buffer.h"
 #include "webrtc/base/checks.h"
+#include "webrtc/base/export.h"
 #include "webrtc/base/refcount.h"
 #include "webrtc/base/scoped_ref_ptr.h"
 
 namespace rtc {
 
-class CopyOnWriteBuffer {
+class WEBRTC_DYLIB_EXPORT CopyOnWriteBuffer {
  public:
   // An empty buffer.
   CopyOnWriteBuffer();
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/event.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/event.h
index d4b58724f0e..fb51d9c4c29 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/event.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/event.h
@@ -12,6 +12,7 @@
 #define WEBRTC_BASE_EVENT_H__
 
 #include "webrtc/base/constructormagic.h"
+#include "webrtc/base/export.h"
 #if defined(WEBRTC_WIN)
 #include "webrtc/base/win32.h"  // NOLINT: consider this a system header.
 #elif defined(WEBRTC_POSIX)
@@ -22,7 +23,7 @@
 
 namespace rtc {
 
-class Event {
+class WEBRTC_DYLIB_EXPORT Event {
  public:
   static const int kForever = -1;
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/fakenetwork.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/fakenetwork.h
index 108e738468d..7191ffe9137 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/fakenetwork.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/fakenetwork.h
@@ -79,7 +79,7 @@ class FakeNetworkManager : public NetworkManagerBase,
   virtual void StopUpdating() { --start_count_; }
 
   // MessageHandler interface.
-  virtual void OnMessage(Message* msg) {
+  virtual void OnMessage(Message*) {
     DoUpdateNetworks();
   }
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/flags.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/base/flags.cc
index 9b7177c22c1..a7f1c98bf8b 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/flags.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/flags.cc
@@ -57,7 +57,7 @@ void Flag::SetToDefault() {
       variable_->s = default_.s;
       return;
   }
-  FATAL() << "unreachable code";
+  RTC_FATAL() << "unreachable code";
 }
 
 
@@ -68,7 +68,7 @@ static const char* Type2String(Flag::Type type) {
     case Flag::FLOAT: return "float";
     case Flag::STRING: return "string";
   }
-  FATAL() << "unreachable code";
+  RTC_FATAL() << "unreachable code";
 }
 
 
@@ -87,7 +87,7 @@ static void PrintFlagValue(Flag::Type type, FlagValue* p) {
       printf("%s", p->s);
       return;
   }
-  FATAL() << "unreachable code";
+  RTC_FATAL() << "unreachable code";
 }
 
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/helpers.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/helpers.h
index fcf77afd7f8..15fe16e24bd 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/helpers.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/helpers.h
@@ -13,6 +13,7 @@
 
 #include <string>
 #include "webrtc/base/basictypes.h"
+#include "webrtc/base/export.h"
 
 namespace rtc {
 
@@ -25,7 +26,7 @@ bool InitRandom(const char* seed, size_t len);
 
 // Generates a (cryptographically) random string of the given length.
 // We generate base64 values so that they will be printable.
-std::string CreateRandomString(size_t length);
+WEBRTC_DYLIB_EXPORT std::string CreateRandomString(size_t length);
 
 // Generates a (cryptographically) random string of the given length.
 // We generate base64 values so that they will be printable.
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/ipaddress.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/ipaddress.h
index ef1e3d81700..90dca488199 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/ipaddress.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/ipaddress.h
@@ -27,6 +27,7 @@
 
 #include "webrtc/base/basictypes.h"
 #include "webrtc/base/byteorder.h"
+#include "webrtc/base/export.h"
 #if defined(WEBRTC_WIN)
 #include "webrtc/base/win32.h"
 #endif
@@ -86,8 +87,8 @@ class IPAddress {
   friend std::ostream& operator<<(std::ostream& os, const IPAddress& addr);
 
   int family() const { return family_; }
-  in_addr ipv4_address() const;
-  in6_addr ipv6_address() const;
+  WEBRTC_DYLIB_EXPORT in_addr ipv4_address() const;
+  WEBRTC_DYLIB_EXPORT in6_addr ipv6_address() const;
 
   // Returns the number of bytes needed to store the raw address.
   size_t Size() const;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/location.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/location.h
index 541be9ac141..5f0203201f1 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/location.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/location.h
@@ -13,6 +13,8 @@
 
 #include <string>
 
+#include "webrtc/base/event.h"
+#include "webrtc/base/export.h"
 #include "webrtc/base/stringize_macros.h"
 
 namespace rtc {
@@ -21,7 +23,7 @@ namespace rtc {
 // significantly brought to life.
 // This is a stripped down version of:
 // https://code.google.com/p/chromium/codesearch#chromium/src/base/location.h
-class Location {
+class WEBRTC_DYLIB_EXPORT Location {
  public:
   // Constructor should be called with a long-lived char*, such as __FILE__.
   // It assumes the provided value will persist as a global constant, and it
@@ -50,7 +52,7 @@ class Location {
 #define RTC_FROM_HERE RTC_FROM_HERE_WITH_FUNCTION(__FUNCTION__)
 
 #define RTC_FROM_HERE_WITH_FUNCTION(function_name) \
-  ::rtc::Location(function_name, __FILE__ ":" STRINGIZE(__LINE__))
+  ::rtc::Location(function_name, __FILE__ ":" RTC_STRINGIZE(__LINE__))
 
 }  // namespace rtc
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/logging.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/base/logging.cc
index 25f85c96a7c..1c195a23d9b 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/logging.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/logging.cc
@@ -41,6 +41,7 @@ static const char kLibjingle[] = "libjingle";
 
 #include "webrtc/base/criticalsection.h"
 #include "webrtc/base/logging.h"
+#include "webrtc/base/neverdestroyed.h"
 #include "webrtc/base/platform_thread.h"
 #include "webrtc/base/stringencode.h"
 #include "webrtc/base/stringutils.h"
@@ -103,15 +104,23 @@ LoggingSeverity LogMessage::dbg_sev_ = LS_NONE;
 bool LogMessage::log_to_stderr_ = true;
 
 namespace {
-// Global lock for log subsystem, only needed to serialize access to streams_.
-CriticalSection g_log_crit;
+// Global lock for log subsystem, only needed to serialize access to streams.
+const CriticalSection& g_log_crit()
+{
+    static webrtc::NeverDestroyed<CriticalSection> g_log_crit;
+    return g_log_crit;
+}
 }  // namespace
 
 // The list of logging streams currently configured.
 // Note: we explicitly do not clean this up, because of the uncertain ordering
 // of destructors at program exit.  Let the person who sets the stream trigger
 // cleanup by setting to null, or let it leak (safe at program exit).
-LogMessage::StreamList LogMessage::streams_ GUARDED_BY(g_log_crit);
+LogMessage::StreamList& LogMessage::streams() EXCLUSIVE_LOCKS_REQUIRED(g_log_crit())
+{
+    static webrtc::NeverDestroyed<LogMessage::StreamList> streams GUARDED_BY(g_log_crit());
+    return streams;
+}
 
 // Boolean options default to false (0)
 bool LogMessage::thread_, LogMessage::timestamp_;
@@ -207,8 +216,8 @@ LogMessage::~LogMessage() {
     OutputToDebug(str, severity_, tag_);
   }
 
-  CritScope cs(&g_log_crit);
-  for (auto& kv : streams_) {
+  CritScope cs(&g_log_crit());
+  for (auto& kv : streams()) {
     if (severity_ >= kv.second) {
       kv.first->OnLogMessage(str);
     }
@@ -235,7 +244,7 @@ void LogMessage::LogTimestamps(bool on) {
 
 void LogMessage::LogToDebug(LoggingSeverity min_sev) {
   dbg_sev_ = min_sev;
-  CritScope cs(&g_log_crit);
+  CritScope cs(&g_log_crit());
   UpdateMinLogSeverity();
 }
 
@@ -244,9 +253,9 @@ void LogMessage::SetLogToStderr(bool log_to_stderr) {
 }
 
 int LogMessage::GetLogToStream(LogSink* stream) {
-  CritScope cs(&g_log_crit);
+  CritScope cs(&g_log_crit());
   LoggingSeverity sev = LS_NONE;
-  for (auto& kv : streams_) {
+  for (auto& kv : streams()) {
     if (!stream || stream == kv.first) {
       sev = std::min(sev, kv.second);
     }
@@ -255,16 +264,16 @@ int LogMessage::GetLogToStream(LogSink* stream) {
 }
 
 void LogMessage::AddLogToStream(LogSink* stream, LoggingSeverity min_sev) {
-  CritScope cs(&g_log_crit);
-  streams_.push_back(std::make_pair(stream, min_sev));
+  CritScope cs(&g_log_crit());
+  streams().push_back(std::make_pair(stream, min_sev));
   UpdateMinLogSeverity();
 }
 
 void LogMessage::RemoveLogToStream(LogSink* stream) {
-  CritScope cs(&g_log_crit);
-  for (StreamList::iterator it = streams_.begin(); it != streams_.end(); ++it) {
+  CritScope cs(&g_log_crit());
+  for (StreamList::iterator it = streams().begin(); it != streams().end(); ++it) {
     if (stream == it->first) {
-      streams_.erase(it);
+      streams().erase(it);
       break;
     }
   }
@@ -333,9 +342,9 @@ void LogMessage::ConfigureLogging(const char* params) {
   LogToDebug(debug_level);
 }
 
-void LogMessage::UpdateMinLogSeverity() EXCLUSIVE_LOCKS_REQUIRED(g_log_crit) {
+void LogMessage::UpdateMinLogSeverity() EXCLUSIVE_LOCKS_REQUIRED(g_log_crit()) {
   LoggingSeverity min_sev = dbg_sev_;
-  for (auto& kv : streams_) {
+  for (auto& kv : streams()) {
     min_sev = std::min(dbg_sev_, kv.second);
   }
   min_sev_ = min_sev;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/logging.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/logging.h
index 8f476a0215c..576e1490f72 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/logging.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/logging.h
@@ -58,6 +58,7 @@
 #endif
 
 #include "webrtc/base/basictypes.h"
+#include "webrtc/base/export.h"
 #include "webrtc/base/constructormagic.h"
 #include "webrtc/base/thread_annotations.h"
 
@@ -175,7 +176,7 @@ class LogMessage {
 
   // These are the available logging channels
   //  Debug: Debug console on Windows, otherwise stderr
-  static void LogToDebug(LoggingSeverity min_sev);
+  WEBRTC_DYLIB_EXPORT static void LogToDebug(LoggingSeverity min_sev);
   static LoggingSeverity GetLogToDebug() { return dbg_sev_; }
 
   // Sets whether logs will be directed to stderr in debug mode.
@@ -233,7 +234,7 @@ class LogMessage {
   static LoggingSeverity min_sev_, dbg_sev_, ctx_sev_;
 
   // The output streams and their associated severities
-  static StreamList streams_;
+  static StreamList& streams();
 
   // Flags for formatting options
   static bool thread_, timestamp_;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/messagehandler.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/messagehandler.h
index 72c0dc69079..1185647fe8c 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/messagehandler.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/messagehandler.h
@@ -14,6 +14,7 @@
 #include <memory>
 #include <utility>
 
+#include "webrtc/base/export.h"
 #include "webrtc/base/constructormagic.h"
 
 namespace rtc {
@@ -22,10 +23,10 @@ struct Message;
 
 // Messages get dispatched to a MessageHandler
 
-class MessageHandler {
+class WEBRTC_DYLIB_EXPORT MessageHandler {
  public:
-  virtual ~MessageHandler();
-  virtual void OnMessage(Message* msg) = 0;
+  WEBRTC_DYLIB_EXPORT virtual ~MessageHandler();
+  virtual void OnMessage(Message*) = 0;
 
  protected:
   MessageHandler() {}
@@ -40,7 +41,7 @@ class FunctorMessageHandler : public MessageHandler {
  public:
   explicit FunctorMessageHandler(const FunctorT& functor)
       : functor_(functor) {}
-  virtual void OnMessage(Message* msg) {
+  virtual void OnMessage(Message*) {
     result_ = functor_();
   }
   const ReturnT& result() const { return result_; }
@@ -60,7 +61,7 @@ class FunctorMessageHandler<void, FunctorT> : public MessageHandler {
  public:
   explicit FunctorMessageHandler(const FunctorT& functor)
       : functor_(functor) {}
-  virtual void OnMessage(Message* msg) {
+  virtual void OnMessage(Message*) {
     functor_();
   }
   void result() const {}
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/network.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/network.h
index 34d6538c33c..2815cbadd9e 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/network.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/network.h
@@ -19,6 +19,7 @@
 #include <string>
 #include <vector>
 
+#include "webrtc/base/export.h"
 #include "webrtc/base/ipaddress.h"
 #include "webrtc/base/networkmonitor.h"
 #include "webrtc/base/messagehandler.h"
@@ -123,7 +124,7 @@ class NetworkManager : public DefaultLocalAddressProvider {
   // can optionally be called after GetNetworks.
   //
   // TODO(guoweis): remove this body when chromium implements this.
-  virtual void GetAnyAddressNetworks(NetworkList* networks) {}
+  virtual void GetAnyAddressNetworks(NetworkList*) {}
 
   // Dumps the current list of networks in the network manager.
   virtual void DumpNetworks() {}
@@ -140,7 +141,7 @@ class NetworkManager : public DefaultLocalAddressProvider {
 };
 
 // Base class for NetworkManager implementations.
-class NetworkManagerBase : public NetworkManager {
+class WEBRTC_DYLIB_EXPORT NetworkManagerBase : public NetworkManager {
  public:
   NetworkManagerBase();
   ~NetworkManagerBase() override;
@@ -210,7 +211,7 @@ class BasicNetworkManager : public NetworkManagerBase,
                             public MessageHandler,
                             public sigslot::has_slots<> {
  public:
-  BasicNetworkManager();
+  WEBRTC_DYLIB_EXPORT BasicNetworkManager();
   ~BasicNetworkManager() override;
 
   void StartUpdating() override;
@@ -282,7 +283,7 @@ class BasicNetworkManager : public NetworkManagerBase,
 };
 
 // Represents a Unix-type network interface, with a name and single address.
-class Network {
+class WEBRTC_DYLIB_EXPORT Network {
  public:
   Network(const std::string& name,
           const std::string& description,
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/neverdestroyed.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/neverdestroyed.h
new file mode 100644
index 00000000000..93d23d1965e
--- /dev/null
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/neverdestroyed.h
@@ -0,0 +1,33 @@
+/*
+ *  Copyright (c) 2017 Apple Inc. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#pragma once
+
+namespace webrtc {
+
+template<typename T> class NeverDestroyed {
+    NeverDestroyed(const NeverDestroyed&) = delete;
+    NeverDestroyed& operator=(const NeverDestroyed&) = delete;
+public:
+    template<typename... Args>
+    NeverDestroyed(Args&&... args)
+    {
+        new (&m_storage) T(std::forward<Args>(args)...);
+    }
+    operator T&() { return *asPtr(); }
+    T& get() { return *asPtr(); }
+    T* operator&() { return asPtr(); }
+private:
+    typedef typename std::remove_const<T>::type* PointerType;
+    PointerType asPtr() { return reinterpret_cast<PointerType>(&m_storage); }
+    typename std::aligned_storage<sizeof(T), std::alignment_of<T>::value>::type m_storage;
+};
+
+}
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/openssladapter.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/base/openssladapter.cc
index c098412113a..73b68753bb6 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/openssladapter.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/openssladapter.cc
@@ -347,6 +347,11 @@ OpenSSLAdapter::BeginSSL() {
   }
 
   SSL_set_app_data(ssl_, this);
+  // WEBKIT change start
+  if (ssl_host_name_.length()) {
+    SSL_set_tlsext_host_name(ssl_, ssl_host_name_.c_str());
+  }
+  // WEBKIT change end
 
   SSL_set_bio(ssl_, bio, bio);
   // SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER allows different buffers to be passed
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/opensslidentity.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/base/opensslidentity.cc
index 9495496ffe8..d20ef556410 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/opensslidentity.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/opensslidentity.cc
@@ -407,11 +407,11 @@ OpenSSLCertificate* OpenSSLCertificate::GetReference() const {
 std::string OpenSSLCertificate::ToPEMString() const {
   BIO* bio = BIO_new(BIO_s_mem());
   if (!bio) {
-    FATAL() << "unreachable code";
+    RTC_FATAL() << "unreachable code";
   }
   if (!PEM_write_bio_X509(bio, x509_)) {
     BIO_free(bio);
-    FATAL() << "unreachable code";
+    RTC_FATAL() << "unreachable code";
   }
   BIO_write(bio, "\0", 1);
   char* buffer;
@@ -428,11 +428,11 @@ void OpenSSLCertificate::ToDER(Buffer* der_buffer) const {
   // Calculates the DER representation of the certificate, from scratch.
   BIO* bio = BIO_new(BIO_s_mem());
   if (!bio) {
-    FATAL() << "unreachable code";
+    RTC_FATAL() << "unreachable code";
   }
   if (!i2d_X509_bio(bio, x509_)) {
     BIO_free(bio);
-    FATAL() << "unreachable code";
+    RTC_FATAL() << "unreachable code";
   }
   char* data;
   size_t length = BIO_get_mem_data(bio, &data);
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/proxyinfo.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/proxyinfo.h
index 2251b13ee2e..723bad2bdcc 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/proxyinfo.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/proxyinfo.h
@@ -12,8 +12,9 @@
 #define WEBRTC_BASE_PROXYINFO_H__
 
 #include <string>
-#include "webrtc/base/socketaddress.h"
 #include "webrtc/base/cryptstring.h"
+#include "webrtc/base/export.h"
+#include "webrtc/base/socketaddress.h"
 
 namespace rtc {
 
@@ -25,7 +26,7 @@ enum ProxyType {
 };
 const char * ProxyToString(ProxyType proxy);
 
-struct ProxyInfo {
+struct WEBRTC_DYLIB_EXPORT ProxyInfo {
   ProxyType type;
   SocketAddress address;
   std::string autoconfig_url;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/safe_conversions.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/safe_conversions.h
index ff9cc44bc2c..2a44f5648ed 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/safe_conversions.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/safe_conversions.h
@@ -63,11 +63,11 @@ inline Dst saturated_cast(Src value) {
 
     // Should fail only on attempting to assign NaN to a saturated integer.
     case internal::TYPE_INVALID:
-      FATAL();
+      RTC_FATAL();
       return std::numeric_limits<Dst>::max();
   }
 
-  FATAL();
+  RTC_FATAL();
   return static_cast<Dst>(value);
 }
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/safe_conversions_impl.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/safe_conversions_impl.h
index 52e52eff823..63daeb91815 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/safe_conversions_impl.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/safe_conversions_impl.h
@@ -113,7 +113,7 @@ struct RangeCheckImpl {};
 // Dst range always contains the result: nothing to check.
 template <typename Dst, typename Src, DstSign IsDstSigned, SrcSign IsSrcSigned>
 struct RangeCheckImpl<Dst, Src, IsDstSigned, IsSrcSigned, CONTAINS_RANGE> {
-  static RangeCheckResult Check(Src value) {
+  static RangeCheckResult Check(Src) {
     return TYPE_VALID;
   }
 };
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/sanitizer.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/sanitizer.h
index e27a692164a..c5f83c8eace 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/sanitizer.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/sanitizer.h
@@ -50,6 +50,10 @@ static inline void rtc_AsanPoison(const volatile void* ptr,
                                   size_t num_elements) {
 #if RTC_HAS_ASAN
   ASAN_POISON_MEMORY_REGION(ptr, element_size * num_elements);
+#else
+  (void)ptr;
+  (void)element_size;
+  (void)num_elements;
 #endif
 }
 
@@ -61,6 +65,10 @@ static inline void rtc_AsanUnpoison(const volatile void* ptr,
                                     size_t num_elements) {
 #if RTC_HAS_ASAN
   ASAN_UNPOISON_MEMORY_REGION(ptr, element_size * num_elements);
+#else
+  (void)ptr;
+  (void)element_size;
+  (void)num_elements;
 #endif
 }
 
@@ -71,6 +79,10 @@ static inline void rtc_MsanMarkUninitialized(const volatile void* ptr,
                                              size_t num_elements) {
 #if RTC_HAS_MSAN
   __msan_poison(ptr, element_size * num_elements);
+#else
+  (void)ptr;
+  (void)element_size;
+  (void)num_elements;
 #endif
 }
 
@@ -82,6 +94,10 @@ static inline void rtc_MsanCheckInitialized(const volatile void* ptr,
                                             size_t num_elements) {
 #if RTC_HAS_MSAN
   __msan_check_mem_is_initialized(ptr, element_size * num_elements);
+#else
+  (void)ptr;
+  (void)element_size;
+  (void)num_elements;
 #endif
 }
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/socketaddress.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/socketaddress.h
index bcff3900b89..34d44deb487 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/socketaddress.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/socketaddress.h
@@ -15,6 +15,7 @@
 #include <vector>
 #include <iosfwd>
 #include "webrtc/base/basictypes.h"
+#include "webrtc/base/export.h"
 #include "webrtc/base/ipaddress.h"
 
 #undef SetPort
@@ -25,7 +26,7 @@ struct sockaddr_storage;
 namespace rtc {
 
 // Records an IP address and port.
-class SocketAddress {
+class WEBRTC_DYLIB_EXPORT SocketAddress {
  public:
   // Creates a nil address.
   SocketAddress();
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/socketserver.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/socketserver.h
index 5eada4a4061..75aae195390 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/socketserver.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/socketserver.h
@@ -35,7 +35,7 @@ class SocketServer : public SocketFactory {
   // When the socket server is installed into a Thread, this function is
   // called to allow the socket server to use the thread's message queue for
   // any messaging that it might need to perform.
-  virtual void SetMessageQueue(MessageQueue* queue) {}
+  virtual void SetMessageQueue(MessageQueue*) {}
 
   // Sleeps until:
   //  1) cms milliseconds have elapsed (unless cms == kForever)
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/stream.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/stream.h
index dbc2ad750a9..f71d91b69bd 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/stream.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/stream.h
@@ -132,7 +132,7 @@ class StreamInterface : public MessageHandler {
   // processed.  Read and ConsumeReadData invalidate the buffer returned by
   // GetReadData.
   virtual const void* GetReadData(size_t* data_len);
-  virtual void ConsumeReadData(size_t used) {}
+  virtual void ConsumeReadData(size_t) {}
 
   // GetWriteBuffer returns a pointer to a buffer which is owned by the stream.
   // The buffer has a capacity of buf_len bytes.  null is returned if there is
@@ -146,7 +146,7 @@ class StreamInterface : public MessageHandler {
   // when it is available.  If the requested amount is too large, return an
   // error.
   virtual void* GetWriteBuffer(size_t* buf_len);
-  virtual void ConsumeWriteBuffer(size_t used) {}
+  virtual void ConsumeWriteBuffer(size_t) {}
 
   // Write data_len bytes found in data, circumventing any throttling which
   // would could cause SR_BLOCK to be returned.  Returns true if all the data
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/stringize_macros.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/stringize_macros.h
index 7e2f44da8ae..8044684f81c 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/stringize_macros.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/stringize_macros.h
@@ -33,6 +33,6 @@
 // Then:
 //   STRINGIZE(A) produces "FOO"
 //   STRINGIZE(B(y)) produces "myobj->FunctionCall(y)"
-#define STRINGIZE(x) STRINGIZE_NO_EXPANSION(x)
+#define RTC_STRINGIZE(x) STRINGIZE_NO_EXPANSION(x)
 
 #endif  // WEBRTC_BASE_STRINGIZE_MACROS_H_
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/thread.h b/Source/ThirdParty/libwebrtc/Source/webrtc/base/thread.h
index 6e5da61005b..1d4934b172d 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/thread.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/thread.h
@@ -22,6 +22,7 @@
 #endif
 #include "webrtc/base/constructormagic.h"
 #include "webrtc/base/event.h"
+#include "webrtc/base/export.h"
 #include "webrtc/base/messagequeue.h"
 #include "webrtc/base/platform_thread_types.h"
 
@@ -100,7 +101,7 @@ class Runnable {
 
 // WARNING! SUBCLASSES MUST CALL Stop() IN THEIR DESTRUCTORS!  See ~Thread().
 
-class LOCKABLE Thread : public MessageQueue {
+class WEBRTC_DYLIB_EXPORT LOCKABLE Thread : public MessageQueue {
  public:
   // Create a new Thread and optionally assign it to the passed SocketServer.
   Thread();
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/base/virtualsocketserver.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/base/virtualsocketserver.cc
index a7e2d309718..ce89c12e029 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/base/virtualsocketserver.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/base/virtualsocketserver.cc
@@ -1030,7 +1030,7 @@ void VirtualSocketServer::UpdateDelayDistribution() {
   }
 }
 
-static double PI = 4 * atan(1.0);
+static const double PI = 3.141592653589793238462643383279502884;
 
 static double Normal(double x, double mean, double stddev) {
   double a = (x - mean) * (x - mean) / (2 * stddev * stddev);
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/include/frame_callback.h b/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/include/frame_callback.h
index 0a2a905008d..4ff5288c54f 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/include/frame_callback.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/include/frame_callback.h
@@ -49,7 +49,7 @@ struct EncodedFrame {
 class EncodedFrameObserver {
  public:
   virtual void EncodedFrameCallback(const EncodedFrame& encoded_frame) = 0;
-  virtual void OnEncodeTiming(int64_t capture_ntp_ms, int encode_duration_ms) {}
+  virtual void OnEncodeTiming(int64_t /* capture_ntp_ms */, int /* encode_duration_ms */) {}
 
  protected:
   virtual ~EncodedFrameObserver() {}
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/include/i420_buffer_pool.h b/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/include/i420_buffer_pool.h
index 454a8cd9d7d..937b95e07c5 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/include/i420_buffer_pool.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/include/i420_buffer_pool.h
@@ -15,6 +15,7 @@
 #include <limits>
 
 #include "webrtc/api/video/i420_buffer.h"
+#include "webrtc/base/export.h"
 #include "webrtc/base/race_checker.h"
 
 namespace webrtc {
@@ -26,7 +27,7 @@ namespace webrtc {
 // changes, old buffers will be purged from the pool.
 // Note that CreateBuffer will crash if more than kMaxNumberOfFramesBeforeCrash
 // are created. This is to prevent memory leaks where frames are not returned.
-class I420BufferPool {
+class WEBRTC_DYLIB_EXPORT I420BufferPool {
  public:
   I420BufferPool()
       : I420BufferPool(false) {}
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/include/video_frame_buffer.h b/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/include/video_frame_buffer.h
index 6b578bce491..2420e3e1847 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/include/video_frame_buffer.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/include/video_frame_buffer.h
@@ -23,7 +23,7 @@ namespace webrtc {
 // This is used for convenience as most native-handle implementations can share
 // many VideoFrame implementations, but need to implement a few others (such
 // as their own destructors or conversion methods back to software I420).
-class NativeHandleBuffer : public VideoFrameBuffer {
+class WEBRTC_DYLIB_EXPORT NativeHandleBuffer : public VideoFrameBuffer {
  public:
   NativeHandleBuffer(void* native_handle, int width, int height);
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/libyuv/include/webrtc_libyuv.h b/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/libyuv/include/webrtc_libyuv.h
index 13e58d2ae48..eb0779d2b6d 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/libyuv/include/webrtc_libyuv.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/libyuv/include/webrtc_libyuv.h
@@ -19,6 +19,7 @@
 #include <vector>
 
 #include "webrtc/api/video/video_frame.h"
+#include "webrtc/base/export.h"
 #include "webrtc/common_types.h"  // VideoTypes.
 #include "webrtc/typedefs.h"
 
@@ -82,7 +83,7 @@ int ExtractBuffer(const VideoFrame& input_frame, size_t size, uint8_t* buffer);
 // remember to delete the I420Buffer forward declaration above. The only
 // exception at the time of this writing is VideoCaptureImpl::IncomingFrame,
 // which still needs libyuv::ConvertToI420.
-int ConvertToI420(VideoType src_video_type,
+WEBRTC_DYLIB_EXPORT int ConvertToI420(VideoType src_video_type,
                   const uint8_t* src_frame,
                   int crop_x,
                   int crop_y,
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/logging/rtc_event_log/rtc_event_log.h b/Source/ThirdParty/libwebrtc/Source/webrtc/logging/rtc_event_log/rtc_event_log.h
index 0d45552bb15..1e43acdb5af 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/logging/rtc_event_log/rtc_event_log.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/logging/rtc_event_log/rtc_event_log.h
@@ -76,7 +76,7 @@ class RtcEventLog {
   // TODO(nisse): webrtc::Clock is deprecated. Delete this method and
   // above forward declaration of Clock when
   // webrtc/system_wrappers/include/clock.h is deleted.
-  static std::unique_ptr<RtcEventLog> Create(const Clock* clock) {
+  static std::unique_ptr<RtcEventLog> Create(const Clock*) {
     return Create();
   }
 
@@ -184,46 +184,46 @@ class RtcEventLog {
 // No-op implementation is used if flag is not set, or in tests.
 class RtcEventLogNullImpl : public RtcEventLog {
  public:
-  bool StartLogging(const std::string& file_name,
-                    int64_t max_size_bytes) override {
+  bool StartLogging(const std::string& /* file_name */,
+                    int64_t /* max_size_bytes */) override {
     return false;
   }
-  bool StartLogging(rtc::PlatformFile platform_file,
-                    int64_t max_size_bytes) override {
+  bool StartLogging(rtc::PlatformFile /* platform_file */,
+                    int64_t /* max_size_bytes */) override {
     return false;
   }
   void StopLogging() override {}
   void LogVideoReceiveStreamConfig(
-      const rtclog::StreamConfig& config) override {}
-  void LogVideoSendStreamConfig(const rtclog::StreamConfig& config) override {}
+      const rtclog::StreamConfig&) override {}
+  void LogVideoSendStreamConfig(const rtclog::StreamConfig&) override {}
   void LogAudioReceiveStreamConfig(
-      const rtclog::StreamConfig& config) override {}
-  void LogAudioSendStreamConfig(const rtclog::StreamConfig& config) override {}
-  void LogRtpHeader(PacketDirection direction,
-                    const uint8_t* header,
-                    size_t packet_length) override {}
-  void LogRtpHeader(PacketDirection direction,
-                    const uint8_t* header,
-                    size_t packet_length,
-                    int probe_cluster_id) override {}
-  void LogRtcpPacket(PacketDirection direction,
-                     const uint8_t* packet,
-                     size_t length) override {}
-  void LogAudioPlayout(uint32_t ssrc) override {}
-  void LogLossBasedBweUpdate(int32_t bitrate_bps,
-                             uint8_t fraction_loss,
-                             int32_t total_packets) override {}
-  void LogDelayBasedBweUpdate(int32_t bitrate_bps,
-                              BandwidthUsage detector_state) override {}
+      const rtclog::StreamConfig&) override {}
+  void LogAudioSendStreamConfig(const rtclog::StreamConfig&) override {}
+  void LogRtpHeader(PacketDirection,
+                    const uint8_t*,
+                    size_t) override {}
+  void LogRtpHeader(PacketDirection,
+                    const uint8_t*,
+                    size_t,
+                    int) override {}
+  void LogRtcpPacket(PacketDirection,
+                     const uint8_t*,
+                     size_t) override {}
+  void LogAudioPlayout(uint32_t) override {}
+  void LogLossBasedBweUpdate(int32_t,
+                             uint8_t,
+                             int32_t) override {}
+  void LogDelayBasedBweUpdate(int32_t,
+                              BandwidthUsage) override {}
   void LogAudioNetworkAdaptation(
-      const AudioEncoderRuntimeConfig& config) override {}
-  void LogProbeClusterCreated(int id,
-                              int bitrate_bps,
-                              int min_probes,
-                              int min_bytes) override{};
-  void LogProbeResultSuccess(int id, int bitrate_bps) override{};
-  void LogProbeResultFailure(int id,
-                             ProbeFailureReason failure_reason) override{};
+      const AudioEncoderRuntimeConfig&) override {}
+  void LogProbeClusterCreated(int,
+                              int,
+                              int,
+                              int) override{};
+  void LogProbeResultSuccess(int, int) override{};
+  void LogProbeResultFailure(int,
+                             ProbeFailureReason) override{};
 };
 
 }  // namespace webrtc
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/mediachannel.h b/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/mediachannel.h
index 816dfd18fc9..ec4a5d93072 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/mediachannel.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/mediachannel.h
@@ -1189,13 +1189,13 @@ class DataMediaChannel : public MediaChannel {
   virtual bool SetRecvParameters(const DataRecvParameters& params) = 0;
 
   // TODO(pthatcher): Implement this.
-  virtual bool GetStats(DataMediaInfo* info) { return true; }
+  virtual bool GetStats(DataMediaInfo*) { return true; }
 
   virtual bool SetSend(bool send) = 0;
   virtual bool SetReceive(bool receive) = 0;
 
-  virtual void OnNetworkRouteChanged(const std::string& transport_name,
-                                     const rtc::NetworkRoute& network_route) {}
+  virtual void OnNetworkRouteChanged(const std::string&,
+                                     const rtc::NetworkRoute&) {}
 
   virtual bool SendData(
       const SendDataParams& params,
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/internalencoderfactory.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/internalencoderfactory.cc
index a8d4f2d2c2c..fcf01b33614 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/internalencoderfactory.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/internalencoderfactory.cc
@@ -34,7 +34,8 @@ bool IsFlexfecAdvertisedFieldTrialEnabled() {
 }  // namespace
 
 InternalEncoderFactory::InternalEncoderFactory() {
-  supported_codecs_.push_back(cricket::VideoCodec(kVp8CodecName));
+  if (webrtc::VP8Decoder::IsSupported())
+    supported_codecs_.push_back(cricket::VideoCodec(kVp8CodecName));
   if (webrtc::VP9Encoder::IsSupported())
     supported_codecs_.push_back(cricket::VideoCodec(kVp9CodecName));
   if (webrtc::H264Encoder::IsSupported()) {
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtcvideocapturer.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtcvideocapturer.cc
index 9e5c9219ec8..e94608e599a 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtcvideocapturer.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtcvideocapturer.cc
@@ -92,10 +92,20 @@ class WebRtcVcmFactory : public WebRtcVcmFactoryInterface {
  public:
   virtual rtc::scoped_refptr<webrtc::VideoCaptureModule> Create(
       const char* device) {
+#if RTC_HAS_ASAN
+    // FIXME: this shouldn't be necessary.
+    return nullptr;
+#else
     return webrtc::VideoCaptureFactory::Create(device);
+#endif
   }
   virtual webrtc::VideoCaptureModule::DeviceInfo* CreateDeviceInfo() {
+#if RTC_HAS_ASAN
+    // FIXME: this shouldn't be necessary.
+    return nullptr;
+#else
     return webrtc::VideoCaptureFactory::CreateDeviceInfo();
+#endif
   }
   virtual void DestroyDeviceInfo(webrtc::VideoCaptureModule::DeviceInfo* info) {
     delete info;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtcvideodecoderfactory.h b/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtcvideodecoderfactory.h
index 7f0921fd12b..482274e2b89 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtcvideodecoderfactory.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtcvideodecoderfactory.h
@@ -32,7 +32,7 @@ class WebRtcVideoDecoderFactory {
       webrtc::VideoCodecType type) = 0;
   virtual webrtc::VideoDecoder* CreateVideoDecoderWithParams(
       webrtc::VideoCodecType type,
-      VideoDecoderParams params) {
+      VideoDecoderParams) {
     return CreateVideoDecoder(type);
   }
   virtual ~WebRtcVideoDecoderFactory() {}
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtcvideoencoderfactory.h b/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtcvideoencoderfactory.h
index 208ab8b16bb..3a9dd1761df 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtcvideoencoderfactory.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtcvideoencoderfactory.h
@@ -22,7 +22,7 @@ class VideoEncoder;
 
 namespace cricket {
 
-class WebRtcVideoEncoderFactory {
+class WEBRTC_DYLIB_EXPORT WebRtcVideoEncoderFactory {
  public:
   virtual ~WebRtcVideoEncoderFactory() {}
 
@@ -39,7 +39,7 @@ class WebRtcVideoEncoderFactory {
   // frames to be delivered via webrtc::VideoEncoder::Encode. This flag is used
   // as the internal_source parameter to
   // webrtc::ViEExternalCodec::RegisterExternalSendCodec.
-  virtual bool EncoderTypeHasInternalSource(webrtc::VideoCodecType type) const {
+  virtual bool EncoderTypeHasInternalSource(webrtc::VideoCodecType) const {
     return false;
   }
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtcvideoengine.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtcvideoengine.cc
index e592740bb92..855200a78ed 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtcvideoengine.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/media/engine/webrtcvideoengine.cc
@@ -111,11 +111,13 @@ class WebRtcSimulcastEncoderFactory
   webrtc::VideoEncoder* CreateVideoEncoder(
       const cricket::VideoCodec& codec) override {
     RTC_DCHECK(factory_ != NULL);
+#if !defined(RTC_DISABLE_VP8)
     // If it's a codec type we can simulcast, create a wrapped encoder.
     if (CodecNamesEq(codec.name.c_str(), kVp8CodecName)) {
       return new webrtc::SimulcastEncoderAdapter(
           new EncoderFactoryAdapter(factory_));
     }
+#endif
     webrtc::VideoEncoder* encoder = factory_->CreateVideoEncoder(codec);
     if (encoder) {
       non_simulcast_encoders_.push_back(encoder);
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/sctptransport.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/sctptransport.cc
index 45e8decb387..05268f450b7 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/sctptransport.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/sctptransport.cc
@@ -260,7 +260,12 @@ class SctpTransport::UsrSctpWrapper {
         return;
       }
 
+      // WEBKIT Change: disabling the blocking assertion as this is what SleepMs is about.
+      // FIXME: ensure usrsctp_finish is probably called without making blocking calls.
+      bool allowBlockingCalls = rtc::Thread::Current()->SetAllowBlockingCalls(true);
       rtc::Thread::SleepMs(10);
+      if (!allowBlockingCalls)
+        rtc::Thread::Current()->SetAllowBlockingCalls(false);
     }
     LOG(LS_ERROR) << "Failed to shutdown usrsctp.";
   }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/audio_coding_module.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/audio_coding_module.cc
index 2fcbecf3796..cebefd62342 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/audio_coding_module.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/audio_coding_module.cc
@@ -1203,7 +1203,7 @@ int AudioCodingModuleImpl::SetOpusApplication(OpusApplicationMode application) {
       app = AudioEncoder::Application::kAudio;
       break;
     default:
-      FATAL();
+      RTC_FATAL();
       return 0;
   }
   return encoder_stack_->SetApplication(app) ? 0 : -1;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/rent_a_codec.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/rent_a_codec.cc
index 79491b83a66..f353553171c 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/rent_a_codec.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/rent_a_codec.cc
@@ -219,7 +219,7 @@ std::unique_ptr<AudioEncoder> CreateCngEncoder(
       config.vad_mode = Vad::kVadVeryAggressive;
       break;
     default:
-      FATAL();
+      RTC_FATAL();
   }
   return std::unique_ptr<AudioEncoder>(new AudioEncoderCng(std::move(config)));
 }
@@ -234,7 +234,7 @@ std::unique_ptr<AudioDecoder> CreateIsacDecoder(
   return std::unique_ptr<AudioDecoder>(
       new AudioDecoderIsac(sample_rate_hz, bwinfo));
 #else
-  FATAL() << "iSAC is not supported.";
+  RTC_FATAL() << "iSAC is not supported.";
   return std::unique_ptr<AudioDecoder>();
 #endif
 }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/builtin_audio_decoder_factory_internal.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/builtin_audio_decoder_factory_internal.cc
index cbf735ee2e6..b404f604a19 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/builtin_audio_decoder_factory_internal.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/builtin_audio_decoder_factory_internal.cc
@@ -14,6 +14,7 @@
 #include <vector>
 
 #include "webrtc/base/checks.h"
+#include "webrtc/base/neverdestroyed.h"
 #include "webrtc/base/optional.h"
 #include "webrtc/common_types.h"
 #include "webrtc/modules/audio_coding/codecs/cng/webrtc_cng.h"
@@ -50,7 +51,8 @@ struct NamedDecoderConstructor {
 
 // TODO(kwiberg): These factory functions should probably be moved to each
 // decoder.
-NamedDecoderConstructor decoder_constructors[] = {
+static const std::vector<NamedDecoderConstructor>& decoder_constructors() {
+  static NeverDestroyed<std::vector<NamedDecoderConstructor>> decoder_constructors = [] { return std::vector<NamedDecoderConstructor>({
     {"pcmu",
      [](const SdpAudioFormat& format, std::unique_ptr<AudioDecoder>* out) {
        if (format.clockrate_hz == 8000 && format.num_channels >= 1) {
@@ -170,14 +172,16 @@ NamedDecoderConstructor decoder_constructors[] = {
        }
      }},
 #endif
-};
+  });}();
+  return decoder_constructors.get();
+}
 
 class BuiltinAudioDecoderFactory : public AudioDecoderFactory {
  public:
   std::vector<AudioCodecSpec> GetSupportedDecoders() override {
     // Although this looks a bit strange, it means specs need only be
     // initialized once, and that that initialization is thread-safe.
-    static std::vector<AudioCodecSpec> specs = [] {
+    static NeverDestroyed<std::vector<AudioCodecSpec>> specs = [] {
       std::vector<AudioCodecSpec> specs;
 #ifdef WEBRTC_CODEC_OPUS
       AudioCodecInfo opus_info{48000, 1, 64000, 6000, 510000};
@@ -217,7 +221,7 @@ class BuiltinAudioDecoderFactory : public AudioDecoderFactory {
   }
 
   bool IsSupportedDecoder(const SdpAudioFormat& format) override {
-    for (const auto& dc : decoder_constructors) {
+    for (const auto& dc : decoder_constructors()) {
       if (STR_CASE_CMP(format.name.c_str(), dc.name) == 0) {
         return dc.constructor(format, nullptr);
       }
@@ -227,7 +231,7 @@ class BuiltinAudioDecoderFactory : public AudioDecoderFactory {
 
   std::unique_ptr<AudioDecoder> MakeAudioDecoder(
       const SdpAudioFormat& format) override {
-    for (const auto& dc : decoder_constructors) {
+    for (const auto& dc : decoder_constructors()) {
       if (STR_CASE_CMP(format.name.c_str(), dc.name) == 0) {
         std::unique_ptr<AudioDecoder> decoder;
         bool ok = dc.constructor(format, &decoder);
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/cng/audio_encoder_cng.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/cng/audio_encoder_cng.cc
index 993fffea5af..7d028ec4de1 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/cng/audio_encoder_cng.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/cng/audio_encoder_cng.cc
@@ -139,7 +139,7 @@ AudioEncoder::EncodedInfo AudioEncoderCng::EncodeImpl(
       break;
     }
     case Vad::kError: {
-      FATAL();  // Fails only if fed invalid data.
+      RTC_FATAL();  // Fails only if fed invalid data.
       break;
     }
   }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/ilbc/audio_encoder_ilbc.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/ilbc/audio_encoder_ilbc.cc
index 6ed445a97e4..32b18c8db29 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/ilbc/audio_encoder_ilbc.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/ilbc/audio_encoder_ilbc.cc
@@ -55,7 +55,7 @@ int GetIlbcBitrate(int ptime) {
       // 50 bytes per frame of 30 ms => (approx) 13333 bits/s.
       return 13333;
     default:
-      FATAL();
+      RTC_FATAL();
   }
 }
 
@@ -189,7 +189,7 @@ size_t AudioEncoderIlbc::RequiredOutputSizeBytes() const {
     case 3:   return 50;
     case 4:   return 2 * 38;
     case 6:   return 2 * 50;
-    default:  FATAL();
+    default:  RTC_FATAL();
   }
 }
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/neteq/tools/rtp_file_source.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/neteq/tools/rtp_file_source.cc
index 814def12db6..7bc6ffd9962 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/neteq/tools/rtp_file_source.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/neteq/tools/rtp_file_source.cc
@@ -93,7 +93,7 @@ bool RtpFileSource::OpenFile(const std::string& file_name) {
     return true;
   rtp_reader_.reset(RtpFileReader::Create(RtpFileReader::kPcap, file_name));
   if (!rtp_reader_) {
-    FATAL() << "Couldn't open input file as either a rtpdump or .pcap. Note "
+    RTC_FATAL() << "Couldn't open input file as either a rtpdump or .pcap. Note "
                "that .pcapng is not supported.";
   }
   return true;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_device/audio_device_impl.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_device/audio_device_impl.cc
index 45bc3a5aaf6..bd9bd87c3d8 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_device/audio_device_impl.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_device/audio_device_impl.cc
@@ -1722,7 +1722,7 @@ int32_t AudioDeviceModuleImpl::PlayoutSampleRate(
 
 int32_t AudioDeviceModuleImpl::ResetAudioDevice() {
   LOG(INFO) << __FUNCTION__;
-  FATAL() << "Should never be called";
+  RTC_FATAL() << "Should never be called";
   return -1;
 }
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/include/module.h b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/include/module.h
index 432ed409ee0..2141f97677f 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/include/module.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/include/module.h
@@ -53,7 +53,7 @@ class Module {
   //
   // NOTE: This method is not called from the worker thread itself, but from
   //       the thread that registers/deregisters the module or calls Start/Stop.
-  virtual void ProcessThreadAttached(ProcessThread* process_thread) {}
+  virtual void ProcessThreadAttached(ProcessThread*) {}
 
  protected:
   virtual ~Module() {}
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtp_utility.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtp_utility.cc
index f959087c99d..4ec78e26b75 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtp_utility.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtp_utility.cc
@@ -11,6 +11,7 @@
 #include "webrtc/modules/rtp_rtcp/source/rtp_utility.h"
 
 #include "webrtc/base/logging.h"
+#include "webrtc/base/neverdestroyed.h"
 #include "webrtc/modules/rtp_rtcp/include/rtp_cvo.h"
 #include "webrtc/modules/rtp_rtcp/source/byte_io.h"
 #include "webrtc/modules/rtp_rtcp/source/rtp_header_extensions.h"
@@ -18,12 +19,12 @@
 namespace webrtc {
 
 RtpFeedback* NullObjectRtpFeedback() {
-  static NullRtpFeedback null_rtp_feedback;
+  static NeverDestroyed<NullRtpFeedback> null_rtp_feedback;
   return &null_rtp_feedback;
 }
 
 ReceiveStatistics* NullObjectReceiveStatistics() {
-  static NullReceiveStatistics null_receive_statistics;
+  static NeverDestroyed<NullReceiveStatistics> null_receive_statistics;
   return &null_receive_statistics;
 }
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/include/vp8.h b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/include/vp8.h
index dd3514235d4..c9e45ee5b65 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/include/vp8.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/include/vp8.h
@@ -19,6 +19,7 @@ namespace webrtc {
 
 class VP8Encoder : public VideoEncoder {
  public:
+  static bool IsSupported();
   static VP8Encoder* Create();
 
   virtual ~VP8Encoder() {}
@@ -26,6 +27,7 @@ class VP8Encoder : public VideoEncoder {
 
 class VP8Decoder : public VideoDecoder {
  public:
+  static bool IsSupported();
   static VP8Decoder* Create();
 
   virtual ~VP8Decoder() {}
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/vp8_noop.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/vp8_noop.cc
new file mode 100644
index 00000000000..a61c3655190
--- /dev/null
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/vp8_noop.cc
@@ -0,0 +1,39 @@
+/*
+ *  Copyright (c) 2017 Apple Inc. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ *
+ */
+
+#if !defined(RTC_DISABLE_VP8)
+#error
+#endif  // !defined(RTC_DISABLE_VP8)
+
+#include "webrtc/base/checks.h"
+#include "webrtc/modules/video_coding/codecs/vp8/include/vp8.h"
+
+namespace webrtc {
+
+bool VP8Encoder::IsSupported() {
+  return false;
+}
+
+VP8Encoder* VP8Encoder::Create() {
+  RTC_NOTREACHED();
+  return nullptr;
+}
+
+bool VP8Decoder::IsSupported() {
+  return false;
+}
+
+VP8Decoder* VP8Decoder::Create() {
+  RTC_NOTREACHED();
+  return nullptr;
+}
+
+}  // namespace webrtc
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/qp_parser.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/qp_parser.cc
index 26b46f17fbf..0c9a24e324f 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/qp_parser.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/qp_parser.cc
@@ -16,17 +16,8 @@
 
 namespace webrtc {
 
-bool QpParser::GetQp(const VCMEncodedFrame& frame, int* qp) {
-  switch (frame.CodecSpecific()->codecType) {
-    case kVideoCodecVP8:
-      // QP range: [0, 127].
-      return vp8::GetQp(frame.Buffer(), frame.Length(), qp);
-    case kVideoCodecVP9:
-      // QP range: [0, 255].
-      return vp9::GetQp(frame.Buffer(), frame.Length(), qp);
-    default:
-      return false;
-  }
+bool QpParser::GetQp(const VCMEncodedFrame&, int*) {
+  return false;
 }
 
 }  // namespace webrtc
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/video_codec_initializer.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/video_codec_initializer.cc
index 7218cd57caa..5f8f6887e52 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/video_codec_initializer.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/video_codec_initializer.cc
@@ -37,6 +37,7 @@ bool VideoCodecInitializer::SetupCodec(
   std::unique_ptr<TemporalLayersFactory> tl_factory;
   switch (codec->codecType) {
     case kVideoCodecVP8: {
+#if !defined(RTC_DISABLE_VP8)
       if (!codec->VP8()->tl_factory) {
         if (codec->mode == kScreensharing &&
             (codec->numberOfSimulcastStreams > 1 ||
@@ -50,6 +51,7 @@ bool VideoCodecInitializer::SetupCodec(
         }
         codec->VP8()->tl_factory = tl_factory.get();
       }
+#endif
       break;
     }
     default: {
@@ -70,11 +72,13 @@ VideoCodecInitializer::CreateBitrateAllocator(
   std::unique_ptr<VideoBitrateAllocator> rate_allocator;
 
   switch (codec.codecType) {
+#if !defined(RTC_DISABLE_VP8)
     case kVideoCodecVP8: {
       // Set up default VP8 temporal layer factory, if not provided.
       rate_allocator.reset(
           new SimulcastRateAllocator(codec, std::move(tl_factory)));
     } break;
+#endif
     default:
       rate_allocator.reset(new DefaultVideoBitrateAllocator(codec));
   }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/video_sender.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/video_sender.cc
index ab7729745e5..10b8673bf8d 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/video_sender.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/video_sender.cc
@@ -108,6 +108,11 @@ int32_t VideoSender::RegisterSendCodec(const VideoCodec* sendCodec,
   }
 
   // If we have screensharing and we have layers, we disable frame dropper.
+#if defined(WEBRTC_WEBKIT_BUILD)
+  // WEBKIT change: the frame dropper does not work consistently. We disable it for now.
+  // FIXME: Investigate why and enable it again. See https://bugs.webkit.org/show_bug.cgi?id=168973.
+  _mediaOpt.EnableFrameDropper(false);
+#else
   bool disable_frame_dropper =
       numLayers > 1 && sendCodec->mode == kScreensharing;
   if (disable_frame_dropper) {
@@ -115,6 +120,7 @@ int32_t VideoSender::RegisterSendCodec(const VideoCodec* sendCodec,
   } else if (frame_dropper_enabled_) {
     _mediaOpt.EnableFrameDropper(true);
   }
+#endif
 
   {
     rtc::CritScope cs(&params_crit_);
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/basicpacketsocketfactory.h b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/basicpacketsocketfactory.h
index 5046e0f518d..39fb562f0ba 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/basicpacketsocketfactory.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/basicpacketsocketfactory.h
@@ -11,6 +11,7 @@
 #ifndef WEBRTC_P2P_BASE_BASICPACKETSOCKETFACTORY_H_
 #define WEBRTC_P2P_BASE_BASICPACKETSOCKETFACTORY_H_
 
+#include "webrtc/base/export.h"
 #include "webrtc/p2p/base/packetsocketfactory.h"
 
 namespace rtc {
@@ -19,7 +20,7 @@ class AsyncSocket;
 class SocketFactory;
 class Thread;
 
-class BasicPacketSocketFactory : public PacketSocketFactory {
+class WEBRTC_DYLIB_EXPORT BasicPacketSocketFactory : public PacketSocketFactory {
  public:
   BasicPacketSocketFactory();
   explicit BasicPacketSocketFactory(Thread* thread);
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/icetransportinternal.h b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/icetransportinternal.h
index e9b40dc2bb8..5347b3798af 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/icetransportinternal.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/icetransportinternal.h
@@ -63,7 +63,7 @@ class IceTransportInternal : public rtc::PacketTransportInternal {
 
   // TODO(zhihuang): Remove this once it's no longer called in
   // remoting/protocol/libjingle_transport_factory.cc
-  virtual void SetIceProtocolType(IceProtocolType type) {}
+  virtual void SetIceProtocolType(IceProtocolType) {}
 
   virtual void SetIceCredentials(const std::string& ice_ufrag,
                                  const std::string& ice_pwd) {
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/packettransportinternal.h b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/packettransportinternal.h
index 8e32f72480d..b1662f13f0c 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/packettransportinternal.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/packettransportinternal.h
@@ -61,7 +61,7 @@ class PacketTransportInternal : public virtual webrtc::PacketTransportInterface,
 
   // TODO(pthatcher): Once Chrome's MockPacketTransportInterface implements
   // this, remove the default implementation.
-  virtual bool GetOption(rtc::Socket::Option opt, int* value) { return false; }
+  virtual bool GetOption(rtc::Socket::Option, int*) { return false; }
 
   // Returns the most recent error that occurred on this channel.
   virtual int GetError() = 0;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/port.h b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/port.h
index fd6d18290b4..209c0516544 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/port.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/port.h
@@ -250,9 +250,9 @@ class Port : public PortInterface, public rtc::MessageHandler,
   // port implemented this method.
   // TODO(mallinath) - Make it pure virtual.
   virtual bool HandleIncomingPacket(
-      rtc::AsyncPacketSocket* socket, const char* data, size_t size,
-      const rtc::SocketAddress& remote_addr,
-      const rtc::PacketTime& packet_time) {
+      rtc::AsyncPacketSocket*, const char*, size_t,
+      const rtc::SocketAddress&,
+      const rtc::PacketTime&) {
     RTC_NOTREACHED();
     return false;
   }
@@ -383,7 +383,7 @@ class Port : public PortInterface, public rtc::MessageHandler,
   }
 
   // Extra work to be done in subclasses when a connection is destroyed.
-  virtual void HandleConnectionDestroyed(Connection* conn) {}
+  virtual void HandleConnectionDestroyed(Connection*) {}
 
  private:
   void Construct();
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun.h b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun.h
index 4ea45050cab..92c6352f81d 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun.h
@@ -218,7 +218,7 @@ class StunAttribute {
   virtual StunAttributeValueType value_type() const = 0;
 
   // Only XorAddressAttribute needs this so far.
-  virtual void SetOwner(StunMessage* owner) {}
+  virtual void SetOwner(StunMessage*) {}
 
   // Reads the body (not the type or length) for this type of attribute from
   // the given buffer.  Return value is true if successful.
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stunrequest.h b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stunrequest.h
index 99dff14aee9..e1aab31a093 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stunrequest.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stunrequest.h
@@ -115,11 +115,11 @@ class StunRequest : public rtc::MessageHandler {
 
   // Fills in a request object to be sent.  Note that request's transaction ID
   // will already be set and cannot be changed.
-  virtual void Prepare(StunMessage* request) {}
+  virtual void Prepare(StunMessage*) {}
 
   // Called when the message receives a response or times out.
-  virtual void OnResponse(StunMessage* response) {}
-  virtual void OnErrorResponse(StunMessage* response) {}
+  virtual void OnResponse(StunMessage*) {}
+  virtual void OnErrorResponse(StunMessage*) {}
   virtual void OnTimeout() {}
   // Called when the message is sent.
   virtual void OnSent();
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/transportchannelimpl.h b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/transportchannelimpl.h
index f72cb2d1b08..21b859b0491 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/transportchannelimpl.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/transportchannelimpl.h
@@ -40,7 +40,7 @@ class TransportChannelImpl : public TransportChannel {
   virtual void SetIceTiebreaker(uint64_t tiebreaker) = 0;
   // TODO(pthatcher): Remove this once it's no longer called in
   // remoting/protocol/libjingle_transport_factory.cc
-  virtual void SetIceProtocolType(IceProtocolType type) {}
+  virtual void SetIceProtocolType(IceProtocolType) {}
   // TODO(honghaiz): Remove this once the call in chromoting is removed.
   virtual void SetIceCredentials(const std::string& ice_ufrag,
                                  const std::string& ice_pwd) {
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/client/basicportallocator.h b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/client/basicportallocator.h
index cd178f965e6..e67c80f279f 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/client/basicportallocator.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/client/basicportallocator.h
@@ -17,6 +17,7 @@
 
 #include "webrtc/p2p/base/portallocator.h"
 #include "webrtc/base/checks.h"
+#include "webrtc/base/export.h"
 #include "webrtc/base/messagequeue.h"
 #include "webrtc/base/network.h"
 #include "webrtc/base/thread.h"
@@ -25,7 +26,7 @@ namespace cricket {
 
 class BasicPortAllocator : public PortAllocator {
  public:
-  BasicPortAllocator(rtc::NetworkManager* network_manager,
+  WEBRTC_DYLIB_EXPORT BasicPortAllocator(rtc::NetworkManager* network_manager,
                      rtc::PacketSocketFactory* socket_factory);
   explicit BasicPortAllocator(rtc::NetworkManager* network_manager);
   BasicPortAllocator(rtc::NetworkManager* network_manager,
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/pc/mediastream.h b/Source/ThirdParty/libwebrtc/Source/webrtc/pc/mediastream.h
index 56fbed95bae..fa59157daab 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/pc/mediastream.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/pc/mediastream.h
@@ -18,10 +18,11 @@
 
 #include "webrtc/api/mediastreaminterface.h"
 #include "webrtc/api/notifier.h"
+#include "webrtc/base/basictypes.h"
 
 namespace webrtc {
 
-class MediaStream : public Notifier<MediaStreamInterface> {
+class WEBRTC_DYLIB_EXPORT MediaStream : public Notifier<MediaStreamInterface> {
  public:
   static rtc::scoped_refptr<MediaStream> Create(const std::string& label);
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/pc/peerconnectionfactory.h b/Source/ThirdParty/libwebrtc/Source/webrtc/pc/peerconnectionfactory.h
index c93594db62f..b9c27b66bb3 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/pc/peerconnectionfactory.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/pc/peerconnectionfactory.h
@@ -86,10 +86,10 @@ class PeerConnectionFactory : public PeerConnectionFactoryInterface {
   bool StartAecDump(rtc::PlatformFile file, int64_t max_size_bytes) override;
   void StopAecDump() override;
   // TODO(ivoc) Remove after Chrome is updated.
-  bool StartRtcEventLog(rtc::PlatformFile file) override { return false; }
+  bool StartRtcEventLog(rtc::PlatformFile) override { return false; }
   // TODO(ivoc) Remove after Chrome is updated.
-  bool StartRtcEventLog(rtc::PlatformFile file,
-                        int64_t max_size_bytes) override {
+  bool StartRtcEventLog(rtc::PlatformFile,
+                        int64_t) override {
     return false;
   }
   // TODO(ivoc) Remove after Chrome is updated.
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/pc/rtcstatscollector.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/pc/rtcstatscollector.cc
index ca995327d5f..d198675f6f0 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/pc/rtcstatscollector.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/pc/rtcstatscollector.cc
@@ -1201,6 +1201,20 @@ std::map<MediaStreamTrackInterface*, std::string>
 RTCStatsCollector::PrepareTrackToID_s() const {
   RTC_DCHECK(signaling_thread_->IsCurrent());
   std::map<MediaStreamTrackInterface*, std::string> track_to_id;
+#if defined(WEBRTC_WEBKIT_BUILD)
+  for (auto& sender : pc_->GetSenders()) {
+    auto track = sender->track();
+    if (!track)
+      continue;
+    track_to_id[track.get()] = track->id();
+  }
+  for (auto& receiver : pc_->GetReceivers()) {
+    auto track = receiver->track();
+    if (!track)
+      continue;
+    track_to_id[track.get()] = track->id();
+  }
+#else
   StreamCollectionInterface* local_and_remote_streams[] =
       { pc_->local_streams().get(), pc_->remote_streams().get() };
   for (auto& streams : local_and_remote_streams) {
@@ -1218,6 +1232,7 @@ RTCStatsCollector::PrepareTrackToID_s() const {
       }
     }
   }
+#endif
   return track_to_id;
 }
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/Video/corevideo_frame_buffer.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/Video/corevideo_frame_buffer.h
index 603cbc01c49..470710a4195 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/Video/corevideo_frame_buffer.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/Video/corevideo_frame_buffer.h
@@ -15,11 +15,12 @@
 
 #include <vector>
 
+#include "webrtc/base/export.h"
 #include "webrtc/common_video/include/video_frame_buffer.h"
 
 namespace webrtc {
 
-class CoreVideoFrameBuffer : public VideoFrameBuffer {
+class WEBRTC_DYLIB_EXPORT CoreVideoFrameBuffer : public VideoFrameBuffer {
  public:
   explicit CoreVideoFrameBuffer(CVPixelBufferRef pixel_buffer);
   CoreVideoFrameBuffer(CVPixelBufferRef pixel_buffer,
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/encoder.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/encoder.h
index 92cd6b7d011..640e5d7c771 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/encoder.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/encoder.h
@@ -14,6 +14,7 @@
 
 #include "webrtc/api/video/video_rotation.h"
 #include "webrtc/base/criticalsection.h"
+#include "webrtc/base/export.h"
 #include "webrtc/common_video/h264/h264_bitstream_parser.h"
 #include "webrtc/common_video/include/bitrate_adjuster.h"
 #include "webrtc/media/base/codec.h"
@@ -30,7 +31,7 @@
 
 namespace webrtc {
 
-class H264VideoToolboxEncoder : public H264Encoder {
+class WEBRTC_DYLIB_EXPORT H264VideoToolboxEncoder : public H264Encoder {
  public:
   explicit H264VideoToolboxEncoder(const cricket::VideoCodec& codec);
 
@@ -68,6 +69,9 @@ class H264VideoToolboxEncoder : public H264Encoder {
 
   ScalingSettings GetScalingSettings() const override;
 
+ protected:
+  virtual int CreateCompressionSession(VTCompressionSessionRef&, VTCompressionOutputCallback, int32_t width, int32_t height, bool useHardwareAcceleratedVideoEncoder = true);
+
  private:
   int ResetCompressionSession();
   void ConfigureCompressionSession();
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/encoder.mm b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/encoder.mm
index 1d37ebaed62..c4a5a1bd372 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/encoder.mm
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/encoder.mm
@@ -524,6 +524,17 @@ int H264VideoToolboxEncoder::Release() {
 int H264VideoToolboxEncoder::ResetCompressionSession() {
   DestroyCompressionSession();
 
+  int status = CreateCompressionSession(compression_session_, internal::VTCompressionOutputCallback, width_, height_);
+  if (status != noErr) {
+    LOG(LS_ERROR) << "Failed to create compression session: " << status;
+    return WEBRTC_VIDEO_CODEC_ERROR;
+  }
+  ConfigureCompressionSession();
+  return WEBRTC_VIDEO_CODEC_OK;
+}
+
+int H264VideoToolboxEncoder::CreateCompressionSession(VTCompressionSessionRef& compressionSession, VTCompressionOutputCallback outputCallback, int32_t width, int32_t height, bool useHardwareAcceleratedVideoEncoder) {
+
   // Set source image buffer attributes. These attributes will be present on
   // buffers retrieved from the encoder's pixel buffer pool.
   const size_t attributes_size = 3;
@@ -553,23 +564,34 @@ int H264VideoToolboxEncoder::ResetCompressionSession() {
     CFRelease(pixel_format);
     pixel_format = nullptr;
   }
+
+#if defined(WEBRTC_USE_VTB_HARDWARE_ENCODER)
+  CFTypeRef sessionKeys[] = {kVTVideoEncoderSpecification_EnableHardwareAcceleratedVideoEncoder};
+  CFTypeRef sessionValues[] = {useHardwareAcceleratedVideoEncoder ? kCFBooleanTrue : kCFBooleanFalse};
+  CFDictionaryRef encoderSpecification = internal::CreateCFDictionary(sessionKeys, sessionValues, 1);
+#else
+  CFDictionaryRef encoderSpecification = nullptr;
+#endif
+
   OSStatus status = VTCompressionSessionCreate(
       nullptr,  // use default allocator
-      width_, height_, kCMVideoCodecType_H264,
-      nullptr,  // use default encoder
+      width, height, kCMVideoCodecType_H264,
+      encoderSpecification,  // use default encoder
       source_attributes,
       nullptr,  // use default compressed data allocator
-      internal::VTCompressionOutputCallback, this, &compression_session_);
+      outputCallback, this, &compression_session_);
   if (source_attributes) {
     CFRelease(source_attributes);
     source_attributes = nullptr;
   }
-  if (status != noErr) {
-    LOG(LS_ERROR) << "Failed to create compression session: " << status;
-    return WEBRTC_VIDEO_CODEC_ERROR;
+
+#if defined(WEBRTC_USE_VTB_HARDWARE_ENCODER)
+  if (encoderSpecification) {
+    CFRelease(encoderSpecification);
+    encoderSpecification = nullptr;
   }
-  ConfigureCompressionSession();
-  return WEBRTC_VIDEO_CODEC_OK;
+#endif
+  return status;
 }
 
 void H264VideoToolboxEncoder::ConfigureCompressionSession() {
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/videocodecfactory.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/videocodecfactory.h
index 2332bbceca2..517d00c8738 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/videocodecfactory.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/videocodecfactory.h
@@ -16,7 +16,7 @@
 
 namespace webrtc {
 
-class VideoToolboxVideoEncoderFactory
+class WEBRTC_DYLIB_EXPORT VideoToolboxVideoEncoderFactory
     : public cricket::WebRtcVideoEncoderFactory {
  public:
   VideoToolboxVideoEncoderFactory();
@@ -28,12 +28,14 @@ class VideoToolboxVideoEncoderFactory
   const std::vector<cricket::VideoCodec>& supported_codecs() const override;
 
  private:
+  virtual VideoEncoder* CreateSupportedVideoEncoder(const cricket::VideoCodec& codec);
+
   // TODO(magjed): Mutable because it depends on a field trial and it is
   // recalculated every call to supported_codecs().
   mutable std::vector<cricket::VideoCodec> supported_codecs_;
 };
 
-class VideoToolboxVideoDecoderFactory
+class WEBRTC_DYLIB_EXPORT VideoToolboxVideoDecoderFactory
     : public cricket::WebRtcVideoDecoderFactory {
  public:
   VideoToolboxVideoDecoderFactory();
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/videocodecfactory.mm b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/videocodecfactory.mm
index 1aa5ba3d28d..88aa86c1a66 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/videocodecfactory.mm
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/videocodecfactory.mm
@@ -36,12 +36,16 @@ VideoEncoder* VideoToolboxVideoEncoderFactory::CreateVideoEncoder(
     const cricket::VideoCodec& codec) {
   if (FindMatchingCodec(supported_codecs_, codec)) {
     LOG(LS_INFO) << "Creating HW encoder for " << codec.name;
-    return new H264VideoToolboxEncoder(codec);
+    return CreateSupportedVideoEncoder(codec);
   }
   LOG(LS_INFO) << "No HW encoder found for codec " << codec.name;
   return nullptr;
 }
 
+VideoEncoder* VideoToolboxVideoEncoderFactory::CreateSupportedVideoEncoder(const cricket::VideoCodec& codec) {
+  return new H264VideoToolboxEncoder(codec);
+}
+
 void VideoToolboxVideoEncoderFactory::DestroyVideoEncoder(VideoEncoder* encoder) {
   delete encoder;
   encoder = nullptr;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/system_wrappers/source/clock.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/system_wrappers/source/clock.cc
index f65adfcbb18..56396920616 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/system_wrappers/source/clock.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/system_wrappers/source/clock.cc
@@ -20,6 +20,7 @@
 #endif
 
 #include "webrtc/base/criticalsection.h"
+#include "webrtc/base/neverdestroyed.h"
 #include "webrtc/base/timeutils.h"
 #include "webrtc/system_wrappers/include/rw_lock_wrapper.h"
 
@@ -218,7 +219,7 @@ Clock* Clock::GetRealTimeClock() {
   }
   return g_shared_clock;
 #elif defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
-  static UnixRealTimeClock clock;
+  static NeverDestroyed<UnixRealTimeClock> clock;
   return &clock;
 #else
   return NULL;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/voice_engine/utility.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/voice_engine/utility.cc
index f877c43b15a..04a550fe392 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/voice_engine/utility.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/voice_engine/utility.cc
@@ -59,7 +59,7 @@ void RemixAndResample(const int16_t* src_data,
 
   if (resampler->InitializeIfNeeded(sample_rate_hz, dst_frame->sample_rate_hz_,
                                     audio_ptr_num_channels) == -1) {
-    FATAL() << "InitializeIfNeeded failed: sample_rate_hz = " << sample_rate_hz
+    RTC_FATAL() << "InitializeIfNeeded failed: sample_rate_hz = " << sample_rate_hz
             << ", dst_frame->sample_rate_hz_ = " << dst_frame->sample_rate_hz_
             << ", audio_ptr_num_channels = " << audio_ptr_num_channels;
   }
@@ -73,7 +73,7 @@ void RemixAndResample(const int16_t* src_data,
                                        dst_frame->mutable_data(),
                                        AudioFrame::kMaxDataSizeSamples);
   if (out_length == -1) {
-    FATAL() << "Resample failed: audio_ptr = " << audio_ptr
+    RTC_FATAL() << "Resample failed: audio_ptr = " << audio_ptr
             << ", src_length = " << src_length
             << ", dst_frame->mutable_data() = " << dst_frame->mutable_data();
   }
