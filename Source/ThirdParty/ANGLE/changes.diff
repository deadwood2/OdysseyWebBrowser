diff --git a/src/common/utilities.cpp b/src/common/utilities.cpp
index 87932a53f..83ea168e2 100644
--- a/src/common/utilities.cpp
+++ b/src/common/utilities.cpp
@@ -6,6 +6,9 @@
 
 // utilities.cpp: Conversion functions and other utility routines.
 
+// Older clang versions have a false positive on this warning here.
+#pragma clang diagnostic ignored "-Wglobal-constructors"
+
 #include "common/utilities.h"
 #include <GLSLANG/ShaderVars.h>
 #include "GLES3/gl3.h"
diff --git a/src/compiler/preprocessor/preprocessor_tab_autogen.cpp b/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
index 4711774cd..cf25e4823 100644
--- a/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
+++ b/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
@@ -1,5 +1,7 @@
 /* A Bison parser, made by GNU Bison 3.3.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2019 Free Software Foundation,
diff --git a/src/compiler/translator/glslang_tab_autogen.cpp b/src/compiler/translator/glslang_tab_autogen.cpp
index 8c9fd3298..3962a214b 100644
--- a/src/compiler/translator/glslang_tab_autogen.cpp
+++ b/src/compiler/translator/glslang_tab_autogen.cpp
@@ -1,5 +1,7 @@
 /* A Bison parser, made by GNU Bison 3.3.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2019 Free Software Foundation,
diff --git a/src/compiler/translator/glslang_tab_autogen.h b/src/compiler/translator/glslang_tab_autogen.h
index e0e8d6447..ebf8d90f5 100644
--- a/src/compiler/translator/glslang_tab_autogen.h
+++ b/src/compiler/translator/glslang_tab_autogen.h
@@ -1,5 +1,7 @@
 /* A Bison parser, made by GNU Bison 3.3.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of the BSD license. */
+
 /* Bison interface for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2019 Free Software Foundation,
diff --git a/src/libANGLE/State.cpp b/src/libANGLE/State.cpp
index 207bc3997..fa1bd2f16 100644
--- a/src/libANGLE/State.cpp
+++ b/src/libANGLE/State.cpp
@@ -6,6 +6,9 @@
 
 // State.cpp: Implements the State class, encapsulating raw GL state.
 
+// Older clang versions have a false positive on this warning here.
+#pragma clang diagnostic ignored "-Wglobal-constructors"
+
 #include "libANGLE/State.h"
 
 #include <string.h>
diff --git a/src/libANGLE/renderer/gl/cgl/DisplayCGL.mm b/src/libANGLE/renderer/gl/cgl/DisplayCGL.mm
index 148213933..cd8a6ca6b 100644
--- a/src/libANGLE/renderer/gl/cgl/DisplayCGL.mm
+++ b/src/libANGLE/renderer/gl/cgl/DisplayCGL.mm
@@ -292,7 +292,7 @@ egl::Error DisplayCGL::restoreLostDevice(const egl::Display *display)
 
 bool DisplayCGL::isValidNativeWindow(EGLNativeWindowType window) const
 {
-    NSObject *layer = (__bridge NSObject *)window;
+    NSObject *layer = reinterpret_cast<NSObject *>(window);
     return [layer isKindOfClass:[CALayer class]];
 }
 
diff --git a/src/libANGLE/renderer/gl/cgl/WindowSurfaceCGL.mm b/src/libANGLE/renderer/gl/cgl/WindowSurfaceCGL.mm
index 1c1fd2252..54d8320ea 100644
--- a/src/libANGLE/renderer/gl/cgl/WindowSurfaceCGL.mm
+++ b/src/libANGLE/renderer/gl/cgl/WindowSurfaceCGL.mm
@@ -153,7 +153,7 @@ WindowSurfaceCGL::WindowSurfaceCGL(const egl::SurfaceState &state,
     : SurfaceGL(state),
       mSwapLayer(nil),
       mCurrentSwapId(0),
-      mLayer((__bridge CALayer *)layer),
+      mLayer(reinterpret_cast<CALayer *>(layer)),
       mContext(context),
       mFunctions(renderer->getFunctions()),
       mStateManager(renderer->getStateManager()),
diff --git a/src/libANGLE/renderer/gl/eagl/DisplayEAGL.mm b/src/libANGLE/renderer/gl/eagl/DisplayEAGL.mm
index 552285160..797d3b75c 100644
--- a/src/libANGLE/renderer/gl/eagl/DisplayEAGL.mm
+++ b/src/libANGLE/renderer/gl/eagl/DisplayEAGL.mm
@@ -107,6 +107,7 @@ void DisplayEAGL::terminate()
     if (mContext != nullptr)
     {
         [EAGLContext setCurrentContext:nil];
+        [mContext release];
         mContext = nullptr;
     }
 }
@@ -237,7 +238,7 @@ egl::Error DisplayEAGL::restoreLostDevice(const egl::Display *display)
 
 bool DisplayEAGL::isValidNativeWindow(EGLNativeWindowType window) const
 {
-    NSObject *layer = (__bridge NSObject *)window;
+    NSObject *layer = reinterpret_cast<NSObject *>(window);
     return [layer isKindOfClass:[CALayer class]];
 }
 
@@ -328,6 +329,7 @@ WorkerContextEAGL::WorkerContextEAGL(EAGLContextObj context) : mContext(context)
 WorkerContextEAGL::~WorkerContextEAGL()
 {
     [EAGLContext setCurrentContext:nil];
+    [mContext release];
     mContext = nullptr;
 }
 
diff --git a/src/libANGLE/renderer/gl/eagl/WindowSurfaceEAGL.mm b/src/libANGLE/renderer/gl/eagl/WindowSurfaceEAGL.mm
index cb482d05b..6cef7d3dd 100644
--- a/src/libANGLE/renderer/gl/eagl/WindowSurfaceEAGL.mm
+++ b/src/libANGLE/renderer/gl/eagl/WindowSurfaceEAGL.mm
@@ -119,7 +119,7 @@ WindowSurfaceEAGL::WindowSurfaceEAGL(const egl::SurfaceState &state,
     : SurfaceGL(state),
       mSwapLayer(nil),
       mCurrentSwapId(0),
-      mLayer((__bridge CALayer *)layer),
+      mLayer(reinterpret_cast<CALayer *>(layer)),
       mContext(context),
       mFunctions(renderer->getFunctions()),
       mStateManager(renderer->getStateManager()),
@@ -141,6 +141,7 @@ WindowSurfaceEAGL::~WindowSurfaceEAGL()
     if (mSwapLayer != nil)
     {
         [mSwapLayer removeFromSuperlayer];
+        [mSwapLayer release];
         mSwapLayer = nil;
     }
 
diff --git a/Source/ThirdParty/ANGLE/src/tests/perf_tests/glmark2Benchmark.cpp b/Source/ThirdParty/ANGLE/src/tests/perf_tests/glmark2Benchmark.cpp
deleted file mode 100644
index 174fcc6735a..00000000000
--- a/Source/ThirdParty/ANGLE/src/tests/perf_tests/glmark2Benchmark.cpp
+++ /dev/null
@@ -1,285 +0,0 @@
-//
-// Copyright 2019 The ANGLE Project Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-//
-// glmark2Benchmark:
-//   Runs the glmark2 benchmark.
-//
-
-#include <gtest/gtest.h>
-
-#include <stdio.h>
-#include <sstream>
-
-#include "../perf_tests/third_party/perf/perf_result_reporter.h"
-#include "ANGLEPerfTestArgs.h"
-#include "common/platform.h"
-#include "common/system_utils.h"
-#include "test_utils/angle_test_configs.h"
-#include "test_utils/angle_test_instantiate.h"
-#include "util/test_utils.h"
-
-using namespace angle;
-
-namespace
-{
-
-struct BenchmarkInfo
-{
-    const char *glmark2Config;
-    const char *name;
-};
-
-// Each glmark2 scene is individually benchmarked.  If glmark2 is run without a specific benchmark,
-// it can produce an aggregate score, which is not interesting at the moment.  Adding an empty
-// string ("") to this list will enable a test where glmark2 is run with the default scenes and the
-// score for each test as well as the overall score is output.
-constexpr BenchmarkInfo kBenchmarks[] = {
-    {"build:use-vbo=false", "build"},
-    {"build:use-vbo=true", "build_vbo"},
-    {"texture:texture-filter=nearest", "texture_nearest"},
-    {"texture:texture-filter=linear", "texture_linear"},
-    {"texture:texture-filter=mipmap", "texture_mipmap"},
-    {"shading:shading=gouraud", "shading_gouraud"},
-    {"shading:shading=blinn-phong-inf", "shading_blinn_phong"},
-    {"shading:shading=phong", "shading_phong"},
-    {"shading:shading=cel", "shading_cel"},
-    {"bump:bump-render=high-poly", "bump_high_poly"},
-    {"bump:bump-render=normals", "bump_normals"},
-    {"bump:bump-render=height", "bump_height"},
-    {"effect2d:kernel=0,1,0;1,-4,1;0,1,0;", "effect2d_edge"},
-    {"effect2d:kernel=1,1,1,1,1;1,1,1,1,1;1,1,1,1,1;", "effect2d_blur"},
-    {"pulsar:light=false:quads=5:texture=false", "pulsar"},
-    {"desktop:blur-radius=5:effect=blur:passes=1:separable=true:windows=4", "desktop_blur"},
-    {"desktop:effect=shadow:windows=4", "desktop_shadow"},
-    {"buffer:columns=200:interleave=false:update-dispersion=0.9:update-fraction=0.5:update-method="
-     "map",
-     "buffer_map"},
-    {"buffer:columns=200:interleave=false:update-dispersion=0.9:update-fraction=0.5:update-method="
-     "subdata",
-     "buffer_subdata"},
-    {"buffer:columns=200:interleave=true:update-dispersion=0.9:update-fraction=0.5:update-method="
-     "map",
-     "buffer_map_interleave"},
-    {"ideas:speed=duration", "ideas"},
-    {"jellyfish", "jellyfish"},
-    {"terrain", "terrain"},
-    {"shadow", "shadow"},
-    {"refract", "refract"},
-    {"conditionals:fragment-steps=0:vertex-steps=0", "conditionals"},
-    {"conditionals:fragment-steps=5:vertex-steps=0", "conditionals_fragment"},
-    {"conditionals:fragment-steps=0:vertex-steps=5", "conditionals_vertex"},
-    {"function:fragment-complexity=low:fragment-steps=5", "function"},
-    {"function:fragment-complexity=medium:fragment-steps=5", "function_complex"},
-    {"loop:fragment-loop=false:fragment-steps=5:vertex-steps=5", "loop_no_fsloop"},
-    {"loop:fragment-steps=5:fragment-uniform=false:vertex-steps=5", "loop_no_uniform"},
-    {"loop:fragment-steps=5:fragment-uniform=true:vertex-steps=5", "loop"},
-};
-
-using GLMark2BenchmarkTestParams = std::tuple<PlatformParameters, size_t>;
-std::string GLMark2BenchmarkPrint(
-    const ::testing::TestParamInfo<GLMark2BenchmarkTestParams> &paramsInfo)
-{
-    const GLMark2BenchmarkTestParams &params = paramsInfo.param;
-    std::ostringstream out;
-
-    out << std::get<0>(params) << '_';
-    out << kBenchmarks[std::get<1>(params)].name;
-
-    return out.str();
-}
-
-class GLMark2Benchmark : public testing::TestWithParam<GLMark2BenchmarkTestParams>
-{
-  public:
-    GLMark2Benchmark()
-    {
-        switch (std::get<0>(GetParam()).getRenderer())
-        {
-            case EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE:
-                mBackend = "d3d11";
-                break;
-            case EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE:
-                mBackend = "gl";
-                break;
-            case EGL_PLATFORM_ANGLE_TYPE_VULKAN_ANGLE:
-                mBackend = "vulkan";
-                break;
-            default:
-                break;
-        }
-        std::string story = kBenchmarks[std::get<1>(GetParam())].name;
-        mReporter = std::make_unique<perf_test::PerfResultReporter>("glmark2_" + mBackend, story);
-        mReporter->RegisterImportantMetric(".fps", "fps");
-        mReporter->RegisterImportantMetric(".score", "score");
-    }
-
-    void run()
-    {
-        // Only supported on Linux and Windows at the moment.
-        if (!IsLinux() && !IsWindows())
-        {
-            return;
-        }
-
-        const BenchmarkInfo benchmarkInfo = kBenchmarks[std::get<1>(GetParam())];
-        const char *benchmark             = benchmarkInfo.glmark2Config;
-        const char *benchmarkName         = benchmarkInfo.name;
-        bool completeRun                  = benchmark == nullptr || benchmark[0] == '\0';
-
-        Optional<std::string> cwd = GetCWD();
-
-        // Set the current working directory to the executable's, as the data path of glmark2 is
-        // set relative to that path.
-        std::string executableDir = GetExecutableDirectory();
-        SetCWD(executableDir.c_str());
-        SetEnvironmentVar("ANGLE_DEFAULT_PLATFORM", mBackend.c_str());
-
-        std::vector<const char *> args = {
-            "glmark2_angle",
-        };
-        if (OneFrame())
-        {
-            args.push_back("--validate");
-        }
-        if (!completeRun)
-        {
-            args.push_back("--benchmark");
-            args.push_back(benchmark);
-            fprintf(stderr, "Running benchmark: %s\n", benchmark);
-        }
-        args.push_back(nullptr);
-
-        ProcessHandle process(args, true, false);
-        ASSERT_TRUE(process && process->started());
-        ASSERT_TRUE(process->finish());
-
-        // Restore the current working directory for the next tests.
-        if (cwd.valid())
-        {
-            SetCWD(cwd.value().c_str());
-        }
-
-        ASSERT_EQ(EXIT_SUCCESS, process->getExitCode());
-
-        if (!OneFrame())
-        {
-            std::string output = process->getStdout();
-            parseOutput(output, benchmarkName, completeRun);
-        }
-    }
-
-  private:
-    void parseOutput(const std::string &output, const char *benchmarkName, bool completeRun)
-    {
-        // Output is in the following format:
-        //
-        // =======================================================
-        //     glmark2 2017.07
-        // =======================================================
-        //     OpenGL Information
-        //     GL_VENDOR:     ...
-        //     GL_RENDERER:   ...
-        //     GL_VERSION:    ...
-        // =======================================================
-        // [test] config: FPS: uint FrameTime: float ms
-        // [test] config: Not Supported
-        // ...
-        // =======================================================
-        //                                   glmark2 Score: uint
-        // =======================================================
-        //
-        // This function skips the header, prints one line for each test/config line where there's
-        // an FPS value, and finally prints the overall score.
-        std::istringstream glmark2Output(output);
-        std::string line;
-
-        // Expect ==== at the top of the header
-        std::getline(glmark2Output, line);
-        ASSERT_EQ('=', line[0]);
-
-        // Skip one line
-        std::getline(glmark2Output, line);
-
-        // Expect ==== in the middle of the header
-        std::getline(glmark2Output, line);
-        ASSERT_EQ('=', line[0]);
-
-        // Skip four lines
-        std::getline(glmark2Output, line);
-        std::getline(glmark2Output, line);
-        std::getline(glmark2Output, line);
-        std::getline(glmark2Output, line);
-
-        // The fourth line is the GL_VERSION.  Expect it to include ANGLE, otherwise we are not
-        // running against ANGLE.
-        ASSERT_NE(line.find("ANGLE"), std::string::npos);
-
-        // Expect ==== at the bottom of the header
-        std::getline(glmark2Output, line);
-        ASSERT_EQ('=', line[0]);
-
-        // Read configs until the top of the footer is reached
-        while (std::getline(glmark2Output, line) && line[0] != '=')
-        {
-            // Parse the line
-            std::istringstream lin(line);
-
-            std::string testName, testConfig;
-            lin >> testName >> testConfig;
-            EXPECT_TRUE(lin);
-
-            std::string fpsTag, frametimeTag;
-            size_t fps;
-            float frametime;
-
-            lin >> fpsTag >> fps >> frametimeTag >> frametime;
-
-            // If the line is not in `FPS: uint FrameTime: Float ms` format, the test is not
-            // supported.  It will be skipped.
-            if (!lin)
-            {
-                continue;
-            }
-
-            EXPECT_EQ("FPS:", fpsTag);
-            EXPECT_EQ("FrameTime:", frametimeTag);
-
-            if (!completeRun)
-            {
-                mReporter->AddResult(".fps", fps);
-            }
-        }
-
-        // Get the score line: `glmark2 Score: uint`
-        std::string glmark2Tag, scoreTag;
-        size_t score;
-        glmark2Output >> glmark2Tag >> scoreTag >> score;
-        EXPECT_TRUE(glmark2Output);
-        EXPECT_EQ("glmark2", glmark2Tag);
-        EXPECT_EQ("Score:", scoreTag);
-
-        if (completeRun)
-        {
-            mReporter->AddResult(".score", score);
-        }
-    }
-
-    std::string mBackend = "invalid";
-    std::unique_ptr<perf_test::PerfResultReporter> mReporter;
-};
-
-TEST_P(GLMark2Benchmark, Run)
-{
-    run();
-}
-
-ANGLE_INSTANTIATE_TEST_COMBINE_1(GLMark2Benchmark,
-                                 GLMark2BenchmarkPrint,
-                                 testing::Range(static_cast<size_t>(0), ArraySize(kBenchmarks)),
-                                 ES2_D3D11(),
-                                 ES2_OPENGLES(),
-                                 ES2_VULKAN());
-
-}  // namespace
diff --git a/Source/ThirdParty/ANGLE/third_party/glmark2/BUILD.gn b/Source/ThirdParty/ANGLE/third_party/glmark2/BUILD.gn
deleted file mode 100644
index 25ae133986a..00000000000
--- a/Source/ThirdParty/ANGLE/third_party/glmark2/BUILD.gn
+++ /dev/null
@@ -1,423 +0,0 @@
-# Copyright 2019 The ANGLE Project Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-#
-# Build integration for glmark2.
-
-import("../../gni/angle.gni")
-
-_glmark2_glad_common_sources = [
-  "src/src/glad/include/glad/egl.h",
-  "src/src/glad/include/glad/wgl.h",
-  "src/src/glad/src/egl.c",
-]
-
-if (is_win) {
-  _glmark2_glad_common_sources += [ "src/src/glad/src/wgl.c" ]
-}
-
-config("glmark2_glad_config") {
-  include_dirs = [ "src/src/glad/include" ]
-}
-
-source_set("glmark2_glad_gles") {
-  sources = _glmark2_glad_common_sources + [
-              "src/src/glad/include/glad/gles2.h",
-              "src/src/glad/src/gles2.c",
-            ]
-  public_configs = [ ":glmark2_glad_config" ]
-}
-
-source_set("glmark2_glad_gl") {
-  sources = _glmark2_glad_common_sources + [
-              "src/src/glad/include/glad/gl.h",
-              "src/src/glad/src/gl.c",
-            ]
-  public_configs = [ ":glmark2_glad_config" ]
-}
-
-glmark_data_path = "${angle_root}/third_party/glmark2/src/data"
-raw_glmark_data_path = rebase_path(glmark_data_path, root_build_dir)
-
-config("glmark2_common_config") {
-  defines = [ "GLMARK_DATA_PATH=\"${raw_glmark_data_path}\"" ]
-  include_dirs = [ "src/src" ]
-  if (is_win) {
-    include_dirs += [ "src/src/include" ]
-
-    # M_PI is nonstandard.
-    defines += [ "_USE_MATH_DEFINES" ]
-
-    if (!is_clang) {
-      cflags = [
-        # MSVC warns about the copyright character being illegal.
-        "/wd4828",
-
-        # A warning generated in scene-effect-2d in vec2::calc_offset
-        "/wd4146",
-      ]
-    }
-  }
-}
-
-config("glmark2_gles_config") {
-  defines = [ "GLMARK2_USE_GLESv2" ]
-}
-
-config("glmark2_gl_config") {
-  defines = [ "GLMARK2_USE_GL" ]
-}
-
-group("glmark2_gles") {
-  public_configs = [
-    ":glmark2_common_config",
-    ":glmark2_gles_config",
-  ]
-  public_deps = [
-    ":glmark2_glad_gles",
-  ]
-}
-
-group("glmark2_gl") {
-  public_configs = [
-    ":glmark2_common_config",
-    ":glmark2_gl_config",
-  ]
-  public_deps = [
-    ":glmark2_glad_gl",
-  ]
-}
-
-# Supplies compatible headers on Win32.
-config("glmark2_headers_config") {
-  if (is_win) {
-    if (is_clang) {
-      cflags = [
-        "-Wno-unused-function",
-        "-Wno-writable-strings",
-        "-Wno-extra-tokens",
-      ]
-    }
-  }
-}
-
-source_set("glmark2_headers") {
-  sources = [
-    "src/src/canvas.h",
-    "src/src/gl-headers.h",
-    "src/src/gl-state-egl.h",
-    "src/src/gl-state.h",
-    "src/src/gl-visual-config.h",
-    "src/src/mesh.h",
-    "src/src/options.h",
-    "src/src/scene.h",
-    "src/src/shared-library.h",
-    "src/src/texture.h",
-  ]
-
-  if (is_linux) {
-    sources += [ "src/src/gl-state-glx.h" ]
-  }
-  if (is_win) {
-    sources += [
-      "src/src/gl-state-wgl.h",
-      "src/src/include/dirent.h",
-      "src/src/include/getopt.h",
-      "src/src/include/sys/time.h",
-    ]
-  }
-  public_configs = [ ":glmark2_headers_config" ]
-  include_dirs = [ "src/src" ]
-}
-
-config("glmark2_libmatrix_config") {
-  include_dirs = [ "src/src/libmatrix" ]
-}
-
-template("glmark2_libmatrix") {
-  source_set(target_name) {
-    forward_variables_from(invoker, "*")
-    sources = [
-      "src/src/libmatrix/gl-if.h",
-      "src/src/libmatrix/log.cc",
-      "src/src/libmatrix/log.h",
-      "src/src/libmatrix/mat.cc",
-      "src/src/libmatrix/mat.h",
-      "src/src/libmatrix/program.cc",
-      "src/src/libmatrix/program.h",
-      "src/src/libmatrix/shader-source.cc",
-      "src/src/libmatrix/shader-source.h",
-      "src/src/libmatrix/stack.h",
-      "src/src/libmatrix/util.cc",
-      "src/src/libmatrix/util.h",
-      "src/src/libmatrix/vec.h",
-    ]
-
-    if (is_clang) {
-      cflags_cc = [ "-Wno-implicit-fallthrough" ]
-    }
-    public_deps = [
-      ":glmark2_headers",
-    ]
-    public_configs = [ ":glmark2_libmatrix_config" ]
-  }
-}
-
-glmark2_libmatrix("glmark2_libmatrix_gles") {
-  deps = [
-    ":glmark2_gles",
-  ]
-}
-
-glmark2_libmatrix("glmark2_libmatrix_gl") {
-  deps = [
-    ":glmark2_gl",
-  ]
-}
-
-config("glmark2_scene_ideas_config") {
-  include_dirs = [ "src/src/scene-ideas" ]
-}
-
-template("glmark2_scene_ideas") {
-  source_set(target_name) {
-    forward_variables_from(invoker, "*")
-    sources = [
-      "src/src/scene-ideas/a.cc",
-      "src/src/scene-ideas/characters.h",
-      "src/src/scene-ideas/d.cc",
-      "src/src/scene-ideas/e.cc",
-      "src/src/scene-ideas/i.cc",
-      "src/src/scene-ideas/lamp.cc",
-      "src/src/scene-ideas/lamp.h",
-      "src/src/scene-ideas/logo.cc",
-      "src/src/scene-ideas/logo.h",
-      "src/src/scene-ideas/m.cc",
-      "src/src/scene-ideas/n.cc",
-      "src/src/scene-ideas/o.cc",
-      "src/src/scene-ideas/s.cc",
-      "src/src/scene-ideas/splines.cc",
-      "src/src/scene-ideas/splines.h",
-      "src/src/scene-ideas/t.cc",
-      "src/src/scene-ideas/table.cc",
-      "src/src/scene-ideas/table.h",
-    ]
-    public_configs = [ ":glmark2_scene_ideas_config" ]
-  }
-}
-
-glmark2_scene_ideas("glmark2_scene_ideas_gles") {
-  deps = [
-    ":glmark2_gles",
-    ":glmark2_libmatrix_gles",
-  ]
-}
-
-glmark2_scene_ideas("glmark2_scene_ideas_gl") {
-  deps = [
-    ":glmark2_gl",
-    ":glmark2_libmatrix_gl",
-  ]
-}
-
-config("glmark2_scene_terrain_config") {
-  include_dirs = [ "src/src/scene-terrain" ]
-}
-
-template("glmark2_scene_terrain") {
-  source_set(target_name) {
-    forward_variables_from(invoker, "*")
-    sources = [
-      "src/src/scene-terrain/base-renderer.cpp",
-      "src/src/scene-terrain/blur-renderer.cpp",
-      "src/src/scene-terrain/copy-renderer.cpp",
-      "src/src/scene-terrain/luminance-renderer.cpp",
-      "src/src/scene-terrain/normal-from-height-renderer.cpp",
-      "src/src/scene-terrain/overlay-renderer.cpp",
-      "src/src/scene-terrain/renderer-chain.cpp",
-      "src/src/scene-terrain/renderer.h",
-      "src/src/scene-terrain/simplex-noise-renderer.cpp",
-      "src/src/scene-terrain/terrain-renderer.cpp",
-      "src/src/scene-terrain/texture-renderer.cpp",
-    ]
-
-    public_configs = [ ":glmark2_scene_terrain_config" ]
-  }
-}
-
-glmark2_scene_terrain("glmark2_scene_terrain_gles") {
-  deps = [
-    ":glmark2_gles",
-    ":glmark2_libmatrix_gles",
-  ]
-}
-
-glmark2_scene_terrain("glmark2_scene_terrain_gl") {
-  deps = [
-    ":glmark2_gl",
-    ":glmark2_libmatrix_gl",
-  ]
-}
-
-template("glmark2_common") {
-  source_set(target_name) {
-    forward_variables_from(invoker, "*")
-    sources = [
-      "src/src/benchmark-collection.cpp",
-      "src/src/benchmark-collection.h",
-      "src/src/benchmark.cpp",
-      "src/src/benchmark.h",
-      "src/src/default-benchmarks.h",
-      "src/src/gl-headers.cpp",
-      "src/src/gl-visual-config.cpp",
-      "src/src/gl-visual-config.h",
-      "src/src/image-reader.cpp",
-      "src/src/image-reader.h",
-      "src/src/main-loop.cpp",
-      "src/src/main-loop.h",
-      "src/src/mesh.cpp",
-      "src/src/model.cpp",
-      "src/src/model.h",
-      "src/src/native-state.h",
-      "src/src/options.cpp",
-      "src/src/scene-buffer.cpp",
-      "src/src/scene-build.cpp",
-      "src/src/scene-bump.cpp",
-      "src/src/scene-clear.cpp",
-      "src/src/scene-collection.h",
-      "src/src/scene-conditionals.cpp",
-      "src/src/scene-default-options.cpp",
-      "src/src/scene-desktop.cpp",
-      "src/src/scene-effect-2d.cpp",
-      "src/src/scene-function.cpp",
-      "src/src/scene-grid.cpp",
-      "src/src/scene-ideas.cpp",
-      "src/src/scene-jellyfish.cpp",
-      "src/src/scene-jellyfish.h",
-      "src/src/scene-loop.cpp",
-      "src/src/scene-pulsar.cpp",
-      "src/src/scene-refract.cpp",
-      "src/src/scene-refract.h",
-      "src/src/scene-shading.cpp",
-      "src/src/scene-shadow.cpp",
-      "src/src/scene-terrain.cpp",
-      "src/src/scene-texture.cpp",
-      "src/src/scene.cpp",
-      "src/src/shared-library.cpp",
-      "src/src/text-renderer.cpp",
-      "src/src/text-renderer.h",
-      "src/src/texture.cpp",
-    ]
-
-    public_deps += [
-      ":glmark2_headers",
-      "${angle_libpng_dir}:libpng",
-      "${angle_root}/third_party:jpeg",
-    ]
-  }
-}
-
-glmark2_common("glmark2_common_gles") {
-  public_deps = [
-    ":glmark2_gles",
-    ":glmark2_libmatrix_gles",
-    ":glmark2_scene_ideas_gles",
-    ":glmark2_scene_terrain_gles",
-  ]
-}
-
-glmark2_common("glmark2_common_gl") {
-  public_deps = [
-    ":glmark2_gl",
-    ":glmark2_libmatrix_gl",
-    ":glmark2_scene_ideas_gl",
-    ":glmark2_scene_terrain_gl",
-  ]
-}
-
-glmark2_version = "2017.07"
-
-template("glmark2_exe") {
-  executable(target_name) {
-    forward_variables_from(invoker, "*")
-    sources += [
-      "src/src/canvas-generic.cpp",
-      "src/src/canvas-generic.h",
-      "src/src/main.cpp",
-    ]
-    data = [
-      "src/data/",
-    ]
-
-    defines += [ "GLMARK_VERSION=\"${glmark2_version}\"" ]
-
-    if (is_win) {
-      defines += [ "GLMARK2_USE_WIN32" ]
-      sources += [
-        "src/src/native-state-win32.cpp",
-        "src/src/native-state-win32.h",
-      ]
-    }
-    if (is_linux) {
-      defines += [ "GLMARK2_USE_X11" ]
-      sources += [
-        "src/src/native-state-x11.cpp",
-        "src/src/native-state-x11.h",
-      ]
-      libs = [ "X11" ]
-    }
-  }
-}
-
-glmark2_exe("glmark2_angle") {
-  sources = [
-    "src/src/gl-state-egl.cpp",
-  ]
-  deps = [
-    ":glmark2_common_gles",
-  ]
-  data_deps = [
-    "${angle_root}:libEGL",
-    "${angle_root}:libGLESv2",
-  ]
-
-  defines = [
-    "EGL_EGL_PROTOTYPES=1",
-    "GLMARK2_USE_EGL",
-  ]
-
-  if (is_linux && !is_component_build) {
-    # Set rpath to find shared libs in a non-component build.
-    public_configs = [ "//build/config/gcc:rpath_for_built_shared_libraries" ]
-  }
-}
-
-if (is_linux) {
-  glmark2_exe("glmark2_glx") {
-    sources = [
-      "src/src/gl-state-glx.cpp",
-      "src/src/glad/include/glad/glx.h",
-      "src/src/glad/src/glx.c",
-    ]
-    deps = [
-      ":glmark2_common_gl",
-    ]
-
-    defines = [ "GLMARK2_USE_GLX" ]
-  }
-}
-
-# opengl32.lib/opengl32.dll are not available on Windows ARM64.
-if (is_win && target_cpu != "arm64") {
-  glmark2_exe("glmark2_wgl") {
-    sources = [
-      "src/src/gl-state-wgl.cpp",
-    ]
-    deps = [
-      ":glmark2_common_gl",
-    ]
-
-    libs = [ "opengl32.lib" ]
-    defines = [ "GLMARK2_USE_WGL" ]
-  }
-}
diff --git a/Source/ThirdParty/ANGLE/third_party/glmark2/README.angle b/Source/ThirdParty/ANGLE/third_party/glmark2/README.angle
deleted file mode 100644
index a2b6371fed8..00000000000
--- a/Source/ThirdParty/ANGLE/third_party/glmark2/README.angle
+++ /dev/null
@@ -1,12 +0,0 @@
-Name: glmark2
-Short Name: glmark2
-URL: https://github.com/glmark2/glmark2
-Security Critical: no
-License: GPL v3
-License File: NOT_SHIPPED
-
-Description:
-glmark2 is an OpenGL 2.0 and ES 2.0 benchmark.
-
-glmark2 is developed by Alexandros Frantzis and Jesse Barker based on the
-original glmark benchmark by Ben Smith.
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/README.md b/Source/ThirdParty/ANGLE/tools/flex-bison/README.md
deleted file mode 100644
index 8dfe1262660..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/README.md
+++ /dev/null
@@ -1,129 +0,0 @@
-# flex and bison binaries
-
-This folder contains the flex and bison binaries. We use these binaries to
-generate the ANGLE translator's lexer and parser.
-
-Use the script [`update_flex_bison_binaries.py`](update_flex_bison_binaries.py)
-to update the versions of these binaries in cloud storage. It must be run on
-Linux or Windows. It will update the SHAs for your platform. After running the
-script run `git commit` and then `git cl upload` to code review using the normal
-review process. You will also want to run
-[`scripts/run_code_generation.py`](../../scripts/run_code_generation.py) to
-update the generated files.
-
-Please update both Windows and Linux binaries at the same time. Use two CLs. One
-for each platform. Note that we don't currently support Mac for generating the
-lexer and parser files. If we do we should add a flex/bison download for Mac as
-well.
-
-Contact jmadill or syoussefi for any help with updating the binaries.
-
-## Updating flex and bison binaries
-
-This is expected to be a rare operation, and is currently done based on the
-following instructions.  Note: get the binaries first on windows, as only a
-single option is available, then build the binaries for the same version on
-Linux.
-
-### On Windows
-
-Install MSys2 (x86_64) from http://www.msys2.org/ on Windows.  `flex` should
-already be installed.  Install bison:
-
-```
-$ pacman -S bison
-```
-
-Note the versions of flex and bison so the same versions can be build on Linux.
-For example:
-
-```
-$ flex --version
-flex 2.6.4
-
-$ bison --version
-bison (GNU Bison) 3.3.2
-```
-
-The only dependencies from MSys2 should be the following:
-
-```
-msys-intl-8.dll
-msys-iconv-2.dll
-msys-2.0.dll
-```
-
-This can be verified with:
-
-```
-$ ldd /usr/bin/flex
-$ ldd /usr/bin/bison
-```
-
-Additionally, we need the binary for m4 at `/usr/bin/m4`.
-
-Copy all these 5 files to this directory:
-
-```
-$ cd angle/
-$ cp /usr/bin/flex.exe \
-     /usr/bin/bison.exe \
-     /usr/bin/m4.exe \
-     /usr/bin/msys-intl-8.dll \
-     /usr/bin/msys-iconv-2.dll \
-     /usr/bin/msys-2.0.dll \
-     tools/flex-bison/windows/
-```
-
-Upload the binaries:
-
-```
-$ cd angle/
-$ python tools/flex-bison/update_flex_bison_binaries.py
-```
-
-### On Linux
-
-```
-# Get the source of flex
-$ git clone https://github.com/westes/flex.git
-$ cd flex/
-# Checkout the same version as msys2 on windows
-$ git checkout v2.6.4
-# Build
-$ autoreconf -i
-$ mkdir build && cd build
-$ ../configure CFLAGS="-O2 -D_GNU_SOURCE"
-$ make -j
-```
-
-```
-# Get the source of bison
-$ curl http://ftp.gnu.org/gnu/bison/bison-3.3.2.tar.xz | tar -xJ
-$ cd bison-3.3.2
-# Build
-$ mkdir build && cd build
-$ ../configure CFLAGS="-O2"
-$ make -j
-```
-
-Note: Bison's [home page][Bison] lists ftp server and other mirrors.  If the
-above link is broken, replace with a mirror.
-
-Copy the 2 executables to this directory:
-
-```
-$ cd angle/
-$ cp /path/to/flex/build/src/flex \
-     /path/to/bison/build/src/bison \
-     tools/flex-bison/linux/
-```
-
-Upload the binaries:
-
-```
-$ cd angle/
-$ python tools/flex-bison/update_flex_bison_binaries.py
-```
-
-[Bison]: https://www.gnu.org/software/bison/
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/linux/bison.sha1 b/Source/ThirdParty/ANGLE/tools/flex-bison/linux/bison.sha1
deleted file mode 100644
index c93d92de419..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/linux/bison.sha1
+++ /dev/null
@@ -1 +0,0 @@
-e628b73cd0a767d93e1f94b5a86ce51ca83c99d5
\ No newline at end of file
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/linux/flex.sha1 b/Source/ThirdParty/ANGLE/tools/flex-bison/linux/flex.sha1
deleted file mode 100644
index d340047ca12..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/linux/flex.sha1
+++ /dev/null
@@ -1 +0,0 @@
-e830e6c0508d9685876e77304bbe7c4a122c08e8
\ No newline at end of file
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/.gitattributes b/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/.gitattributes
deleted file mode 100644
index 0688c8a1491..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/.gitattributes
+++ /dev/null
@@ -1 +0,0 @@
-*                    eol=lf
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/m4sugar/LICENSE b/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/m4sugar/LICENSE
deleted file mode 100644
index d511905c164..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/m4sugar/LICENSE
+++ /dev/null
@@ -1,339 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
- 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Lesser General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License along
-    with this program; if not, write to the Free Software Foundation, Inc.,
-    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/m4sugar/README.chromium b/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/m4sugar/README.chromium
deleted file mode 100644
index c60a5fd4fdc..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/m4sugar/README.chromium
+++ /dev/null
@@ -1,11 +0,0 @@
-Name: Autoconf M4 macros used by Bison
-Short Name: m4sugar
-URL: https://www.gnu.org/software/autoconf/
-Version: unknown
-License: GPL
-License File: LICENSE
-Security critical: no
-
-Description:
-Bison uses M4 to generate its output, and uses the utility M4 macros in this
-directory.
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/m4sugar/foreach.m4 b/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/m4sugar/foreach.m4
deleted file mode 100644
index 7093d0fcc4e..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/m4sugar/foreach.m4
+++ /dev/null
@@ -1,362 +0,0 @@
-#                                                  -*- Autoconf -*-
-# This file is part of Autoconf.
-# foreach-based replacements for recursive functions.
-# Speeds up GNU M4 1.4.x by avoiding quadratic $@ recursion, but penalizes
-# GNU M4 1.6 by requiring more memory and macro expansions.
-#
-# Copyright (C) 2008-2017 Free Software Foundation, Inc.
-
-# This file is part of Autoconf.  This program is free
-# software; you can redistribute it and/or modify it under the
-# terms of the GNU General Public License as published by the
-# Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# Under Section 7 of GPL version 3, you are granted additional
-# permissions described in the Autoconf Configure Script Exception,
-# version 3.0, as published by the Free Software Foundation.
-#
-# You should have received a copy of the GNU General Public License
-# and a copy of the Autoconf Configure Script Exception along with
-# this program; see the files COPYINGv3 and COPYING.EXCEPTION
-# respectively.  If not, see <https://www.gnu.org/licenses/>.
-
-# Written by Eric Blake.
-
-# In M4 1.4.x, every byte of $@ is rescanned.  This means that an
-# algorithm on n arguments that recurses with one less argument each
-# iteration will scan n * (n + 1) / 2 arguments, for O(n^2) time.  In
-# M4 1.6, this was fixed so that $@ is only scanned once, then
-# back-references are made to information stored about the scan.
-# Thus, n iterations need only scan n arguments, for O(n) time.
-# Additionally, in M4 1.4.x, recursive algorithms did not clean up
-# memory very well, requiring O(n^2) memory rather than O(n) for n
-# iterations.
-#
-# This file is designed to overcome the quadratic nature of $@
-# recursion by writing a variant of m4_foreach that uses m4_for rather
-# than $@ recursion to operate on the list.  This involves more macro
-# expansions, but avoids the need to rescan a quadratic number of
-# arguments, making these replacements very attractive for M4 1.4.x.
-# On the other hand, in any version of M4, expanding additional macros
-# costs additional time; therefore, in M4 1.6, where $@ recursion uses
-# fewer macros, these replacements actually pessimize performance.
-# Additionally, the use of $10 to mean the tenth argument violates
-# POSIX; although all versions of m4 1.4.x support this meaning, a
-# future m4 version may switch to take it as the first argument
-# concatenated with a literal 0, so the implementations in this file
-# are not future-proof.  Thus, this file is conditionally included as
-# part of m4_init(), only when it is detected that M4 probably has
-# quadratic behavior (ie. it lacks the macro __m4_version__).
-#
-# Please keep this file in sync with m4sugar.m4.
-
-# _m4_foreach(PRE, POST, IGNORED, ARG...)
-# ---------------------------------------
-# Form the common basis of the m4_foreach and m4_map macros.  For each
-# ARG, expand PRE[ARG]POST[].  The IGNORED argument makes recursion
-# easier, and must be supplied rather than implicit.
-#
-# This version minimizes the number of times that $@ is evaluated by
-# using m4_for to generate a boilerplate into _m4_f then passing $@ to
-# that temporary macro.  Thus, the recursion is done in m4_for without
-# reparsing any user input, and is not quadratic.  For an idea of how
-# this works, note that m4_foreach(i,[1,2],[i]) calls
-#   _m4_foreach([m4_define([i],],[)i],[],[1],[2])
-# which defines _m4_f:
-#   $1[$4]$2[]$1[$5]$2[]_m4_popdef([_m4_f])
-# then calls _m4_f([m4_define([i],],[)i],[],[1],[2]) for a net result:
-#   m4_define([i],[1])i[]m4_define([i],[2])i[]_m4_popdef([_m4_f]).
-m4_define([_m4_foreach],
-[m4_if([$#], [3], [],
-       [m4_pushdef([_m4_f], _m4_for([4], [$#], [1],
-   [$0_([1], [2],], [)])[_m4_popdef([_m4_f])])_m4_f($@)])])
-
-m4_define([_m4_foreach_],
-[[$$1[$$3]$$2[]]])
-
-# m4_case(SWITCH, VAL1, IF-VAL1, VAL2, IF-VAL2, ..., DEFAULT)
-# -----------------------------------------------------------
-# Find the first VAL that SWITCH matches, and expand the corresponding
-# IF-VAL.  If there are no matches, expand DEFAULT.
-#
-# Use m4_for to create a temporary macro in terms of a boilerplate
-# m4_if with final cleanup.  If $# is even, we have DEFAULT; if it is
-# odd, then rounding the last $# up in the temporary macro is
-# harmless.  For example, both m4_case(1,2,3,4,5) and
-# m4_case(1,2,3,4,5,6) result in the intermediate _m4_case being
-#   m4_if([$1],[$2],[$3],[$1],[$4],[$5],_m4_popdef([_m4_case])[$6])
-m4_define([m4_case],
-[m4_if(m4_eval([$# <= 2]), [1], [$2],
-[m4_pushdef([_$0], [m4_if(]_m4_for([2], m4_eval([($# - 1) / 2 * 2]), [2],
-     [_$0_(], [)])[_m4_popdef(
-	 [_$0])]m4_dquote($m4_eval([($# + 1) & ~1]))[)])_$0($@)])])
-
-m4_define([_m4_case_],
-[$0_([1], [$1], m4_incr([$1]))])
-
-m4_define([_m4_case__],
-[[[$$1],[$$2],[$$3],]])
-
-# m4_bmatch(SWITCH, RE1, VAL1, RE2, VAL2, ..., DEFAULT)
-# -----------------------------------------------------
-# m4 equivalent of
-#
-# if (SWITCH =~ RE1)
-#   VAL1;
-# elif (SWITCH =~ RE2)
-#   VAL2;
-# elif ...
-#   ...
-# else
-#   DEFAULT
-#
-# We build the temporary macro _m4_b:
-#   m4_define([_m4_b], _m4_defn([_m4_bmatch]))_m4_b([$1], [$2], [$3])...
-#   _m4_b([$1], [$m-1], [$m])_m4_b([], [], [$m+1]_m4_popdef([_m4_b]))
-# then invoke m4_unquote(_m4_b($@)), for concatenation with later text.
-m4_define([m4_bmatch],
-[m4_if([$#], 0, [m4_fatal([$0: too few arguments: $#])],
-       [$#], 1, [m4_fatal([$0: too few arguments: $#: $1])],
-       [$#], 2, [$2],
-       [m4_pushdef([_m4_b], [m4_define([_m4_b],
-  _m4_defn([_$0]))]_m4_for([3], m4_eval([($# + 1) / 2 * 2 - 1]),
-  [2], [_$0_(], [)])[_m4_b([], [],]m4_dquote([$]m4_eval(
-  [($# + 1) / 2 * 2]))[_m4_popdef([_m4_b]))])m4_unquote(_m4_b($@))])])
-
-m4_define([_m4_bmatch],
-[m4_if(m4_bregexp([$1], [$2]), [-1], [], [[$3]m4_define([$0])])])
-
-m4_define([_m4_bmatch_],
-[$0_([1], m4_decr([$1]), [$1])])
-
-m4_define([_m4_bmatch__],
-[[_m4_b([$$1], [$$2], [$$3])]])
-
-
-# m4_cond(TEST1, VAL1, IF-VAL1, TEST2, VAL2, IF-VAL2, ..., [DEFAULT])
-# -------------------------------------------------------------------
-# Similar to m4_if, except that each TEST is expanded when encountered.
-# If the expansion of TESTn matches the string VALn, the result is IF-VALn.
-# The result is DEFAULT if no tests passed.  This macro allows
-# short-circuiting of expensive tests, where it pays to arrange quick
-# filter tests to run first.
-#
-# m4_cond already guarantees either 3*n or 3*n + 1 arguments, 1 <= n.
-# We only have to speed up _m4_cond, by building the temporary _m4_c:
-#   m4_define([_m4_c], _m4_defn([m4_unquote]))_m4_c([m4_if(($1), [($2)],
-#   [[$3]m4_define([_m4_c])])])_m4_c([m4_if(($4), [($5)],
-#   [[$6]m4_define([_m4_c])])])..._m4_c([m4_if(($m-2), [($m-1)],
-#   [[$m]m4_define([_m4_c])])])_m4_c([[$m+1]]_m4_popdef([_m4_c]))
-# We invoke m4_unquote(_m4_c($@)), for concatenation with later text.
-m4_define([_m4_cond],
-[m4_pushdef([_m4_c], [m4_define([_m4_c],
-  _m4_defn([m4_unquote]))]_m4_for([2], m4_eval([$# / 3 * 3 - 1]), [3],
-  [$0_(], [)])[_m4_c(]m4_dquote(m4_dquote(
-  [$]m4_eval([$# / 3 * 3 + 1])))[_m4_popdef([_m4_c]))])m4_unquote(_m4_c($@))])
-
-m4_define([_m4_cond_],
-[$0_(m4_decr([$1]), [$1], m4_incr([$1]))])
-
-m4_define([_m4_cond__],
-[[_m4_c([m4_if(($$1), [($$2)], [[$$3]m4_define([_m4_c])])])]])
-
-# m4_bpatsubsts(STRING, RE1, SUBST1, RE2, SUBST2, ...)
-# ----------------------------------------------------
-# m4 equivalent of
-#
-#   $_ = STRING;
-#   s/RE1/SUBST1/g;
-#   s/RE2/SUBST2/g;
-#   ...
-#
-# m4_bpatsubsts already validated an odd number of arguments; we only
-# need to speed up _m4_bpatsubsts.  To avoid nesting, we build the
-# temporary _m4_p:
-#   m4_define([_m4_p], [$1])m4_define([_m4_p],
-#   m4_bpatsubst(m4_dquote(_m4_defn([_m4_p])), [$2], [$3]))m4_define([_m4_p],
-#   m4_bpatsubst(m4_dquote(_m4_defn([_m4_p])), [$4], [$5]))m4_define([_m4_p],...
-#   m4_bpatsubst(m4_dquote(_m4_defn([_m4_p])), [$m-1], [$m]))m4_unquote(
-#   _m4_defn([_m4_p])_m4_popdef([_m4_p]))
-m4_define([_m4_bpatsubsts],
-[m4_pushdef([_m4_p], [m4_define([_m4_p],
-  ]m4_dquote([$]1)[)]_m4_for([3], [$#], [2], [$0_(],
-  [)])[m4_unquote(_m4_defn([_m4_p])_m4_popdef([_m4_p]))])_m4_p($@)])
-
-m4_define([_m4_bpatsubsts_],
-[$0_(m4_decr([$1]), [$1])])
-
-m4_define([_m4_bpatsubsts__],
-[[m4_define([_m4_p],
-m4_bpatsubst(m4_dquote(_m4_defn([_m4_p])), [$$1], [$$2]))]])
-
-# m4_shiftn(N, ...)
-# -----------------
-# Returns ... shifted N times.  Useful for recursive "varargs" constructs.
-#
-# m4_shiftn already validated arguments; we only need to speed up
-# _m4_shiftn.  If N is 3, then we build the temporary _m4_s, defined as
-#   ,[$5],[$6],...,[$m]_m4_popdef([_m4_s])
-# before calling m4_shift(_m4_s($@)).
-m4_define([_m4_shiftn],
-[m4_if(m4_incr([$1]), [$#], [], [m4_pushdef([_m4_s],
-  _m4_for(m4_eval([$1 + 2]), [$#], [1],
-  [[,]m4_dquote($], [)])[_m4_popdef([_m4_s])])m4_shift(_m4_s($@))])])
-
-# m4_do(STRING, ...)
-# ------------------
-# This macro invokes all its arguments (in sequence, of course).  It is
-# useful for making your macros more structured and readable by dropping
-# unnecessary dnl's and have the macros indented properly.
-#
-# Here, we use the temporary macro _m4_do, defined as
-#   $1[]$2[]...[]$n[]_m4_popdef([_m4_do])
-m4_define([m4_do],
-[m4_if([$#], [0], [],
-       [m4_pushdef([_$0], _m4_for([1], [$#], [1],
-		   [$], [[[]]])[_m4_popdef([_$0])])_$0($@)])])
-
-# m4_dquote_elt(ARGS)
-# -------------------
-# Return ARGS as an unquoted list of double-quoted arguments.
-#
-# _m4_foreach to the rescue.
-m4_define([m4_dquote_elt],
-[m4_if([$#], [0], [], [[[$1]]_m4_foreach([,m4_dquote(], [)], $@)])])
-
-# m4_reverse(ARGS)
-# ----------------
-# Output ARGS in reverse order.
-#
-# Invoke _m4_r($@) with the temporary _m4_r built as
-#   [$m], [$m-1], ..., [$2], [$1]_m4_popdef([_m4_r])
-m4_define([m4_reverse],
-[m4_if([$#], [0], [], [$#], [1], [[$1]],
-[m4_pushdef([_m4_r], [[$$#]]_m4_for(m4_decr([$#]), [1], [-1],
-    [[, ]m4_dquote($], [)])[_m4_popdef([_m4_r])])_m4_r($@)])])
-
-
-# m4_map_args_pair(EXPRESSION, [END-EXPR = EXPRESSION], ARG...)
-# -------------------------------------------------------------
-# Perform a pairwise grouping of consecutive ARGs, by expanding
-# EXPRESSION([ARG1], [ARG2]).  If there are an odd number of ARGs, the
-# final argument is expanded with END-EXPR([ARGn]).
-#
-# Build the temporary macro _m4_map_args_pair, with the $2([$m+1])
-# only output if $# is odd:
-#   $1([$3], [$4])[]$1([$5], [$6])[]...$1([$m-1],
-#   [$m])[]m4_default([$2], [$1])([$m+1])[]_m4_popdef([_m4_map_args_pair])
-m4_define([m4_map_args_pair],
-[m4_if([$#], [0], [m4_fatal([$0: too few arguments: $#])],
-       [$#], [1], [m4_fatal([$0: too few arguments: $#: $1])],
-       [$#], [2], [],
-       [$#], [3], [m4_default([$2], [$1])([$3])[]],
-       [m4_pushdef([_$0], _m4_for([3],
-   m4_eval([$# / 2 * 2 - 1]), [2], [_$0_(], [)])_$0_end(
-   [1], [2], [$#])[_m4_popdef([_$0])])_$0($@)])])
-
-m4_define([_m4_map_args_pair_],
-[$0_([1], [$1], m4_incr([$1]))])
-
-m4_define([_m4_map_args_pair__],
-[[$$1([$$2], [$$3])[]]])
-
-m4_define([_m4_map_args_pair_end],
-[m4_if(m4_eval([$3 & 1]), [1], [[m4_default([$$2], [$$1])([$$3])[]]])])
-
-# m4_join(SEP, ARG1, ARG2...)
-# ---------------------------
-# Produce ARG1SEPARG2...SEPARGn.  Avoid back-to-back SEP when a given ARG
-# is the empty string.  No expansion is performed on SEP or ARGs.
-#
-# Use a self-modifying separator, since we don't know how many
-# arguments might be skipped before a separator is first printed, but
-# be careful if the separator contains $.  _m4_foreach to the rescue.
-m4_define([m4_join],
-[m4_pushdef([_m4_sep], [m4_define([_m4_sep], _m4_defn([m4_echo]))])]dnl
-[_m4_foreach([_$0([$1],], [)], $@)_m4_popdef([_m4_sep])])
-
-m4_define([_m4_join],
-[m4_if([$2], [], [], [_m4_sep([$1])[$2]])])
-
-# m4_joinall(SEP, ARG1, ARG2...)
-# ------------------------------
-# Produce ARG1SEPARG2...SEPARGn.  An empty ARG results in back-to-back SEP.
-# No expansion is performed on SEP or ARGs.
-#
-# A bit easier than m4_join.  _m4_foreach to the rescue.
-m4_define([m4_joinall],
-[[$2]m4_if(m4_eval([$# <= 2]), [1], [],
-	   [_m4_foreach([$1], [], m4_shift($@))])])
-
-# m4_list_cmp(A, B)
-# -----------------
-# Compare the two lists of integer expressions A and B.
-#
-# m4_list_cmp takes care of any side effects; we only override
-# _m4_list_cmp_raw, where we can safely expand lists multiple times.
-# First, insert padding so that both lists are the same length; the
-# trailing +0 is necessary to handle a missing list.  Next, create a
-# temporary macro to perform pairwise comparisons until an inequality
-# is found.  For example, m4_list_cmp([1], [1,2]) creates _m4_cmp as
-#   m4_if(m4_eval([($1) != ($3)]), [1], [m4_cmp([$1], [$3])],
-#         m4_eval([($2) != ($4)]), [1], [m4_cmp([$2], [$4])],
-#         [0]_m4_popdef([_m4_cmp]))
-# then calls _m4_cmp([1+0], [0*2], [1], [2+0])
-m4_define([_m4_list_cmp_raw],
-[m4_if([$1], [$2], 0,
-       [_m4_list_cmp($1+0_m4_list_pad(m4_count($1), m4_count($2)),
-		     $2+0_m4_list_pad(m4_count($2), m4_count($1)))])])
-
-m4_define([_m4_list_pad],
-[m4_if(m4_eval($1 < $2), [1],
-       [_m4_for(m4_incr([$1]), [$2], [1], [,0*])])])
-
-m4_define([_m4_list_cmp],
-[m4_pushdef([_m4_cmp], [m4_if(]_m4_for(
-   [1], m4_eval([$# >> 1]), [1], [$0_(], [,]m4_eval([$# >> 1])[)])[
-      [0]_m4_popdef([_m4_cmp]))])_m4_cmp($@)])
-
-m4_define([_m4_list_cmp_],
-[$0_([$1], m4_eval([$1 + $2]))])
-
-m4_define([_m4_list_cmp__],
-[[m4_eval([($$1) != ($$2)]), [1], [m4_cmp([$$1], [$$2])],
-]])
-
-# m4_max(EXPR, ...)
-# m4_min(EXPR, ...)
-# -----------------
-# Return the decimal value of the maximum (or minimum) in a series of
-# integer expressions.
-#
-# _m4_foreach to the rescue; we only need to replace _m4_minmax.  Here,
-# we need a temporary macro to track the best answer so far, so that
-# the foreach expression is tractable.
-m4_define([_m4_minmax],
-[m4_pushdef([_m4_best], m4_eval([$2]))_m4_foreach(
-  [m4_define([_m4_best], $1(_m4_best,], [))], m4_shift($@))]dnl
-[_m4_best[]_m4_popdef([_m4_best])])
-
-# m4_set_add_all(SET, VALUE...)
-# -----------------------------
-# Add each VALUE into SET.  This is O(n) in the number of VALUEs, and
-# can be faster than calling m4_set_add for each VALUE.
-#
-# _m4_foreach to the rescue.  If no deletions have occurred, then
-# avoid the speed penalty of m4_set_add.
-m4_define([m4_set_add_all],
-[m4_if([$#], [0], [], [$#], [1], [],
-       [m4_define([_m4_set_size($1)], m4_eval(m4_set_size([$1])
-	  + m4_len(_m4_foreach(m4_ifdef([_m4_set_cleanup($1)],
-  [[m4_set_add]], [[_$0]])[([$1],], [)], $@))))])])
-
-m4_define([_m4_set_add_all],
-[m4_ifdef([_m4_set([$1],$2)], [],
-	  [m4_define([_m4_set([$1],$2)],
-		     [1])m4_pushdef([_m4_set([$1])], [$2])-])])
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/m4sugar/m4sugar.m4 b/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/m4sugar/m4sugar.m4
deleted file mode 100644
index bbd695836a2..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/m4sugar/m4sugar.m4
+++ /dev/null
@@ -1,3308 +0,0 @@
-divert(-1)#                                                  -*- Autoconf -*-
-# This file is part of Autoconf.
-# Base M4 layer.
-# Requires GNU M4.
-#
-# Copyright (C) 1999-2017 Free Software Foundation, Inc.
-
-# This file is part of Autoconf.  This program is free
-# software; you can redistribute it and/or modify it under the
-# terms of the GNU General Public License as published by the
-# Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# Under Section 7 of GPL version 3, you are granted additional
-# permissions described in the Autoconf Configure Script Exception,
-# version 3.0, as published by the Free Software Foundation.
-#
-# You should have received a copy of the GNU General Public License
-# and a copy of the Autoconf Configure Script Exception along with
-# this program; see the files COPYINGv3 and COPYING.EXCEPTION
-# respectively.  If not, see <https://www.gnu.org/licenses/>.
-
-# Written by Akim Demaille.
-
-# Set the quotes, whatever the current quoting system.
-changequote()
-changequote([, ])
-
-# Some old m4's don't support m4exit.  But they provide
-# equivalent functionality by core dumping because of the
-# long macros we define.
-ifdef([__gnu__], ,
-[errprint(M4sugar requires GNU M4. Install it before installing M4sugar or
-set the M4 environment variable to its absolute file name.)
-m4exit(2)])
-
-
-## ------------------------------- ##
-## 1. Simulate --prefix-builtins.  ##
-## ------------------------------- ##
-
-# m4_define
-# m4_defn
-# m4_undefine
-define([m4_define],   defn([define]))
-define([m4_defn],     defn([defn]))
-define([m4_undefine], defn([undefine]))
-
-m4_undefine([define])
-m4_undefine([defn])
-m4_undefine([undefine])
-
-
-# m4_copy(SRC, DST)
-# -----------------
-# Define DST as the definition of SRC.
-# What's the difference between:
-# 1. m4_copy([from], [to])
-# 2. m4_define([to], [from($@)])
-# Well, obviously 1 is more expensive in space.  Maybe 2 is more expensive
-# in time, but because of the space cost of 1, it's not that obvious.
-# Nevertheless, one huge difference is the handling of `$0'.  If `from'
-# uses `$0', then with 1, `to''s `$0' is `to', while it is `from' in 2.
-# The user would certainly prefer to see `to'.
-#
-# This definition is in effect during m4sugar initialization, when
-# there are no pushdef stacks; later on, we redefine it to something
-# more powerful for all other clients to use.
-m4_define([m4_copy],
-[m4_define([$2], m4_defn([$1]))])
-
-
-# m4_rename(SRC, DST)
-# -------------------
-# Rename the macro SRC to DST.
-m4_define([m4_rename],
-[m4_copy([$1], [$2])m4_undefine([$1])])
-
-
-# m4_rename_m4(MACRO-NAME)
-# ------------------------
-# Rename MACRO-NAME to m4_MACRO-NAME.
-m4_define([m4_rename_m4],
-[m4_rename([$1], [m4_$1])])
-
-
-# m4_copy_unm4(m4_MACRO-NAME)
-# ---------------------------
-# Copy m4_MACRO-NAME to MACRO-NAME.
-m4_define([m4_copy_unm4],
-[m4_copy([$1], m4_bpatsubst([$1], [^m4_\(.*\)], [[\1]]))])
-
-
-# Some m4 internals have names colliding with tokens we might use.
-# Rename them a` la `m4 --prefix-builtins'.  Conditionals first, since
-# some subsequent renames are conditional.
-m4_rename_m4([ifdef])
-m4_rename([ifelse], [m4_if])
-
-m4_rename_m4([builtin])
-m4_rename_m4([changecom])
-m4_rename_m4([changequote])
-m4_ifdef([changeword],dnl conditionally available in 1.4.x
-[m4_undefine([changeword])])
-m4_rename_m4([debugfile])
-m4_rename_m4([debugmode])
-m4_rename_m4([decr])
-m4_rename_m4([divnum])
-m4_rename_m4([dumpdef])
-m4_rename_m4([errprint])
-m4_rename_m4([esyscmd])
-m4_rename_m4([eval])
-m4_rename_m4([format])
-m4_undefine([include])
-m4_rename_m4([incr])
-m4_rename_m4([index])
-m4_rename_m4([indir])
-m4_rename_m4([len])
-m4_rename([m4exit], [m4_exit])
-m4_undefine([m4wrap])
-m4_ifdef([mkstemp],dnl added in M4 1.4.8
-[m4_rename_m4([mkstemp])
-m4_copy([m4_mkstemp], [m4_maketemp])
-m4_undefine([maketemp])],
-[m4_rename_m4([maketemp])
-m4_copy([m4_maketemp], [m4_mkstemp])])
-m4_rename([patsubst], [m4_bpatsubst])
-m4_rename_m4([popdef])
-m4_rename_m4([pushdef])
-m4_rename([regexp], [m4_bregexp])
-m4_rename_m4([shift])
-m4_undefine([sinclude])
-m4_rename_m4([substr])
-m4_ifdef([symbols],dnl present only in alpha-quality 1.4o
-[m4_rename_m4([symbols])])
-m4_rename_m4([syscmd])
-m4_rename_m4([sysval])
-m4_rename_m4([traceoff])
-m4_rename_m4([traceon])
-m4_rename_m4([translit])
-
-# _m4_defn(ARG)
-# -------------
-# _m4_defn is for internal use only - it bypasses the wrapper, so it
-# must only be used on one argument at a time, and only on macros
-# known to be defined.  Make sure this still works if the user renames
-# m4_defn but not _m4_defn.
-m4_copy([m4_defn], [_m4_defn])
-
-# _m4_divert_raw(NUM)
-# -------------------
-# _m4_divert_raw is for internal use only.  Use this instead of
-# m4_builtin([divert], NUM), so that tracing diversion flow is easier.
-m4_rename([divert], [_m4_divert_raw])
-
-# _m4_popdef(ARG...)
-# ------------------
-# _m4_popdef is for internal use only - it bypasses the wrapper, so it
-# must only be used on macros known to be defined.  Make sure this
-# still works if the user renames m4_popdef but not _m4_popdef.
-m4_copy([m4_popdef], [_m4_popdef])
-
-# _m4_undefine(ARG...)
-# --------------------
-# _m4_undefine is for internal use only - it bypasses the wrapper, so
-# it must only be used on macros known to be defined.  Make sure this
-# still works if the user renames m4_undefine but not _m4_undefine.
-m4_copy([m4_undefine], [_m4_undefine])
-
-# _m4_undivert(NUM...)
-# --------------------
-# _m4_undivert is for internal use only, and should always be given
-# arguments.  Use this instead of m4_builtin([undivert], NUM...), so
-# that tracing diversion flow is easier.
-m4_rename([undivert], [_m4_undivert])
-
-
-## ------------------- ##
-## 2. Error messages.  ##
-## ------------------- ##
-
-
-# m4_location
-# -----------
-# Output the current file, colon, and the current line number.
-m4_define([m4_location],
-[__file__:__line__])
-
-
-# m4_errprintn(MSG)
-# -----------------
-# Same as `errprint', but with the missing end of line.
-m4_define([m4_errprintn],
-[m4_errprint([$1
-])])
-
-
-# m4_warning(MSG)
-# ---------------
-# Warn the user.
-m4_define([m4_warning],
-[m4_errprintn(m4_location[: warning: $1])])
-
-
-# m4_fatal(MSG, [EXIT-STATUS])
-# ----------------------------
-# Fatal the user.                                                      :)
-m4_define([m4_fatal],
-[m4_errprintn(m4_location[: error: $1]
-m4_expansion_stack)m4_exit(m4_if([$2],, 1, [$2]))])
-
-
-# m4_assert(EXPRESSION, [EXIT-STATUS = 1])
-# ----------------------------------------
-# This macro ensures that EXPRESSION evaluates to true, and exits if
-# EXPRESSION evaluates to false.
-m4_define([m4_assert],
-[m4_if(m4_eval([$1]), 0,
-       [m4_fatal([assert failed: $1], [$2])])])
-
-
-
-## ------------- ##
-## 3. Warnings.  ##
-## ------------- ##
-
-
-# _m4_warn(CATEGORY, MESSAGE, [STACK-TRACE])
-# ------------------------------------------
-# Report a MESSAGE to the user if the CATEGORY of warnings is enabled.
-# This is for traces only.
-# If present, STACK-TRACE is a \n-separated list of "LOCATION: MESSAGE",
-# where the last line (and no other) ends with "the top level".
-#
-# Within m4, the macro is a no-op.  This macro really matters
-# when autom4te post-processes the trace output.
-m4_define([_m4_warn], [])
-
-
-# m4_warn(CATEGORY, MESSAGE)
-# --------------------------
-# Report a MESSAGE to the user if the CATEGORY of warnings is enabled.
-m4_define([m4_warn],
-[_m4_warn([$1], [$2],
-m4_ifdef([_m4_expansion_stack], [m4_expansion_stack]))])
-
-
-
-## ------------------- ##
-## 4. File inclusion.  ##
-## ------------------- ##
-
-
-# We also want to neutralize include (and sinclude for symmetry),
-# but we want to extend them slightly: warn when a file is included
-# several times.  This is, in general, a dangerous operation, because
-# too many people forget to quote the first argument of m4_define.
-#
-# For instance in the following case:
-#   m4_define(foo, [bar])
-# then a second reading will turn into
-#   m4_define(bar, [bar])
-# which is certainly not what was meant.
-
-# m4_include_unique(FILE)
-# -----------------------
-# Declare that the FILE was loading; and warn if it has already
-# been included.
-m4_define([m4_include_unique],
-[m4_ifdef([m4_include($1)],
-	  [m4_warn([syntax], [file `$1' included several times])])dnl
-m4_define([m4_include($1)])])
-
-
-# m4_include(FILE)
-# ----------------
-# Like the builtin include, but warns against multiple inclusions.
-m4_define([m4_include],
-[m4_include_unique([$1])dnl
-m4_builtin([include], [$1])])
-
-
-# m4_sinclude(FILE)
-# -----------------
-# Like the builtin sinclude, but warns against multiple inclusions.
-m4_define([m4_sinclude],
-[m4_include_unique([$1])dnl
-m4_builtin([sinclude], [$1])])
-
-
-
-## ------------------------------------ ##
-## 5. Additional branching constructs.  ##
-## ------------------------------------ ##
-
-# Both `m4_ifval' and `m4_ifset' tests against the empty string.  The
-# difference is that `m4_ifset' is specialized on macros.
-#
-# In case of arguments of macros, eg. $1, it makes little difference.
-# In the case of a macro `FOO', you don't want to check `m4_ifval(FOO,
-# TRUE)', because if `FOO' expands with commas, there is a shifting of
-# the arguments.  So you want to run `m4_ifval([FOO])', but then you just
-# compare the *string* `FOO' against `', which, of course fails.
-#
-# So you want the variation `m4_ifset' that expects a macro name as $1.
-# If this macro is both defined and defined to a non empty value, then
-# it runs TRUE, etc.
-
-
-# m4_ifblank(COND, [IF-BLANK], [IF-TEXT])
-# m4_ifnblank(COND, [IF-TEXT], [IF-BLANK])
-# ----------------------------------------
-# If COND is empty, or consists only of blanks (space, tab, newline),
-# then expand IF-BLANK, otherwise expand IF-TEXT.  This differs from
-# m4_ifval only if COND has just whitespace, but it helps optimize in
-# spite of users who mistakenly leave trailing space after what they
-# thought was an empty argument:
-#   macro(
-#         []
-#        )
-#
-# Writing one macro in terms of the other causes extra overhead, so
-# we inline both definitions.
-m4_define([m4_ifblank],
-[m4_if(m4_translit([[$1]],  [ ][	][
-]), [], [$2], [$3])])
-
-m4_define([m4_ifnblank],
-[m4_if(m4_translit([[$1]],  [ ][	][
-]), [], [$3], [$2])])
-
-
-# m4_ifval(COND, [IF-TRUE], [IF-FALSE])
-# -------------------------------------
-# If COND is not the empty string, expand IF-TRUE, otherwise IF-FALSE.
-# Comparable to m4_ifdef.
-m4_define([m4_ifval],
-[m4_if([$1], [], [$3], [$2])])
-
-
-# m4_n(TEXT)
-# ----------
-# If TEXT is not empty, return TEXT and a new line, otherwise nothing.
-m4_define([m4_n],
-[m4_if([$1],
-       [], [],
-	   [$1
-])])
-
-
-# m4_ifvaln(COND, [IF-TRUE], [IF-FALSE])
-# --------------------------------------
-# Same as `m4_ifval', but add an extra newline to IF-TRUE or IF-FALSE
-# unless that argument is empty.
-m4_define([m4_ifvaln],
-[m4_if([$1],
-       [],   [m4_n([$3])],
-	     [m4_n([$2])])])
-
-
-# m4_ifset(MACRO, [IF-TRUE], [IF-FALSE])
-# --------------------------------------
-# If MACRO has no definition, or of its definition is the empty string,
-# expand IF-FALSE, otherwise IF-TRUE.
-m4_define([m4_ifset],
-[m4_ifdef([$1],
-	  [m4_ifval(_m4_defn([$1]), [$2], [$3])],
-	  [$3])])
-
-
-# m4_ifndef(NAME, [IF-NOT-DEFINED], [IF-DEFINED])
-# -----------------------------------------------
-m4_define([m4_ifndef],
-[m4_ifdef([$1], [$3], [$2])])
-
-
-# m4_case(SWITCH, VAL1, IF-VAL1, VAL2, IF-VAL2, ..., DEFAULT)
-# -----------------------------------------------------------
-# m4 equivalent of
-# switch (SWITCH)
-# {
-#   case VAL1:
-#     IF-VAL1;
-#     break;
-#   case VAL2:
-#     IF-VAL2;
-#     break;
-#   ...
-#   default:
-#     DEFAULT;
-#     break;
-# }.
-# All the values are optional, and the macro is robust to active
-# symbols properly quoted.
-#
-# Please keep foreach.m4 in sync with any adjustments made here.
-m4_define([m4_case],
-[m4_if([$#], 0, [],
-       [$#], 1, [],
-       [$#], 2, [$2],
-       [$1], [$2], [$3],
-       [$0([$1], m4_shift3($@))])])
-
-
-# m4_bmatch(SWITCH, RE1, VAL1, RE2, VAL2, ..., DEFAULT)
-# -----------------------------------------------------
-# m4 equivalent of
-#
-# if (SWITCH =~ RE1)
-#   VAL1;
-# elif (SWITCH =~ RE2)
-#   VAL2;
-# elif ...
-#   ...
-# else
-#   DEFAULT
-#
-# All the values are optional, and the macro is robust to active symbols
-# properly quoted.
-#
-# Please keep foreach.m4 in sync with any adjustments made here.
-m4_define([m4_bmatch],
-[m4_if([$#], 0, [m4_fatal([$0: too few arguments: $#])],
-       [$#], 1, [m4_fatal([$0: too few arguments: $#: $1])],
-       [$#], 2, [$2],
-       [m4_if(m4_bregexp([$1], [$2]), -1, [$0([$1], m4_shift3($@))],
-	      [$3])])])
-
-# m4_argn(N, ARGS...)
-# -------------------
-# Extract argument N (greater than 0) from ARGS.  Example:
-#   m4_define([b], [B])
-#   m4_argn([2], [a], [b], [c]) => b
-#
-# Rather than using m4_car(m4_shiftn([$1], $@)), we exploit the fact that
-# GNU m4 can directly reference any argument, through an indirect macro.
-m4_define([m4_argn],
-[m4_assert([0 < $1])]dnl
-[m4_pushdef([_$0], [_m4_popdef([_$0])]m4_dquote([$]m4_incr([$1])))_$0($@)])
-
-
-# m4_car(ARGS...)
-# m4_cdr(ARGS...)
-# ---------------
-# Manipulate m4 lists.  m4_car returns the first argument.  m4_cdr
-# bundles all but the first argument into a quoted list.  These two
-# macros are generally used with list arguments, with quoting removed
-# to break the list into multiple m4 ARGS.
-m4_define([m4_car], [[$1]])
-m4_define([m4_cdr],
-[m4_if([$#], 0, [m4_fatal([$0: cannot be called without arguments])],
-       [$#], 1, [],
-       [m4_dquote(m4_shift($@))])])
-
-# _m4_cdr(ARGS...)
-# ----------------
-# Like m4_cdr, except include a leading comma unless only one argument
-# remains.  Why?  Because comparing a large list against [] is more
-# expensive in expansion time than comparing the number of arguments; so
-# _m4_cdr can be used to reduce the number of arguments when it is time
-# to end recursion.
-m4_define([_m4_cdr],
-[m4_if([$#], 1, [],
-       [, m4_dquote(m4_shift($@))])])
-
-
-
-# m4_cond(TEST1, VAL1, IF-VAL1, TEST2, VAL2, IF-VAL2, ..., [DEFAULT])
-# -------------------------------------------------------------------
-# Similar to m4_if, except that each TEST is expanded when encountered.
-# If the expansion of TESTn matches the string VALn, the result is IF-VALn.
-# The result is DEFAULT if no tests passed.  This macro allows
-# short-circuiting of expensive tests, where it pays to arrange quick
-# filter tests to run first.
-#
-# For an example, consider a previous implementation of _AS_QUOTE_IFELSE:
-#
-#    m4_if(m4_index([$1], [\]), [-1], [$2],
-#          m4_eval(m4_index([$1], [\\]) >= 0), [1], [$2],
-#          m4_eval(m4_index([$1], [\$]) >= 0), [1], [$2],
-#          m4_eval(m4_index([$1], [\`]) >= 0), [1], [$3],
-#          m4_eval(m4_index([$1], [\"]) >= 0), [1], [$3],
-#          [$2])
-#
-# Here, m4_index is computed 5 times, and m4_eval 4, even if $1 contains
-# no backslash.  It is more efficient to do:
-#
-#    m4_cond([m4_index([$1], [\])], [-1], [$2],
-#            [m4_eval(m4_index([$1], [\\]) >= 0)], [1], [$2],
-#            [m4_eval(m4_index([$1], [\$]) >= 0)], [1], [$2],
-#            [m4_eval(m4_index([$1], [\`]) >= 0)], [1], [$3],
-#            [m4_eval(m4_index([$1], [\"]) >= 0)], [1], [$3],
-#            [$2])
-#
-# In the common case of $1 with no backslash, only one m4_index expansion
-# occurs, and m4_eval is avoided altogether.
-#
-# Please keep foreach.m4 in sync with any adjustments made here.
-m4_define([m4_cond],
-[m4_if([$#], [0], [m4_fatal([$0: cannot be called without arguments])],
-       [$#], [1], [$1],
-       m4_eval([$# % 3]), [2], [m4_fatal([$0: missing an argument])],
-       [_$0($@)])])
-
-m4_define([_m4_cond],
-[m4_if(($1), [($2)], [$3],
-       [$#], [3], [],
-       [$#], [4], [$4],
-       [$0(m4_shift3($@))])])
-
-
-## ---------------------------------------- ##
-## 6. Enhanced version of some primitives.  ##
-## ---------------------------------------- ##
-
-# m4_bpatsubsts(STRING, RE1, SUBST1, RE2, SUBST2, ...)
-# ----------------------------------------------------
-# m4 equivalent of
-#
-#   $_ = STRING;
-#   s/RE1/SUBST1/g;
-#   s/RE2/SUBST2/g;
-#   ...
-#
-# All the values are optional, and the macro is robust to active symbols
-# properly quoted.
-#
-# I would have liked to name this macro `m4_bpatsubst', unfortunately,
-# due to quotation problems, I need to double quote $1 below, therefore
-# the anchors are broken :(  I can't let users be trapped by that.
-#
-# Recall that m4_shift3 always results in an argument.  Hence, we need
-# to distinguish between a final deletion vs. ending recursion.
-#
-# Please keep foreach.m4 in sync with any adjustments made here.
-m4_define([m4_bpatsubsts],
-[m4_if([$#], 0, [m4_fatal([$0: too few arguments: $#])],
-       [$#], 1, [m4_fatal([$0: too few arguments: $#: $1])],
-       [$#], 2, [m4_unquote(m4_builtin([patsubst], [[$1]], [$2]))],
-       [$#], 3, [m4_unquote(m4_builtin([patsubst], [[$1]], [$2], [$3]))],
-       [_$0($@m4_if(m4_eval($# & 1), 0, [,]))])])
-m4_define([_m4_bpatsubsts],
-[m4_if([$#], 2, [$1],
-       [$0(m4_builtin([patsubst], [[$1]], [$2], [$3]),
-	   m4_shift3($@))])])
-
-
-# m4_copy(SRC, DST)
-# -----------------
-# Define the pushdef stack DST as a copy of the pushdef stack SRC;
-# give an error if DST is already defined.  This is particularly nice
-# for copying self-modifying pushdef stacks, where the top definition
-# includes one-shot initialization that is later popped to the normal
-# definition.  This version intentionally does nothing if SRC is
-# undefined.
-#
-# Some macros simply can't be renamed with this method: namely, anything
-# involved in the implementation of m4_stack_foreach_sep.
-m4_define([m4_copy],
-[m4_ifdef([$2], [m4_fatal([$0: won't overwrite defined macro: $2])],
-	  [m4_stack_foreach_sep([$1], [m4_pushdef([$2],], [)])])]dnl
-[m4_ifdef([m4_location($1)], [m4_define([m4_location($2)], m4_location)])])
-
-
-# m4_copy_force(SRC, DST)
-# m4_rename_force(SRC, DST)
-# -------------------------
-# Like m4_copy/m4_rename, except blindly overwrite any existing DST.
-# Note that m4_copy_force tolerates undefined SRC, while m4_rename_force
-# does not.
-m4_define([m4_copy_force],
-[m4_ifdef([$2], [_m4_undefine([$2])])m4_copy($@)])
-
-m4_define([m4_rename_force],
-[m4_ifdef([$2], [_m4_undefine([$2])])m4_rename($@)])
-
-
-# m4_define_default(MACRO, VALUE)
-# -------------------------------
-# If MACRO is undefined, set it to VALUE.
-m4_define([m4_define_default],
-[m4_ifndef([$1], [m4_define($@)])])
-
-
-# m4_default(EXP1, EXP2)
-# m4_default_nblank(EXP1, EXP2)
-# -----------------------------
-# Returns EXP1 if not empty/blank, otherwise EXP2.  Expand the result.
-#
-# m4_default is called on hot paths, so inline the contents of m4_ifval,
-# for one less round of expansion.
-m4_define([m4_default],
-[m4_if([$1], [], [$2], [$1])])
-
-m4_define([m4_default_nblank],
-[m4_ifblank([$1], [$2], [$1])])
-
-
-# m4_default_quoted(EXP1, EXP2)
-# m4_default_nblank_quoted(EXP1, EXP2)
-# ------------------------------------
-# Returns EXP1 if non empty/blank, otherwise EXP2.  Leave the result quoted.
-#
-# For comparison:
-#   m4_define([active], [ACTIVE])
-#   m4_default([active], [default]) => ACTIVE
-#   m4_default([], [active]) => ACTIVE
-#   -m4_default([ ], [active])- => - -
-#   -m4_default_nblank([ ], [active])- => -ACTIVE-
-#   m4_default_quoted([active], [default]) => active
-#   m4_default_quoted([], [active]) => active
-#   -m4_default_quoted([ ], [active])- => - -
-#   -m4_default_nblank_quoted([ ], [active])- => -active-
-#
-# m4_default macro is called on hot paths, so inline the contents of m4_ifval,
-# for one less round of expansion.
-m4_define([m4_default_quoted],
-[m4_if([$1], [], [[$2]], [[$1]])])
-
-m4_define([m4_default_nblank_quoted],
-[m4_ifblank([$1], [[$2]], [[$1]])])
-
-
-# m4_defn(NAME)
-# -------------
-# Like the original, except guarantee a warning when using something which is
-# undefined (unlike M4 1.4.x).  This replacement is not a full-featured
-# replacement: if any of the defined macros contain unbalanced quoting, but
-# when pasted together result in a well-quoted string, then only native m4
-# support is able to get it correct.  But that's where quadrigraphs come in
-# handy, if you really need unbalanced quotes inside your macros.
-#
-# This macro is called frequently, so minimize the amount of additional
-# expansions by skipping m4_ifndef.  Better yet, if __m4_version__ exists,
-# (added in M4 1.6), then let m4 do the job for us (see m4_init).
-m4_define([m4_defn],
-[m4_if([$#], [0], [[$0]],
-       [$#], [1], [m4_ifdef([$1], [_m4_defn([$1])],
-			    [m4_fatal([$0: undefined macro: $1])])],
-       [m4_map_args([$0], $@)])])
-
-
-# m4_dumpdef(NAME...)
-# -------------------
-# In m4 1.4.x, dumpdef writes to the current debugfile, rather than
-# stderr.  This in turn royally confuses autom4te; so we follow the
-# lead of newer m4 and always dump to stderr.  Unlike the original,
-# this version requires an argument, since there is no convenient way
-# in m4 1.4.x to grab the names of all defined macros.  Newer m4
-# always dumps to stderr, regardless of the current debugfile; it also
-# provides m4symbols as a way to grab all current macro names.  But
-# dumpdefs is not frequently called, so we don't need to worry about
-# conditionally using these newer features.  Also, this version
-# doesn't sort multiple arguments.
-#
-# If we detect m4 1.6 or newer, then provide an alternate definition,
-# installed during m4_init, that allows builtins through.
-# Unfortunately, there is no nice way in m4 1.4.x to dump builtins.
-m4_define([m4_dumpdef],
-[m4_if([$#], [0], [m4_fatal([$0: missing argument])],
-       [$#], [1], [m4_ifdef([$1], [m4_errprintn(
-  [$1:	]m4_dquote(_m4_defn([$1])))], [m4_fatal([$0: undefined macro: $1])])],
-       [m4_map_args([$0], $@)])])
-
-m4_define([_m4_dumpdef],
-[m4_if([$#], [0], [m4_fatal([$0: missing argument])],
-       [$#], [1], [m4_builtin([dumpdef], [$1])],
-       [m4_map_args_sep([m4_builtin([dumpdef],], [)], [], $@)])])
-
-
-# m4_dumpdefs(NAME...)
-# --------------------
-# Similar to `m4_dumpdef(NAME)', but if NAME was m4_pushdef'ed, display its
-# value stack (most recent displayed first).  Also, this version silently
-# ignores undefined macros, rather than erroring out.
-#
-# This macro cheats, because it relies on the current definition of NAME
-# while the second argument of m4_stack_foreach_lifo is evaluated (which
-# would be undefined according to the API).
-m4_define([m4_dumpdefs],
-[m4_if([$#], [0], [m4_fatal([$0: missing argument])],
-       [$#], [1], [m4_stack_foreach_lifo([$1], [m4_dumpdef([$1])m4_ignore])],
-       [m4_map_args([$0], $@)])])
-
-# m4_esyscmd_s(COMMAND)
-# ---------------------
-# Like m4_esyscmd, except strip any trailing newlines, thus behaving
-# more like shell command substitution.
-m4_define([m4_esyscmd_s],
-[m4_chomp_all(m4_esyscmd([$1]))])
-
-
-# m4_popdef(NAME)
-# ---------------
-# Like the original, except guarantee a warning when using something which is
-# undefined (unlike M4 1.4.x).
-#
-# This macro is called frequently, so minimize the amount of additional
-# expansions by skipping m4_ifndef.  Better yet, if __m4_version__ exists,
-# (added in M4 1.6), then let m4 do the job for us (see m4_init).
-m4_define([m4_popdef],
-[m4_if([$#], [0], [[$0]],
-       [$#], [1], [m4_ifdef([$1], [_m4_popdef([$1])],
-			    [m4_fatal([$0: undefined macro: $1])])],
-       [m4_map_args([$0], $@)])])
-
-
-# m4_shiftn(N, ...)
-# -----------------
-# Returns ... shifted N times.  Useful for recursive "varargs" constructs.
-#
-# Autoconf does not use this macro, because it is inherently slower than
-# calling the common cases of m4_shift2 or m4_shift3 directly.  But it
-# might as well be fast for other clients, such as Libtool.  One way to
-# do this is to expand $@ only once in _m4_shiftn (otherwise, for long
-# lists, the expansion of m4_if takes twice as much memory as what the
-# list itself occupies, only to throw away the unused branch).  The end
-# result is strictly equivalent to
-#   m4_if([$1], 1, [m4_shift(,m4_shift(m4_shift($@)))],
-#         [_m4_shiftn(m4_decr([$1]), m4_shift(m4_shift($@)))])
-# but with the final `m4_shift(m4_shift($@)))' shared between the two
-# paths.  The first leg uses a no-op m4_shift(,$@) to balance out the ().
-#
-# Please keep foreach.m4 in sync with any adjustments made here.
-m4_define([m4_shiftn],
-[m4_assert(0 < $1 && $1 < $#)_$0($@)])
-
-m4_define([_m4_shiftn],
-[m4_if([$1], 1, [m4_shift(],
-       [$0(m4_decr([$1])]), m4_shift(m4_shift($@)))])
-
-# m4_shift2(...)
-# m4_shift3(...)
-# --------------
-# Returns ... shifted twice, and three times.  Faster than m4_shiftn.
-m4_define([m4_shift2], [m4_shift(m4_shift($@))])
-m4_define([m4_shift3], [m4_shift(m4_shift(m4_shift($@)))])
-
-# _m4_shift2(...)
-# _m4_shift3(...)
-# ---------------
-# Like m4_shift2 or m4_shift3, except include a leading comma unless shifting
-# consumes all arguments.  Why?  Because in recursion, it is nice to
-# distinguish between 1 element left and 0 elements left, based on how many
-# arguments this shift expands to.
-m4_define([_m4_shift2],
-[m4_if([$#], [2], [],
-       [, m4_shift(m4_shift($@))])])
-m4_define([_m4_shift3],
-[m4_if([$#], [3], [],
-       [, m4_shift(m4_shift(m4_shift($@)))])])
-
-
-# m4_undefine(NAME)
-# -----------------
-# Like the original, except guarantee a warning when using something which is
-# undefined (unlike M4 1.4.x).
-#
-# This macro is called frequently, so minimize the amount of additional
-# expansions by skipping m4_ifndef.  Better yet, if __m4_version__ exists,
-# (added in M4 1.6), then let m4 do the job for us (see m4_init).
-m4_define([m4_undefine],
-[m4_if([$#], [0], [[$0]],
-       [$#], [1], [m4_ifdef([$1], [_m4_undefine([$1])],
-			    [m4_fatal([$0: undefined macro: $1])])],
-       [m4_map_args([$0], $@)])])
-
-# _m4_wrap(PRE, POST)
-# -------------------
-# Helper macro for m4_wrap and m4_wrap_lifo.  Allows nested calls to
-# m4_wrap within wrapped text.  Use _m4_defn and _m4_popdef for speed.
-m4_define([_m4_wrap],
-[m4_ifdef([$0_text],
-	  [m4_define([$0_text], [$1]_m4_defn([$0_text])[$2])],
-	  [m4_builtin([m4wrap], [m4_unquote(
-  _m4_defn([$0_text])_m4_popdef([$0_text]))])m4_define([$0_text], [$1$2])])])
-
-# m4_wrap(TEXT)
-# -------------
-# Append TEXT to the list of hooks to be executed at the end of input.
-# Whereas the order of the original may be LIFO in the underlying m4,
-# this version is always FIFO.
-m4_define([m4_wrap],
-[_m4_wrap([], [$1[]])])
-
-# m4_wrap_lifo(TEXT)
-# ------------------
-# Prepend TEXT to the list of hooks to be executed at the end of input.
-# Whereas the order of m4_wrap may be FIFO in the underlying m4, this
-# version is always LIFO.
-m4_define([m4_wrap_lifo],
-[_m4_wrap([$1[]])])
-
-## ------------------------- ##
-## 7. Quoting manipulation.  ##
-## ------------------------- ##
-
-
-# m4_apply(MACRO, LIST)
-# ---------------------
-# Invoke MACRO, with arguments provided from the quoted list of
-# comma-separated quoted arguments.  If LIST is empty, invoke MACRO
-# without arguments.  The expansion will not be concatenated with
-# subsequent text.
-m4_define([m4_apply],
-[m4_if([$2], [], [$1], [$1($2)])[]])
-
-# _m4_apply(MACRO, LIST)
-# ----------------------
-# Like m4_apply, except do nothing if LIST is empty.
-m4_define([_m4_apply],
-[m4_if([$2], [], [], [$1($2)[]])])
-
-
-# m4_count(ARGS)
-# --------------
-# Return a count of how many ARGS are present.
-m4_define([m4_count], [$#])
-
-
-# m4_curry(MACRO, ARG...)
-# -----------------------
-# Perform argument currying.  The expansion of this macro is another
-# macro that takes exactly one argument, appends it to the end of the
-# original ARG list, then invokes MACRO.  For example:
-#   m4_curry([m4_curry], [m4_reverse], [1])([2])([3]) => 3, 2, 1
-# Not quite as practical as m4_incr, but you could also do:
-#   m4_define([add], [m4_eval(([$1]) + ([$2]))])
-#   m4_define([add_one], [m4_curry([add], [1])])
-#   add_one()([2]) => 3
-m4_define([m4_curry], [$1(m4_shift($@,)_$0])
-m4_define([_m4_curry],               [[$1])])
-
-
-# m4_do(STRING, ...)
-# ------------------
-# This macro invokes all its arguments (in sequence, of course).  It is
-# useful for making your macros more structured and readable by dropping
-# unnecessary dnl's and have the macros indented properly.  No concatenation
-# occurs after a STRING; use m4_unquote(m4_join(,STRING)) for that.
-#
-# Please keep foreach.m4 in sync with any adjustments made here.
-m4_define([m4_do],
-[m4_if([$#], 0, [],
-       [$#], 1, [$1[]],
-       [$1[]$0(m4_shift($@))])])
-
-
-# m4_dquote(ARGS)
-# ---------------
-# Return ARGS as a quoted list of quoted arguments.
-m4_define([m4_dquote],  [[$@]])
-
-
-# m4_dquote_elt(ARGS)
-# -------------------
-# Return ARGS as an unquoted list of double-quoted arguments.
-#
-# Please keep foreach.m4 in sync with any adjustments made here.
-m4_define([m4_dquote_elt],
-[m4_if([$#], [0], [],
-       [$#], [1], [[[$1]]],
-       [[[$1]],$0(m4_shift($@))])])
-
-
-# m4_echo(ARGS)
-# -------------
-# Return the ARGS, with the same level of quoting.  Whitespace after
-# unquoted commas are consumed.
-m4_define([m4_echo], [$@])
-
-
-# m4_expand(ARG)
-# _m4_expand(ARG)
-# ---------------
-# Return the expansion of ARG as a single string.  Unlike
-# m4_quote($1), this preserves whitespace following single-quoted
-# commas that appear within ARG.  It also deals with shell case
-# statements.
-#
-#   m4_define([active], [ACT, IVE])
-#   m4_define([active2], [[ACT, IVE]])
-#   m4_quote(active, active2)
-#   => ACT,IVE,ACT, IVE
-#   m4_expand([active, active2])
-#   => ACT, IVE, ACT, IVE
-#
-# Unfortunately, due to limitations in m4, ARG must expand to
-# something with balanced quotes (use quadrigraphs to get around
-# this), and should not contain the unlikely delimiters -=<{( or
-# )}>=-.  It is possible to have unbalanced quoted `(' or `)', as well
-# as unbalanced unquoted `)'.  m4_expand can handle unterminated
-# comments or dnl on the final line, at the expense of speed; it also
-# aids in detecting attempts to incorrectly change the current
-# diversion inside ARG.  Meanwhile, _m4_expand is faster but must be
-# given a terminated expansion, and has no safety checks for
-# mis-diverted text.
-#
-# Exploit that extra unquoted () will group unquoted commas and the
-# following whitespace.  m4_bpatsubst can't handle newlines inside $1,
-# and m4_substr strips quoting.  So we (ab)use m4_changequote, using
-# temporary quotes to remove the delimiters that conveniently included
-# the unquoted () that were added prior to the changequote.
-#
-# Thanks to shell case statements, too many people are prone to pass
-# underquoted `)', so we try to detect that by passing a marker as a
-# fourth argument; if the marker is not present, then we assume that
-# we encountered an early `)', and re-expand the first argument, but
-# this time with one more `(' in the second argument and in the
-# open-quote delimiter.  We must also ignore the slop from the
-# previous try.  The final macro is thus half line-noise, half art.
-m4_define([m4_expand],
-[m4_pushdef([m4_divert], _m4_defn([_m4_divert_unsafe]))]dnl
-[m4_pushdef([m4_divert_push], _m4_defn([_m4_divert_unsafe]))]dnl
-[m4_chomp(_$0([$1
-]))_m4_popdef([m4_divert], [m4_divert_push])])
-
-m4_define([_m4_expand], [$0_([$1], [(], -=<{($1)}>=-, [}>=-])])
-
-m4_define([_m4_expand_],
-[m4_if([$4], [}>=-],
-       [m4_changequote([-=<{$2], [)}>=-])$3m4_changequote([, ])],
-       [$0([$1], [($2], -=<{($2$1)}>=-, [}>=-])m4_ignore$2])])
-
-
-# m4_ignore(ARGS)
-# ---------------
-# Expands to nothing.  Useful for conditionally ignoring an arbitrary
-# number of arguments (see _m4_list_cmp for an example).
-m4_define([m4_ignore])
-
-
-# m4_make_list(ARGS)
-# ------------------
-# Similar to m4_dquote, this creates a quoted list of quoted ARGS.  This
-# version is less efficient than m4_dquote, but separates each argument
-# with a comma and newline, rather than just comma, for readability.
-# When developing an m4sugar algorithm, you could temporarily use
-#   m4_pushdef([m4_dquote],m4_defn([m4_make_list]))
-# around your code to make debugging easier.
-m4_define([m4_make_list], [m4_join([,
-], m4_dquote_elt($@))])
-
-
-# m4_noquote(STRING)
-# ------------------
-# Return the result of ignoring all quotes in STRING and invoking the
-# macros it contains.  Among other things, this is useful for enabling
-# macro invocations inside strings with [] blocks (for instance regexps
-# and help-strings).  On the other hand, since all quotes are disabled,
-# any macro expanded during this time that relies on nested [] quoting
-# will likely crash and burn.  This macro is seldom useful; consider
-# m4_unquote or m4_expand instead.
-m4_define([m4_noquote],
-[m4_changequote([-=<{(],[)}>=-])$1-=<{()}>=-m4_changequote([,])])
-
-
-# m4_quote(ARGS)
-# --------------
-# Return ARGS as a single argument.  Any whitespace after unquoted commas
-# is stripped.  There is always output, even when there were no arguments.
-#
-# It is important to realize the difference between `m4_quote(exp)' and
-# `[exp]': in the first case you obtain the quoted *result* of the
-# expansion of EXP, while in the latter you just obtain the string
-# `exp'.
-m4_define([m4_quote],  [[$*]])
-
-
-# _m4_quote(ARGS)
-# ---------------
-# Like m4_quote, except that when there are no arguments, there is no
-# output.  For conditional scenarios (such as passing _m4_quote as the
-# macro name in m4_mapall), this feature can be used to distinguish between
-# one argument of the empty string vs. no arguments.  However, in the
-# normal case with arguments present, this is less efficient than m4_quote.
-m4_define([_m4_quote],
-[m4_if([$#], [0], [], [[$*]])])
-
-
-# m4_reverse(ARGS)
-# ----------------
-# Output ARGS in reverse order.
-#
-# Please keep foreach.m4 in sync with any adjustments made here.
-m4_define([m4_reverse],
-[m4_if([$#], [0], [], [$#], [1], [[$1]],
-       [$0(m4_shift($@)), [$1]])])
-
-
-# m4_unquote(ARGS)
-# ----------------
-# Remove one layer of quotes from each ARG, performing one level of
-# expansion.  For one argument, m4_unquote([arg]) is more efficient than
-# m4_do([arg]), but for multiple arguments, the difference is that
-# m4_unquote separates arguments with commas while m4_do concatenates.
-# Follow this macro with [] if concatenation with subsequent text is
-# undesired.
-m4_define([m4_unquote], [$*])
-
-
-## -------------------------- ##
-## 8. Implementing m4 loops.  ##
-## -------------------------- ##
-
-
-# m4_for(VARIABLE, FIRST, LAST, [STEP = +/-1], EXPRESSION)
-# --------------------------------------------------------
-# Expand EXPRESSION defining VARIABLE to FROM, FROM + 1, ..., TO with
-# increments of STEP.  Both limits are included, and bounds are
-# checked for consistency.  The algorithm is robust to indirect
-# VARIABLE names.  Changing VARIABLE inside EXPRESSION will not impact
-# the number of iterations.
-#
-# Uses _m4_defn for speed, and avoid dnl in the macro body.  Factor
-# the _m4_for call so that EXPRESSION is only parsed once.
-m4_define([m4_for],
-[m4_pushdef([$1], m4_eval([$2]))]dnl
-[m4_cond([m4_eval(([$3]) > ([$2]))], 1,
-	   [m4_pushdef([_m4_step], m4_eval(m4_default_quoted([$4],
-	      1)))m4_assert(_m4_step > 0)_$0(_m4_defn([$1]),
-  m4_eval((([$3]) - ([$2])) / _m4_step * _m4_step + ([$2])), _m4_step,],
-	 [m4_eval(([$3]) < ([$2]))], 1,
-	   [m4_pushdef([_m4_step], m4_eval(m4_default_quoted([$4],
-	      -1)))m4_assert(_m4_step < 0)_$0(_m4_defn([$1]),
-  m4_eval((([$2]) - ([$3])) / -(_m4_step) * _m4_step + ([$2])), _m4_step,],
-	 [m4_pushdef([_m4_step])_$0(_m4_defn([$1]), _m4_defn([$1]), 0,])]dnl
-[[m4_define([$1],], [)$5])m4_popdef([_m4_step], [$1])])
-
-# _m4_for(COUNT, LAST, STEP, PRE, POST)
-# -------------------------------------
-# Core of the loop, no consistency checks, all arguments are plain
-# numbers.  Expand PRE[COUNT]POST, then alter COUNT by STEP and
-# iterate if COUNT is not LAST.
-m4_define([_m4_for],
-[$4[$1]$5[]m4_if([$1], [$2], [],
-		 [$0(m4_eval([$1 + $3]), [$2], [$3], [$4], [$5])])])
-
-
-# Implementing `foreach' loops in m4 is much more tricky than it may
-# seem.  For example, the old M4 1.4.4 manual had an incorrect example,
-# which looked like this (when translated to m4sugar):
-#
-# | # foreach(VAR, (LIST), STMT)
-# | m4_define([foreach],
-# |   [m4_pushdef([$1])_foreach([$1], [$2], [$3])m4_popdef([$1])])
-# | m4_define([_arg1], [$1])
-# | m4_define([_foreach],
-# |   [m4_if([$2], [()], ,
-# |     [m4_define([$1], _arg1$2)$3[]_foreach([$1], (m4_shift$2), [$3])])])
-#
-# But then if you run
-#
-# | m4_define(a, 1)
-# | m4_define(b, 2)
-# | m4_define(c, 3)
-# | foreach([f], [([a], [(b], [c)])], [echo f
-# | ])
-#
-# it gives
-#
-#  => echo 1
-#  => echo (2,3)
-#
-# which is not what is expected.
-#
-# Of course the problem is that many quotes are missing.  So you add
-# plenty of quotes at random places, until you reach the expected
-# result.  Alternatively, if you are a quoting wizard, you directly
-# reach the following implementation (but if you really did, then
-# apply to the maintenance of m4sugar!).
-#
-# | # foreach(VAR, (LIST), STMT)
-# | m4_define([foreach], [m4_pushdef([$1])_foreach($@)m4_popdef([$1])])
-# | m4_define([_arg1], [[$1]])
-# | m4_define([_foreach],
-# |  [m4_if($2, [()], ,
-# |    [m4_define([$1], [_arg1$2])$3[]_foreach([$1], [(m4_shift$2)], [$3])])])
-#
-# which this time answers
-#
-#  => echo a
-#  => echo (b
-#  => echo c)
-#
-# Bingo!
-#
-# Well, not quite.
-#
-# With a better look, you realize that the parens are more a pain than
-# a help: since anyway you need to quote properly the list, you end up
-# with always using an outermost pair of parens and an outermost pair
-# of quotes.  Rejecting the parens both eases the implementation, and
-# simplifies the use:
-#
-# | # foreach(VAR, (LIST), STMT)
-# | m4_define([foreach], [m4_pushdef([$1])_foreach($@)m4_popdef([$1])])
-# | m4_define([_arg1], [$1])
-# | m4_define([_foreach],
-# |  [m4_if($2, [], ,
-# |    [m4_define([$1], [_arg1($2)])$3[]_foreach([$1], [m4_shift($2)], [$3])])])
-#
-#
-# Now, just replace the `$2' with `m4_quote($2)' in the outer `m4_if'
-# to improve robustness, and you come up with a nice implementation
-# that doesn't require extra parentheses in the user's LIST.
-#
-# But wait -  now the algorithm is quadratic, because every recursion of
-# the algorithm keeps the entire LIST and merely adds another m4_shift to
-# the quoted text.  If the user has a lot of elements in LIST, you can
-# bring the system to its knees with the memory m4 then requires, or trip
-# the m4 --nesting-limit recursion factor.  The only way to avoid
-# quadratic growth is ensure m4_shift is expanded prior to the recursion.
-# Hence the design below.
-#
-# The M4 manual now includes a chapter devoted to this issue, with
-# the lessons learned from m4sugar.  And still, this design is only
-# optimal for M4 1.6; see foreach.m4 for yet more comments on why
-# M4 1.4.x uses yet another implementation.
-
-
-# m4_foreach(VARIABLE, LIST, EXPRESSION)
-# --------------------------------------
-#
-# Expand EXPRESSION assigning each value of the LIST to VARIABLE.
-# LIST should have the form `item_1, item_2, ..., item_n', i.e. the
-# whole list must *quoted*.  Quote members too if you don't want them
-# to be expanded.
-#
-# This macro is robust to active symbols:
-#      | m4_define(active, [ACT, IVE])
-#      | m4_foreach(Var, [active, active], [-Var-])
-#     => -ACT--IVE--ACT--IVE-
-#
-#      | m4_foreach(Var, [[active], [active]], [-Var-])
-#     => -ACT, IVE--ACT, IVE-
-#
-#      | m4_foreach(Var, [[[active]], [[active]]], [-Var-])
-#     => -active--active-
-#
-# This macro is called frequently, so avoid extra expansions such as
-# m4_ifval and dnl.  Also, since $2 might be quite large, try to use it
-# as little as possible in _m4_foreach; each extra use requires that much
-# more memory for expansion.  So, rather than directly compare $2 against
-# [] and use m4_car/m4_cdr for recursion, we instead unbox the list (which
-# requires swapping the argument order in the helper), insert an ignored
-# third argument, and use m4_shift3 to detect when recursion is complete,
-# at which point this looks very much like m4_map_args.
-m4_define([m4_foreach],
-[m4_if([$2], [], [],
-       [m4_pushdef([$1])_$0([m4_define([$1],], [)$3], [],
-  $2)m4_popdef([$1])])])
-
-# _m4_foreach(PRE, POST, IGNORED, ARG...)
-# ---------------------------------------
-# Form the common basis of the m4_foreach and m4_map macros.  For each
-# ARG, expand PRE[ARG]POST[].  The IGNORED argument makes recursion
-# easier, and must be supplied rather than implicit.
-#
-# Please keep foreach.m4 in sync with any adjustments made here.
-m4_define([_m4_foreach],
-[m4_if([$#], [3], [],
-       [$1[$4]$2[]$0([$1], [$2], m4_shift3($@))])])
-
-
-# m4_foreach_w(VARIABLE, LIST, EXPRESSION)
-# ----------------------------------------
-# Like m4_foreach, but the list is whitespace separated.  Depending on
-# EXPRESSION, it may be more efficient to use m4_map_args_w.
-#
-# This macro is robust to active symbols:
-#    m4_foreach_w([Var], [ active
-#    b	act\
-#    ive  ], [-Var-])end
-#    => -active--b--active-end
-#
-# This used to use a slower implementation based on m4_foreach:
-#   m4_foreach([$1], m4_split(m4_normalize([$2]), [ ]), [$3])
-m4_define([m4_foreach_w],
-[m4_pushdef([$1])m4_map_args_w([$2],
-  [m4_define([$1],], [)$3])m4_popdef([$1])])
-
-
-# m4_map(MACRO, LIST)
-# m4_mapall(MACRO, LIST)
-# ----------------------
-# Invoke MACRO($1), MACRO($2) etc. where $1, $2... are the elements of
-# LIST.  $1, $2... must in turn be lists, appropriate for m4_apply.
-# If LIST contains an empty sublist, m4_map skips the expansion of
-# MACRO, while m4_mapall expands MACRO with no arguments.
-#
-# Since LIST may be quite large, we want to minimize how often it
-# appears in the expansion.  Rather than use m4_car/m4_cdr iteration,
-# we unbox the list, and use _m4_foreach for iteration.  For m4_map,
-# an empty list behaves like an empty sublist and gets ignored; for
-# m4_mapall, we must special-case the empty list.
-m4_define([m4_map],
-[_m4_foreach([_m4_apply([$1],], [)], [], $2)])
-
-m4_define([m4_mapall],
-[m4_if([$2], [], [],
-       [_m4_foreach([m4_apply([$1],], [)], [], $2)])])
-
-
-# m4_map_sep(MACRO, [SEPARATOR], LIST)
-# m4_mapall_sep(MACRO, [SEPARATOR], LIST)
-# ---------------------------------------
-# Invoke MACRO($1), SEPARATOR, MACRO($2), ..., MACRO($N) where $1,
-# $2... $N are the elements of LIST, and are in turn lists appropriate
-# for m4_apply.  SEPARATOR is expanded, in order to allow the creation
-# of a list of arguments by using a single-quoted comma as the
-# separator.  For each empty sublist, m4_map_sep skips the expansion
-# of MACRO and SEPARATOR, while m4_mapall_sep expands MACRO with no
-# arguments.
-#
-# For m4_mapall_sep, merely expand the first iteration without the
-# separator, then include separator as part of subsequent recursion;
-# but avoid extra expansion of LIST's side-effects via a helper macro.
-# For m4_map_sep, things are trickier - we don't know if the first
-# list element is an empty sublist, so we must define a self-modifying
-# helper macro and use that as the separator instead.
-m4_define([m4_map_sep],
-[m4_pushdef([m4_Sep], [m4_define([m4_Sep], _m4_defn([m4_unquote]))])]dnl
-[_m4_foreach([_m4_apply([m4_Sep([$2])[]$1],], [)], [], $3)m4_popdef([m4_Sep])])
-
-m4_define([m4_mapall_sep],
-[m4_if([$3], [], [], [_$0([$1], [$2], $3)])])
-
-m4_define([_m4_mapall_sep],
-[m4_apply([$1], [$3])_m4_foreach([m4_apply([$2[]$1],], [)], m4_shift2($@))])
-
-# m4_map_args(EXPRESSION, ARG...)
-# -------------------------------
-# Expand EXPRESSION([ARG]) for each argument.  More efficient than
-#   m4_foreach([var], [ARG...], [EXPRESSION(m4_defn([var]))])
-# Shorthand for m4_map_args_sep([EXPRESSION(], [)], [], ARG...).
-m4_define([m4_map_args],
-[m4_if([$#], [0], [m4_fatal([$0: too few arguments: $#])],
-       [$#], [1], [],
-       [$#], [2], [$1([$2])[]],
-       [_m4_foreach([$1(], [)], $@)])])
-
-
-# m4_map_args_pair(EXPRESSION, [END-EXPR = EXPRESSION], ARG...)
-# -------------------------------------------------------------
-# Perform a pairwise grouping of consecutive ARGs, by expanding
-# EXPRESSION([ARG1], [ARG2]).  If there are an odd number of ARGs, the
-# final argument is expanded with END-EXPR([ARGn]).
-#
-# For example:
-#   m4_define([show], [($*)m4_newline])dnl
-#   m4_map_args_pair([show], [], [a], [b], [c], [d], [e])dnl
-#   => (a,b)
-#   => (c,d)
-#   => (e)
-#
-# Please keep foreach.m4 in sync with any adjustments made here.
-m4_define([m4_map_args_pair],
-[m4_if([$#], [0], [m4_fatal([$0: too few arguments: $#])],
-       [$#], [1], [m4_fatal([$0: too few arguments: $#: $1])],
-       [$#], [2], [],
-       [$#], [3], [m4_default([$2], [$1])([$3])[]],
-       [$#], [4], [$1([$3], [$4])[]],
-       [$1([$3], [$4])[]$0([$1], [$2], m4_shift(m4_shift3($@)))])])
-
-
-# m4_map_args_sep([PRE], [POST], [SEP], ARG...)
-# ---------------------------------------------
-# Expand PRE[ARG]POST for each argument, with SEP between arguments.
-m4_define([m4_map_args_sep],
-[m4_if([$#], [0], [m4_fatal([$0: too few arguments: $#])],
-       [$#], [1], [],
-       [$#], [2], [],
-       [$#], [3], [],
-       [$#], [4], [$1[$4]$2[]],
-       [$1[$4]$2[]_m4_foreach([$3[]$1], [$2], m4_shift3($@))])])
-
-
-# m4_map_args_w(STRING, [PRE], [POST], [SEP])
-# -------------------------------------------
-# Perform the expansion of PRE[word]POST[] for each word in STRING
-# separated by whitespace.  More efficient than:
-#   m4_foreach_w([var], [STRING], [PRE[]m4_defn([var])POST])
-# Additionally, expand SEP between words.
-#
-# As long as we have to use m4_bpatsubst to split the string, we might
-# as well make it also apply PRE and POST; this avoids iteration
-# altogether.  But we must be careful of any \ in PRE or POST.
-# _m4_strip returns a quoted string, but that's okay, since it also
-# supplies an empty leading and trailing argument due to our
-# intentional whitespace around STRING.  We use m4_substr to strip the
-# empty elements and remove the extra layer of quoting.
-m4_define([m4_map_args_w],
-[_$0(_m4_split([ ]m4_flatten([$1])[ ], [[	 ]+],
-	       m4_if(m4_index([$2$3$4], [\]), [-1], [[$3[]$4[]$2]],
-		     [m4_bpatsubst([[$3[]$4[]$2]], [\\], [\\\\])])),
-     m4_len([[]$3[]$4]), m4_len([$4[]$2[]]))])
-
-m4_define([_m4_map_args_w],
-[m4_substr([$1], [$2], m4_eval(m4_len([$1]) - [$2] - [$3]))])
-
-
-# m4_stack_foreach(MACRO, FUNC)
-# m4_stack_foreach_lifo(MACRO, FUNC)
-# ----------------------------------
-# Pass each stacked definition of MACRO to the one-argument macro FUNC.
-# m4_stack_foreach proceeds in FIFO order, while m4_stack_foreach_lifo
-# processes the topmost definitions first.  In addition, FUNC should
-# not push or pop definitions of MACRO, and should not expect anything about
-# the active definition of MACRO (it will not be the topmost, and may not
-# be the one passed to FUNC either).
-#
-# Some macros simply can't be examined with this method: namely,
-# anything involved in the implementation of _m4_stack_reverse.
-m4_define([m4_stack_foreach],
-[_m4_stack_reverse([$1], [m4_tmp-$1])]dnl
-[_m4_stack_reverse([m4_tmp-$1], [$1], [$2(_m4_defn([m4_tmp-$1]))])])
-
-m4_define([m4_stack_foreach_lifo],
-[_m4_stack_reverse([$1], [m4_tmp-$1], [$2(_m4_defn([m4_tmp-$1]))])]dnl
-[_m4_stack_reverse([m4_tmp-$1], [$1])])
-
-# m4_stack_foreach_sep(MACRO, [PRE], [POST], [SEP])
-# m4_stack_foreach_sep_lifo(MACRO, [PRE], [POST], [SEP])
-# ------------------------------------------------------
-# Similar to m4_stack_foreach and m4_stack_foreach_lifo, in that every
-# definition of a pushdef stack will be visited.  But rather than
-# passing the definition as a single argument to a macro, this variant
-# expands the concatenation of PRE[]definition[]POST, and expands SEP
-# between consecutive expansions.  Note that m4_stack_foreach([a], [b])
-# is equivalent to m4_stack_foreach_sep([a], [b(], [)]).
-m4_define([m4_stack_foreach_sep],
-[_m4_stack_reverse([$1], [m4_tmp-$1])]dnl
-[_m4_stack_reverse([m4_tmp-$1], [$1], [$2[]_m4_defn([m4_tmp-$1])$3], [$4[]])])
-
-m4_define([m4_stack_foreach_sep_lifo],
-[_m4_stack_reverse([$1], [m4_tmp-$1], [$2[]_m4_defn([m4_tmp-$1])$3], [$4[]])]dnl
-[_m4_stack_reverse([m4_tmp-$1], [$1])])
-
-
-# _m4_stack_reverse(OLD, NEW, [ACTION], [SEP])
-# --------------------------------------------
-# A recursive worker for pushdef stack manipulation.  Destructively
-# copy the OLD stack into the NEW, and expanding ACTION for each
-# iteration.  After the first iteration, SEP is promoted to the front
-# of ACTION (note that SEP should include a trailing [] if it is to
-# avoid interfering with ACTION).  The current definition is examined
-# after the NEW has been pushed but before OLD has been popped; this
-# order is important, as ACTION is permitted to operate on either
-# _m4_defn([OLD]) or _m4_defn([NEW]).  Since the operation is
-# destructive, this macro is generally used twice, with a temporary
-# macro name holding the swapped copy.
-m4_define([_m4_stack_reverse],
-[m4_ifdef([$1], [m4_pushdef([$2],
-  _m4_defn([$1]))$3[]_m4_popdef([$1])$0([$1], [$2], [$4$3])])])
-
-
-
-## --------------------------- ##
-## 9. More diversion support.  ##
-## --------------------------- ##
-
-
-# m4_cleardivert(DIVERSION-NAME...)
-# ---------------------------------
-# Discard any text in DIVERSION-NAME.
-#
-# This works even inside m4_expand.
-m4_define([m4_cleardivert],
-[m4_if([$#], [0], [m4_fatal([$0: missing argument])],
-       [_m4_divert_raw([-1])m4_undivert($@)_m4_divert_raw(
-	 _m4_divert(_m4_defn([_m4_divert_diversion]), [-]))])])
-
-
-# _m4_divert(DIVERSION-NAME or NUMBER, [NOWARN])
-# ----------------------------------------------
-# If DIVERSION-NAME is the name of a diversion, return its number,
-# otherwise if it is a NUMBER return it.  Issue a warning about
-# the use of a number instead of a name, unless NOWARN is provided.
-m4_define([_m4_divert],
-[m4_ifdef([_m4_divert($1)],
-	  [m4_indir([_m4_divert($1)])],
-	  [m4_if([$2], [], [m4_warn([syntax],
-	     [prefer named diversions])])$1])])
-
-# KILL is only used to suppress output.
-m4_define([_m4_divert(KILL)],           -1)
-
-# The empty diversion name is a synonym for 0.
-m4_define([_m4_divert()],                0)
-
-
-# m4_divert_stack
-# ---------------
-# Print the diversion stack, if it's nonempty.  The caller is
-# responsible for any leading or trailing newline.
-m4_define([m4_divert_stack],
-[m4_stack_foreach_sep_lifo([_m4_divert_stack], [], [], [
-])])
-
-
-# m4_divert_stack_push(MACRO-NAME, DIVERSION-NAME)
-# ------------------------------------------------
-# Form an entry of the diversion stack from caller MACRO-NAME and
-# entering DIVERSION-NAME and push it.
-m4_define([m4_divert_stack_push],
-[m4_pushdef([_m4_divert_stack], m4_location[: $1: $2])])
-
-
-# m4_divert(DIVERSION-NAME)
-# -------------------------
-# Change the diversion stream to DIVERSION-NAME.
-m4_define([m4_divert],
-[m4_popdef([_m4_divert_stack])]dnl
-[m4_define([_m4_divert_diversion], [$1])]dnl
-[m4_divert_stack_push([$0], [$1])]dnl
-[_m4_divert_raw(_m4_divert([$1]))])
-
-
-# m4_divert_push(DIVERSION-NAME, [NOWARN])
-# ----------------------------------------
-# Change the diversion stream to DIVERSION-NAME, while stacking old values.
-# For internal use only: if NOWARN is not empty, DIVERSION-NAME can be a
-# number instead of a name.
-m4_define([m4_divert_push],
-[m4_divert_stack_push([$0], [$1])]dnl
-[m4_pushdef([_m4_divert_diversion], [$1])]dnl
-[_m4_divert_raw(_m4_divert([$1], [$2]))])
-
-
-# m4_divert_pop([DIVERSION-NAME])
-# -------------------------------
-# Change the diversion stream to its previous value, unstacking it.
-# If specified, verify we left DIVERSION-NAME.
-# When we pop the last value from the stack, we divert to -1.
-m4_define([m4_divert_pop],
-[m4_if([$1], [], [],
-       [$1], _m4_defn([_m4_divert_diversion]), [],
-       [m4_fatal([$0($1): diversion mismatch:
-]m4_divert_stack)])]dnl
-[_m4_popdef([_m4_divert_stack], [_m4_divert_diversion])]dnl
-[m4_ifdef([_m4_divert_diversion], [],
-	   [m4_fatal([too many m4_divert_pop])])]dnl
-[_m4_divert_raw(_m4_divert(_m4_defn([_m4_divert_diversion]), [-]))])
-
-
-# m4_divert_text(DIVERSION-NAME, CONTENT)
-# ---------------------------------------
-# Output CONTENT into DIVERSION-NAME (which may be a number actually).
-# An end of line is appended for free to CONTENT.
-m4_define([m4_divert_text],
-[m4_divert_push([$1])$2
-m4_divert_pop([$1])])
-
-
-# m4_divert_once(DIVERSION-NAME, CONTENT)
-# ---------------------------------------
-# Output CONTENT into DIVERSION-NAME once, if not already there.
-# An end of line is appended for free to CONTENT.
-m4_define([m4_divert_once],
-[m4_expand_once([m4_divert_text([$1], [$2])])])
-
-
-# _m4_divert_unsafe(DIVERSION-NAME)
-# ---------------------------------
-# Issue a warning that the attempt to change the current diversion to
-# DIVERSION-NAME is unsafe, because this macro is being expanded
-# during argument collection of m4_expand.
-m4_define([_m4_divert_unsafe],
-[m4_fatal([$0: cannot change diversion to `$1' inside m4_expand])])
-
-
-# m4_undivert(DIVERSION-NAME...)
-# ------------------------------
-# Undivert DIVERSION-NAME.  Unlike the M4 version, this requires at
-# least one DIVERSION-NAME; also, due to support for named diversions,
-# this should not be used to undivert files.
-m4_define([m4_undivert],
-[m4_if([$#], [0], [m4_fatal([$0: missing argument])],
-       [$#], [1], [_m4_undivert(_m4_divert([$1]))],
-       [m4_map_args([$0], $@)])])
-
-
-## --------------------------------------------- ##
-## 10. Defining macros with bells and whistles.  ##
-## --------------------------------------------- ##
-
-# `m4_defun' is basically `m4_define' but it equips the macro with the
-# needed machinery for `m4_require'.  A macro must be m4_defun'd if
-# either it is m4_require'd, or it m4_require's.
-#
-# Two things deserve attention and are detailed below:
-#  1. Implementation of m4_require
-#  2. Keeping track of the expansion stack
-#
-# 1. Implementation of m4_require
-# ===============================
-#
-# Of course m4_defun calls m4_provide, so that a macro which has
-# been expanded is not expanded again when m4_require'd, but the
-# difficult part is the proper expansion of macros when they are
-# m4_require'd.
-#
-# The implementation is based on three ideas, (i) using diversions to
-# prepare the expansion of the macro and its dependencies (by Franc,ois
-# Pinard), (ii) expand the most recently m4_require'd macros _after_
-# the previous macros (by Axel Thimm), and (iii) track instances of
-# provide before require (by Eric Blake).
-#
-#
-# The first idea: why use diversions?
-# -----------------------------------
-#
-# When a macro requires another, the other macro is expanded in new
-# diversion, GROW.  When the outer macro is fully expanded, we first
-# undivert the most nested diversions (GROW - 1...), and finally
-# undivert GROW.  To understand why we need several diversions,
-# consider the following example:
-#
-# | m4_defun([TEST1], [Test...m4_require([TEST2])1])
-# | m4_defun([TEST2], [Test...m4_require([TEST3])2])
-# | m4_defun([TEST3], [Test...3])
-#
-# Because m4_require is not required to be first in the outer macros, we
-# must keep the expansions of the various levels of m4_require separated.
-# Right before executing the epilogue of TEST1, we have:
-#
-#	   GROW - 2: Test...3
-#	   GROW - 1: Test...2
-#	   GROW:     Test...1
-#	   BODY:
-#
-# Finally the epilogue of TEST1 undiverts GROW - 2, GROW - 1, and
-# GROW into the regular flow, BODY.
-#
-#	   GROW - 2:
-#	   GROW - 1:
-#	   GROW:
-#	   BODY:        Test...3; Test...2; Test...1
-#
-# (The semicolons are here for clarification, but of course are not
-# emitted.)  This is what Autoconf 2.0 (I think) to 2.13 (I'm sure)
-# implement.
-#
-#
-# The second idea: first required first out
-# -----------------------------------------
-#
-# The natural implementation of the idea above is buggy and produces
-# very surprising results in some situations.  Let's consider the
-# following example to explain the bug:
-#
-# | m4_defun([TEST1],  [m4_require([TEST2a])m4_require([TEST2b])])
-# | m4_defun([TEST2a], [])
-# | m4_defun([TEST2b], [m4_require([TEST3])])
-# | m4_defun([TEST3],  [m4_require([TEST2a])])
-# |
-# | AC_INIT
-# | TEST1
-#
-# The dependencies between the macros are:
-#
-#		 3 --- 2b
-#		/        \              is m4_require'd by
-#	       /          \       left -------------------- right
-#	    2a ------------ 1
-#
-# If you strictly apply the rules given in the previous section you get:
-#
-#	   GROW - 2: TEST3
-#	   GROW - 1: TEST2a; TEST2b
-#	   GROW:     TEST1
-#	   BODY:
-#
-# (TEST2a, although required by TEST3 is not expanded in GROW - 3
-# because is has already been expanded before in GROW - 1, so it has
-# been AC_PROVIDE'd, so it is not expanded again) so when you undivert
-# the stack of diversions, you get:
-#
-#	   GROW - 2:
-#	   GROW - 1:
-#	   GROW:
-#	   BODY:        TEST3; TEST2a; TEST2b; TEST1
-#
-# i.e., TEST2a is expanded after TEST3 although the latter required the
-# former.
-#
-# Starting from 2.50, we use an implementation provided by Axel Thimm.
-# The idea is simple: the order in which macros are emitted must be the
-# same as the one in which macros are expanded.  (The bug above can
-# indeed be described as: a macro has been m4_provide'd before its
-# dependent, but it is emitted after: the lack of correlation between
-# emission and expansion order is guilty).
-#
-# How to do that?  You keep the stack of diversions to elaborate the
-# macros, but each time a macro is fully expanded, emit it immediately.
-#
-# In the example above, when TEST2a is expanded, but it's epilogue is
-# not run yet, you have:
-#
-#	   GROW - 2:
-#	   GROW - 1: TEST2a
-#	   GROW:     Elaboration of TEST1
-#	   BODY:
-#
-# The epilogue of TEST2a emits it immediately:
-#
-#	   GROW - 2:
-#	   GROW - 1:
-#	   GROW:     Elaboration of TEST1
-#	   BODY:     TEST2a
-#
-# TEST2b then requires TEST3, so right before the epilogue of TEST3, you
-# have:
-#
-#	   GROW - 2: TEST3
-#	   GROW - 1: Elaboration of TEST2b
-#	   GROW:     Elaboration of TEST1
-#	   BODY:      TEST2a
-#
-# The epilogue of TEST3 emits it:
-#
-#	   GROW - 2:
-#	   GROW - 1: Elaboration of TEST2b
-#	   GROW:     Elaboration of TEST1
-#	   BODY:     TEST2a; TEST3
-#
-# TEST2b is now completely expanded, and emitted:
-#
-#	   GROW - 2:
-#	   GROW - 1:
-#	   GROW:     Elaboration of TEST1
-#	   BODY:     TEST2a; TEST3; TEST2b
-#
-# and finally, TEST1 is finished and emitted:
-#
-#	   GROW - 2:
-#	   GROW - 1:
-#	   GROW:
-#	   BODY:     TEST2a; TEST3; TEST2b: TEST1
-#
-# The idea is simple, but the implementation is a bit involved.  If
-# you are like me, you will want to see the actual functioning of this
-# implementation to be convinced.  The next section gives the full
-# details.
-#
-#
-# The Axel Thimm implementation at work
-# -------------------------------------
-#
-# We consider the macros above, and this configure.ac:
-#
-#	    AC_INIT
-#	    TEST1
-#
-# You should keep the definitions of _m4_defun_pro, _m4_defun_epi, and
-# m4_require at hand to follow the steps.
-#
-# This implementation tries not to assume that the current diversion is
-# BODY, so as soon as a macro (m4_defun'd) is expanded, we first
-# record the current diversion under the name _m4_divert_dump (denoted
-# DUMP below for short).  This introduces an important difference with
-# the previous versions of Autoconf: you cannot use m4_require if you
-# are not inside an m4_defun'd macro, and especially, you cannot
-# m4_require directly from the top level.
-#
-# We have not tried to simulate the old behavior (better yet, we
-# diagnose it), because it is too dangerous: a macro m4_require'd from
-# the top level is expanded before the body of `configure', i.e., before
-# any other test was run.  I let you imagine the result of requiring
-# AC_STDC_HEADERS for instance, before AC_PROG_CC was actually run....
-#
-# After AC_INIT was run, the current diversion is BODY.
-# * AC_INIT was run
-#   DUMP:                undefined
-#   diversion stack:     BODY |-
-#
-# * TEST1 is expanded
-# The prologue of TEST1 sets _m4_divert_dump, which is the diversion
-# where the current elaboration will be dumped, to the current
-# diversion.  It also m4_divert_push to GROW, where the full
-# expansion of TEST1 and its dependencies will be elaborated.
-#   DUMP:        BODY
-#   BODY:        empty
-#   diversions:  GROW, BODY |-
-#
-# * TEST1 requires TEST2a
-# _m4_require_call m4_divert_pushes another temporary diversion,
-# GROW - 1, and expands TEST2a in there.
-#   DUMP:        BODY
-#   BODY:        empty
-#   GROW - 1:    TEST2a
-#   diversions:  GROW - 1, GROW, BODY |-
-# Then the content of the temporary diversion is moved to DUMP and the
-# temporary diversion is popped.
-#   DUMP:        BODY
-#   BODY:        TEST2a
-#   diversions:  GROW, BODY |-
-#
-# * TEST1 requires TEST2b
-# Again, _m4_require_call pushes GROW - 1 and heads to expand TEST2b.
-#   DUMP:        BODY
-#   BODY:        TEST2a
-#   diversions:  GROW - 1, GROW, BODY |-
-#
-# * TEST2b requires TEST3
-# _m4_require_call pushes GROW - 2 and expands TEST3 here.
-# (TEST3 requires TEST2a, but TEST2a has already been m4_provide'd, so
-# nothing happens.)
-#   DUMP:        BODY
-#   BODY:        TEST2a
-#   GROW - 2:    TEST3
-#   diversions:  GROW - 2, GROW - 1, GROW, BODY |-
-# Then the diversion is appended to DUMP, and popped.
-#   DUMP:        BODY
-#   BODY:        TEST2a; TEST3
-#   diversions:  GROW - 1, GROW, BODY |-
-#
-# * TEST1 requires TEST2b (contd.)
-# The content of TEST2b is expanded...
-#   DUMP:        BODY
-#   BODY:        TEST2a; TEST3
-#   GROW - 1:    TEST2b,
-#   diversions:  GROW - 1, GROW, BODY |-
-# ... and moved to DUMP.
-#   DUMP:        BODY
-#   BODY:        TEST2a; TEST3; TEST2b
-#   diversions:  GROW, BODY |-
-#
-# * TEST1 is expanded: epilogue
-# TEST1's own content is in GROW...
-#   DUMP:        BODY
-#   BODY:        TEST2a; TEST3; TEST2b
-#   GROW:        TEST1
-#   diversions:  BODY |-
-# ... and it's epilogue moves it to DUMP and then undefines DUMP.
-#   DUMP:       undefined
-#   BODY:       TEST2a; TEST3; TEST2b; TEST1
-#   diversions: BODY |-
-#
-#
-# The third idea: track macros provided before they were required
-# ---------------------------------------------------------------
-#
-# Using just the first two ideas, Autoconf 2.50 through 2.63 still had
-# a subtle bug for more than seven years.  Let's consider the
-# following example to explain the bug:
-#
-# | m4_defun([TEST1], [1])
-# | m4_defun([TEST2], [2[]m4_require([TEST1])])
-# | m4_defun([TEST3], [3 TEST1 m4_require([TEST2])])
-# | TEST3
-#
-# After the prologue of TEST3, we are collecting text in GROW with the
-# intent of dumping it in BODY during the epilogue.  Next, we
-# encounter the direct invocation of TEST1, which provides the macro
-# in place in GROW.  From there, we encounter a requirement for TEST2,
-# which must be collected in a new diversion.  While expanding TEST2,
-# we encounter a requirement for TEST1, but since it has already been
-# expanded, the Axel Thimm algorithm states that we can treat it as a
-# no-op.  But that would lead to an end result of `2 3 1', meaning
-# that we have once again output a macro (TEST2) prior to its
-# requirements (TEST1).
-#
-# The problem can only occur if a single defun'd macro first provides,
-# then later indirectly requires, the same macro.  Note that directly
-# expanding then requiring a macro is okay: because the dependency was
-# met, the require phase can be a no-op.  For that matter, the outer
-# macro can even require two helpers, where the first helper expands
-# the macro, and the second helper indirectly requires the macro.
-# Out-of-order expansion is only present if the inner macro is
-# required by something that will be hoisted in front of where the
-# direct expansion occurred.  In other words, we must be careful not
-# to warn on:
-#
-# | m4_defun([TEST4], [4])
-# | m4_defun([TEST5], [5 TEST4 m4_require([TEST4])])
-# | TEST5 => 5 4
-#
-# or even the more complex:
-#
-# | m4_defun([TEST6], [6])
-# | m4_defun([TEST7], [7 TEST6])
-# | m4_defun([TEST8], [8 m4_require([TEST6])])
-# | m4_defun([TEST9], [9 m4_require([TEST8])])
-# | m4_defun([TEST10], [10 m4_require([TEST7]) m4_require([TEST9])])
-# | TEST10 => 7 6 8 9 10
-#
-# So, to detect whether a require was direct or indirect, m4_defun and
-# m4_require track the name of the macro that caused a diversion to be
-# created (using the stack _m4_diverting, coupled with an O(1) lookup
-# _m4_diverting([NAME])), and m4_provide stores the name associated
-# with the diversion at which a macro was provided.  A require call is
-# direct if it occurs within the same diversion where the macro was
-# provided, or if the diversion associated with the providing context
-# has been collected.
-#
-# The implementation of the warning involves tracking the set of
-# macros which have been provided since the start of the outermost
-# defun'd macro (the set is named _m4_provide).  When starting an
-# outermost macro, the set is emptied; when a macro is provided, it is
-# added to the set; when require expands the body of a macro, it is
-# removed from the set; and when a macro is indirectly required, the
-# set is checked.  If a macro is in the set, then it has been provided
-# before it was required, and we satisfy dependencies by expanding the
-# macro as if it had never been provided; in the example given above,
-# this means we now output `1 2 3 1'.  Meanwhile, a warning is issued
-# to inform the user that her macros trigger the bug in older autoconf
-# versions, and that her output file now contains redundant contents
-# (and possibly new problems, if the repeated macro was not
-# idempotent).  Meanwhile, macros defined by m4_defun_once instead of
-# m4_defun are idempotent, avoiding any warning or duplicate output.
-#
-#
-# 2. Keeping track of the expansion stack
-# =======================================
-#
-# When M4 expansion goes wrong it is often extremely hard to find the
-# path amongst macros that drove to the failure.  What is needed is
-# the stack of macro `calls'. One could imagine that GNU M4 would
-# maintain a stack of macro expansions, unfortunately it doesn't, so
-# we do it by hand.  This is of course extremely costly, but the help
-# this stack provides is worth it.  Nevertheless to limit the
-# performance penalty this is implemented only for m4_defun'd macros,
-# not for define'd macros.
-#
-# Each time we enter an m4_defun'd macros, we add a definition in
-# _m4_expansion_stack, and when we exit the macro, we remove it (thanks
-# to pushdef/popdef).  m4_stack_foreach is used to print the expansion
-# stack in the rare cases when it's needed.
-#
-# In addition, we want to detect circular m4_require dependencies.
-# Each time we expand a macro FOO we define _m4_expanding(FOO); and
-# m4_require(BAR) simply checks whether _m4_expanding(BAR) is defined.
-
-
-# m4_expansion_stack
-# ------------------
-# Expands to the entire contents of the expansion stack.  The caller
-# must supply a trailing newline.  This macro always prints a
-# location; check whether _m4_expansion_stack is defined to filter out
-# the case when no defun'd macro is in force.
-m4_define([m4_expansion_stack],
-[m4_stack_foreach_sep_lifo([_$0], [_$0_entry(], [)
-])m4_location[: the top level]])
-
-# _m4_expansion_stack_entry(MACRO)
-# --------------------------------
-# Format an entry for MACRO found on the expansion stack.
-m4_define([_m4_expansion_stack_entry],
-[_m4_defn([m4_location($1)])[: $1 is expanded from...]])
-
-# m4_expansion_stack_push(MACRO)
-# ------------------------------
-# Form an entry of the expansion stack on entry to MACRO and push it.
-m4_define([m4_expansion_stack_push],
-[m4_pushdef([_m4_expansion_stack], [$1])])
-
-
-# _m4_divert(GROW)
-# ----------------
-# This diversion is used by the m4_defun/m4_require machinery.  It is
-# important to keep room before GROW because for each nested
-# AC_REQUIRE we use an additional diversion (i.e., two m4_require's
-# will use GROW - 2.  More than 3 levels has never seemed to be
-# needed.)
-#
-# ...
-# - GROW - 2
-#   m4_require'd code, 2 level deep
-# - GROW - 1
-#   m4_require'd code, 1 level deep
-# - GROW
-#   m4_defun'd macros are elaborated here.
-
-m4_define([_m4_divert(GROW)],       10000)
-
-
-# _m4_defun_pro(MACRO-NAME)
-# -------------------------
-# The prologue for Autoconf macros.
-#
-# This is called frequently, so minimize the number of macro invocations
-# by avoiding dnl and m4_defn overhead.
-m4_define([_m4_defun_pro],
-[m4_ifdef([_m4_expansion_stack], [], [_m4_defun_pro_outer([$1])])]dnl
-[m4_expansion_stack_push([$1])m4_pushdef([_m4_expanding($1)])])
-
-m4_define([_m4_defun_pro_outer],
-[m4_set_delete([_m4_provide])]dnl
-[m4_pushdef([_m4_diverting([$1])])m4_pushdef([_m4_diverting], [$1])]dnl
-[m4_pushdef([_m4_divert_dump], m4_divnum)m4_divert_push([GROW])])
-
-# _m4_defun_epi(MACRO-NAME)
-# -------------------------
-# The Epilogue for Autoconf macros.  MACRO-NAME only helps tracing
-# the PRO/EPI pairs.
-#
-# This is called frequently, so minimize the number of macro invocations
-# by avoiding dnl and m4_popdef overhead.
-m4_define([_m4_defun_epi],
-[_m4_popdef([_m4_expanding($1)], [_m4_expansion_stack])]dnl
-[m4_ifdef([_m4_expansion_stack], [], [_m4_defun_epi_outer([$1])])]dnl
-[m4_provide([$1])])
-
-m4_define([_m4_defun_epi_outer],
-[_m4_popdef([_m4_divert_dump], [_m4_diverting([$1])], [_m4_diverting])]dnl
-[m4_divert_pop([GROW])m4_undivert([GROW])])
-
-
-# _m4_divert_dump
-# ---------------
-# If blank, we are outside of any defun'd macro.  Otherwise, expands
-# to the diversion number (not name) where require'd macros should be
-# moved once completed.
-m4_define([_m4_divert_dump])
-
-
-# m4_divert_require(DIVERSION, NAME-TO-CHECK, [BODY-TO-EXPAND])
-# -------------------------------------------------------------
-# Same as m4_require, but BODY-TO-EXPAND goes into the named DIVERSION;
-# requirements still go in the current diversion though.
-#
-m4_define([m4_divert_require],
-[m4_ifdef([_m4_expanding($2)],
-  [m4_fatal([$0: circular dependency of $2])])]dnl
-[m4_if(_m4_divert_dump, [],
-  [m4_fatal([$0($2): cannot be used outside of an m4_defun'd macro])])]dnl
-[m4_provide_if([$2], [],
-  [_m4_require_call([$2], [$3], _m4_divert([$1], [-]))])])
-
-
-# m4_defun(NAME, EXPANSION, [MACRO = m4_define])
-# ----------------------------------------------
-# Define a macro NAME which automatically provides itself.  Add
-# machinery so the macro automatically switches expansion to the
-# diversion stack if it is not already using it, prior to EXPANSION.
-# In this case, once finished, it will bring back all the code
-# accumulated in the diversion stack.  This, combined with m4_require,
-# achieves the topological ordering of macros.  We don't use this
-# macro to define some frequently called macros that are not involved
-# in ordering constraints, to save m4 processing.
-#
-# MACRO is an undocumented argument; when set to m4_pushdef, and NAME
-# is already defined, the new definition is added to the pushdef
-# stack, rather than overwriting the current definition.  It can thus
-# be used to write self-modifying macros, which pop themselves to a
-# previously m4_define'd definition so that subsequent use of the
-# macro is faster.
-m4_define([m4_defun],
-[m4_define([m4_location($1)], m4_location)]dnl
-[m4_default([$3], [m4_define])([$1],
-  [_m4_defun_pro(]m4_dquote($[0])[)$2[]_m4_defun_epi(]m4_dquote($[0])[)])])
-
-
-# m4_defun_init(NAME, INIT, COMMON)
-# ---------------------------------
-# Like m4_defun, but split EXPANSION into two portions: INIT which is
-# done only the first time NAME is invoked, and COMMON which is
-# expanded every time.
-#
-# For now, the COMMON definition is always m4_define'd, giving an even
-# lighter-weight definition.  m4_defun allows self-providing, but once
-# a macro is provided, m4_require no longer cares if it is m4_define'd
-# or m4_defun'd.  m4_defun also provides location tracking to identify
-# dependency bugs, but once the INIT has been expanded, we know there
-# are no dependency bugs.  However, if a future use needs COMMON to be
-# m4_defun'd, we can add a parameter, similar to the third parameter
-# to m4_defun.
-m4_define([m4_defun_init],
-[m4_define([$1], [$3[]])m4_defun([$1],
-   [$2[]_m4_popdef(]m4_dquote($[0])[)m4_indir(]m4_dquote($[0])dnl
-[m4_if(]m4_dquote($[#])[, [0], [], ]m4_dquote([,$]@)[))], [m4_pushdef])])
-
-
-# m4_defun_once(NAME, EXPANSION)
-# ------------------------------
-# Like m4_defun, but guarantee that EXPANSION only happens once
-# (thereafter, using NAME is a no-op).
-#
-# If _m4_divert_dump is empty, we are called at the top level;
-# otherwise, we must ensure that we are required in front of the
-# current defun'd macro.  Use a helper macro so that EXPANSION need
-# only occur once in the definition of NAME, since it might be large.
-m4_define([m4_defun_once],
-[m4_define([m4_location($1)], m4_location)]dnl
-[m4_define([$1], [_m4_defun_once([$1], [$2], m4_if(_m4_divert_dump, [],
-  [[_m4_defun_pro([$1])m4_unquote(], [)_m4_defun_epi([$1])]],
-m4_ifdef([_m4_diverting([$1])], [-]), [-], [[m4_unquote(], [)]],
-  [[_m4_require_call([$1],], [, _m4_divert_dump)]]))])])
-
-m4_define([_m4_defun_once],
-[m4_pushdef([$1])$3[$2[]m4_provide([$1])]$4])
-
-
-# m4_pattern_forbid(ERE, [WHY])
-# -----------------------------
-# Declare that no token matching the forbidden perl extended regular
-# expression ERE should be seen in the output unless...
-m4_define([m4_pattern_forbid], [])
-
-
-# m4_pattern_allow(ERE)
-# ---------------------
-# ... that token also matches the allowed extended regular expression ERE.
-# Both used via traces, by autom4te post-processing.
-m4_define([m4_pattern_allow], [])
-
-
-## --------------------------------- ##
-## 11. Dependencies between macros.  ##
-## --------------------------------- ##
-
-
-# m4_before(THIS-MACRO-NAME, CALLED-MACRO-NAME)
-# ---------------------------------------------
-# Issue a warning if CALLED-MACRO-NAME was called before THIS-MACRO-NAME.
-m4_define([m4_before],
-[m4_provide_if([$2],
-	       [m4_warn([syntax], [$2 was called before $1])])])
-
-
-# m4_require(NAME-TO-CHECK, [BODY-TO-EXPAND = NAME-TO-CHECK])
-# -----------------------------------------------------------
-# If NAME-TO-CHECK has never been expanded (actually, if it is not
-# m4_provide'd), expand BODY-TO-EXPAND *before* the current macro
-# expansion; follow the expansion with a newline.  Once expanded, emit
-# it in _m4_divert_dump.  Keep track of the m4_require chain in
-# _m4_expansion_stack.
-#
-# The normal cases are:
-#
-# - NAME-TO-CHECK == BODY-TO-EXPAND
-#   Which you can use for regular macros with or without arguments, e.g.,
-#     m4_require([AC_PROG_CC], [AC_PROG_CC])
-#     m4_require([AC_CHECK_HEADERS(threads.h)], [AC_CHECK_HEADERS(threads.h)])
-#   which is just the same as
-#     m4_require([AC_PROG_CC])
-#     m4_require([AC_CHECK_HEADERS(threads.h)])
-#
-# - BODY-TO-EXPAND == m4_indir([NAME-TO-CHECK])
-#   In the case of macros with irregular names.  For instance:
-#     m4_require([AC_LANG_COMPILER(C)], [indir([AC_LANG_COMPILER(C)])])
-#   which means `if the macro named `AC_LANG_COMPILER(C)' (the parens are
-#   part of the name, it is not an argument) has not been run, then
-#   call it.'
-#   Had you used
-#     m4_require([AC_LANG_COMPILER(C)], [AC_LANG_COMPILER(C)])
-#   then m4_require would have tried to expand `AC_LANG_COMPILER(C)', i.e.,
-#   call the macro `AC_LANG_COMPILER' with `C' as argument.
-#
-#   You could argue that `AC_LANG_COMPILER', when it receives an argument
-#   such as `C' should dispatch the call to `AC_LANG_COMPILER(C)'.  But this
-#   `extension' prevents `AC_LANG_COMPILER' from having actual arguments that
-#   it passes to `AC_LANG_COMPILER(C)'.
-#
-# This is called frequently, so minimize the number of macro invocations
-# by avoiding dnl and other overhead on the common path.
-m4_define([m4_require],
-[m4_ifdef([_m4_expanding($1)],
-  [m4_fatal([$0: circular dependency of $1])])]dnl
-[m4_if(_m4_divert_dump, [],
-  [m4_fatal([$0($1): cannot be used outside of an ]dnl
-m4_if([$0], [m4_require], [[m4_defun]], [[AC_DEFUN]])['d macro])])]dnl
-[m4_provide_if([$1], [m4_set_contains([_m4_provide], [$1],
-    [_m4_require_check([$1], _m4_defn([m4_provide($1)]), [$0])], [m4_ignore])],
-  [_m4_require_call])([$1], [$2], _m4_divert_dump)])
-
-
-# _m4_require_call(NAME-TO-CHECK, [BODY-TO-EXPAND = NAME-TO-CHECK],
-#                  DIVERSION-NUMBER)
-# -----------------------------------------------------------------
-# If m4_require decides to expand the body, it calls this macro.  The
-# expansion is placed in DIVERSION-NUMBER.
-#
-# This is called frequently, so minimize the number of macro invocations
-# by avoiding dnl and other overhead on the common path.
-# The use of a witness macro protecting the warning allows aclocal
-# to silence any warnings when probing for what macros are required
-# and must therefore be located, when using the Autoconf-without-aclocal-m4
-# autom4te language.  For more background, see:
-# https://lists.gnu.org/archive/html/automake-patches/2012-11/msg00035.html
-m4_define([_m4_require_call],
-[m4_pushdef([_m4_divert_grow], m4_decr(_m4_divert_grow))]dnl
-[m4_pushdef([_m4_diverting([$1])])m4_pushdef([_m4_diverting], [$1])]dnl
-[m4_divert_push(_m4_divert_grow, [-])]dnl
-[m4_if([$2], [], [$1], [$2])
-m4_provide_if([$1], [m4_set_remove([_m4_provide], [$1])],
-  [m4_ifndef([m4_require_silent_probe],
-    [m4_warn([syntax], [$1 is m4_require'd but not m4_defun'd])])])]dnl
-[_m4_divert_raw($3)_m4_undivert(_m4_divert_grow)]dnl
-[m4_divert_pop(_m4_divert_grow)_m4_popdef([_m4_divert_grow],
-[_m4_diverting([$1])], [_m4_diverting])])
-
-
-# _m4_require_check(NAME-TO-CHECK, OWNER, CALLER)
-# -----------------------------------------------
-# NAME-TO-CHECK has been identified as previously expanded in the
-# diversion owned by OWNER.  If this is a problem, warn on behalf of
-# CALLER and return _m4_require_call; otherwise return m4_ignore.
-m4_define([_m4_require_check],
-[m4_if(_m4_defn([_m4_diverting]), [$2], [m4_ignore],
-       m4_ifdef([_m4_diverting([$2])], [-]), [-], [m4_warn([syntax],
-   [$3: `$1' was expanded before it was required
-https://www.gnu.org/software/autoconf/manual/autoconf.html#Expanded-Before-Required])_m4_require_call],
-       [m4_ignore])])
-
-
-# _m4_divert_grow
-# ---------------
-# The counter for _m4_require_call.
-m4_define([_m4_divert_grow], _m4_divert([GROW]))
-
-
-# m4_expand_once(TEXT, [WITNESS = TEXT])
-# --------------------------------------
-# If TEXT has never been expanded, expand it *here*.  Use WITNESS as
-# as a memory that TEXT has already been expanded.
-m4_define([m4_expand_once],
-[m4_provide_if(m4_default_quoted([$2], [$1]),
-	       [],
-	       [m4_provide(m4_default_quoted([$2], [$1]))[]$1])])
-
-
-# m4_provide(MACRO-NAME)
-# ----------------------
-m4_define([m4_provide],
-[m4_ifdef([m4_provide($1)], [],
-[m4_set_add([_m4_provide], [$1], [m4_define([m4_provide($1)],
-  m4_ifdef([_m4_diverting], [_m4_defn([_m4_diverting])]))])])])
-
-
-# m4_provide_if(MACRO-NAME, IF-PROVIDED, IF-NOT-PROVIDED)
-# -------------------------------------------------------
-# If MACRO-NAME is provided do IF-PROVIDED, else IF-NOT-PROVIDED.
-# The purpose of this macro is to provide the user with a means to
-# check macros which are provided without letting her know how the
-# information is coded.
-m4_define([m4_provide_if],
-[m4_ifdef([m4_provide($1)],
-	  [$2], [$3])])
-
-
-## --------------------- ##
-## 12. Text processing.  ##
-## --------------------- ##
-
-
-# m4_cr_letters
-# m4_cr_LETTERS
-# m4_cr_Letters
-# -------------
-m4_define([m4_cr_letters], [abcdefghijklmnopqrstuvwxyz])
-m4_define([m4_cr_LETTERS], [ABCDEFGHIJKLMNOPQRSTUVWXYZ])
-m4_define([m4_cr_Letters],
-m4_defn([m4_cr_letters])dnl
-m4_defn([m4_cr_LETTERS])dnl
-)
-
-
-# m4_cr_digits
-# ------------
-m4_define([m4_cr_digits], [0123456789])
-
-
-# m4_cr_alnum
-# -----------
-m4_define([m4_cr_alnum],
-m4_defn([m4_cr_Letters])dnl
-m4_defn([m4_cr_digits])dnl
-)
-
-
-# m4_cr_symbols1
-# m4_cr_symbols2
-# --------------
-m4_define([m4_cr_symbols1],
-m4_defn([m4_cr_Letters])dnl
-_)
-
-m4_define([m4_cr_symbols2],
-m4_defn([m4_cr_symbols1])dnl
-m4_defn([m4_cr_digits])dnl
-)
-
-# m4_cr_all
-# ---------
-# The character range representing everything, with `-' as the last
-# character, since it is special to m4_translit.  Use with care, because
-# it contains characters special to M4 (fortunately, both ASCII and EBCDIC
-# have [] in order, so m4_defn([m4_cr_all]) remains a valid string).  It
-# also contains characters special to terminals, so it should never be
-# displayed in an error message.  Also, attempts to map [ and ] to other
-# characters via m4_translit must deal with the fact that m4_translit does
-# not add quotes to the output.
-#
-# In EBCDIC, $ is immediately followed by *, which leads to problems
-# if m4_cr_all is inlined into a macro definition; so swap them.
-#
-# It is mainly useful in generating inverted character range maps, for use
-# in places where m4_translit is faster than an equivalent m4_bpatsubst;
-# the regex `[^a-z]' is equivalent to:
-#  m4_translit(m4_dquote(m4_defn([m4_cr_all])), [a-z])
-m4_define([m4_cr_all],
-m4_translit(m4_dquote(m4_format(m4_dquote(m4_for(
-  ,1,255,,[[%c]]))m4_for([i],1,255,,[,i]))), [$*-], [*$])-)
-
-
-# _m4_define_cr_not(CATEGORY)
-# ---------------------------
-# Define m4_cr_not_CATEGORY as the inverse of m4_cr_CATEGORY.
-m4_define([_m4_define_cr_not],
-[m4_define([m4_cr_not_$1],
-	   m4_translit(m4_dquote(m4_defn([m4_cr_all])),
-		       m4_defn([m4_cr_$1])))])
-
-
-# m4_cr_not_letters
-# m4_cr_not_LETTERS
-# m4_cr_not_Letters
-# m4_cr_not_digits
-# m4_cr_not_alnum
-# m4_cr_not_symbols1
-# m4_cr_not_symbols2
-# ------------------
-# Inverse character sets
-_m4_define_cr_not([letters])
-_m4_define_cr_not([LETTERS])
-_m4_define_cr_not([Letters])
-_m4_define_cr_not([digits])
-_m4_define_cr_not([alnum])
-_m4_define_cr_not([symbols1])
-_m4_define_cr_not([symbols2])
-
-
-# m4_newline([STRING])
-# --------------------
-# Expands to a newline, possibly followed by STRING.  Exists mostly for
-# formatting reasons.
-m4_define([m4_newline], [
-$1])
-
-
-# m4_re_escape(STRING)
-# --------------------
-# Escape RE active characters in STRING.
-m4_define([m4_re_escape],
-[m4_bpatsubst([$1],
-	      [[][*+.?\^$]], [\\\&])])
-
-
-# m4_re_string
-# ------------
-# Regexp for `[a-zA-Z_0-9]*'
-# m4_dquote provides literal [] for the character class.
-m4_define([m4_re_string],
-m4_dquote(m4_defn([m4_cr_symbols2]))dnl
-[*]dnl
-)
-
-
-# m4_re_word
-# ----------
-# Regexp for `[a-zA-Z_][a-zA-Z_0-9]*'
-m4_define([m4_re_word],
-m4_dquote(m4_defn([m4_cr_symbols1]))dnl
-m4_defn([m4_re_string])dnl
-)
-
-
-# m4_tolower(STRING)
-# m4_toupper(STRING)
-# ------------------
-# These macros convert STRING to lowercase or uppercase.
-#
-# Rather than expand the m4_defn each time, we inline them up front.
-m4_define([m4_tolower],
-[m4_translit([[$1]], ]m4_dquote(m4_defn([m4_cr_LETTERS]))[,
-		     ]m4_dquote(m4_defn([m4_cr_letters]))[)])
-m4_define([m4_toupper],
-[m4_translit([[$1]], ]m4_dquote(m4_defn([m4_cr_letters]))[,
-		     ]m4_dquote(m4_defn([m4_cr_LETTERS]))[)])
-
-
-# m4_split(STRING, [REGEXP])
-# --------------------------
-# Split STRING into an m4 list of quoted elements.  The elements are
-# quoted with [ and ].  Beginning spaces and end spaces *are kept*.
-# Use m4_strip to remove them.
-#
-# REGEXP specifies where to split.  Default is [\t ]+.
-#
-# If STRING is empty, the result is an empty list.
-#
-# Pay attention to the m4_changequotes.  When m4 reads the definition of
-# m4_split, it still has quotes set to [ and ].  Luckily, these are matched
-# in the macro body, so the definition is stored correctly.  Use the same
-# alternate quotes as m4_noquote; it must be unlikely to appear in $1.
-#
-# Also, notice that $1 is quoted twice, since we want the result to
-# be quoted.  Then you should understand that the argument of
-# patsubst is -=<{(STRING)}>=- (i.e., with additional -=<{( and )}>=-).
-#
-# This macro is safe on active symbols, i.e.:
-#   m4_define(active, ACTIVE)
-#   m4_split([active active ])end
-#   => [active], [active], []end
-#
-# Optimize on regex of ` ' (space), since m4_foreach_w already guarantees
-# that the list contains single space separators, and a common case is
-# splitting a single-element list.  This macro is called frequently,
-# so avoid unnecessary dnl inside the definition.
-m4_define([m4_split],
-[m4_if([$1], [], [],
-       [$2], [ ], [m4_if(m4_index([$1], [ ]), [-1], [[[$1]]],
-			 [_$0([$1], [$2], [, ])])],
-       [$2], [], [_$0([$1], [[	 ]+], [, ])],
-       [_$0([$1], [$2], [, ])])])
-
-m4_define([_m4_split],
-[m4_changequote([-=<{(],[)}>=-])]dnl
-[[m4_bpatsubst(-=<{(-=<{($1)}>=-)}>=-, -=<{($2)}>=-,
-	       -=<{(]$3[)}>=-)]m4_changequote([, ])])
-
-
-# m4_chomp(STRING)
-# m4_chomp_all(STRING)
-# --------------------
-# Return STRING quoted, but without a trailing newline.  m4_chomp
-# removes at most one newline, while m4_chomp_all removes all
-# consecutive trailing newlines.  Embedded newlines are not touched,
-# and a trailing backslash-newline leaves just a trailing backslash.
-#
-# m4_bregexp is slower than m4_index, and we don't always want to
-# remove all newlines; hence the two variants.  We massage characters
-# to give a nicer pattern to match, particularly since m4_bregexp is
-# line-oriented.  Both versions must guarantee a match, to avoid bugs
-# with precision -1 in m4_format in older m4.
-m4_define([m4_chomp],
-[m4_format([[%.*s]], m4_index(m4_translit([[$1]], [
-/.], [/  ])[./.], [/.]), [$1])])
-
-m4_define([m4_chomp_all],
-[m4_format([[%.*s]], m4_bregexp(m4_translit([[$1]], [
-/], [/ ]), [/*$]), [$1])])
-
-
-# m4_flatten(STRING)
-# ------------------
-# If STRING contains end of lines, replace them with spaces.  If there
-# are backslashed end of lines, remove them.  This macro is safe with
-# active symbols.
-#    m4_define(active, ACTIVE)
-#    m4_flatten([active
-#    act\
-#    ive])end
-#    => active activeend
-#
-# In m4, m4_bpatsubst is expensive, so first check for a newline.
-m4_define([m4_flatten],
-[m4_if(m4_index([$1], [
-]), [-1], [[$1]],
-       [m4_translit(m4_bpatsubst([[[$1]]], [\\
-]), [
-], [ ])])])
-
-
-# m4_strip(STRING)
-# ----------------
-# Expands into STRING with tabs and spaces singled out into a single
-# space, and removing leading and trailing spaces.
-#
-# This macro is robust to active symbols.
-#    m4_define(active, ACTIVE)
-#    m4_strip([  active <tab> <tab>active ])end
-#    => active activeend
-#
-# First, notice that we guarantee trailing space.  Why?  Because regular
-# expressions are greedy, and `.* ?' would always group the space into the
-# .* portion.  The algorithm is simpler by avoiding `?' at the end.  The
-# algorithm correctly strips everything if STRING is just ` '.
-#
-# Then notice the second pattern: it is in charge of removing the
-# leading/trailing spaces.  Why not just `[^ ]'?  Because they are
-# applied to over-quoted strings, i.e. more or less [STRING], due
-# to the limitations of m4_bpatsubsts.  So the leading space in STRING
-# is the *second* character; equally for the trailing space.
-m4_define([m4_strip],
-[m4_bpatsubsts([$1 ],
-	       [[	 ]+], [ ],
-	       [^. ?\(.*\) .$], [[[\1]]])])
-
-
-# m4_normalize(STRING)
-# --------------------
-# Apply m4_flatten and m4_strip to STRING.
-#
-# The argument is quoted, so that the macro is robust to active symbols:
-#
-#    m4_define(active, ACTIVE)
-#    m4_normalize([  act\
-#    ive
-#    active ])end
-#    => active activeend
-
-m4_define([m4_normalize],
-[m4_strip(m4_flatten([$1]))])
-
-
-
-# m4_join(SEP, ARG1, ARG2...)
-# ---------------------------
-# Produce ARG1SEPARG2...SEPARGn.  Avoid back-to-back SEP when a given ARG
-# is the empty string.  No expansion is performed on SEP or ARGs.
-#
-# Since the number of arguments to join can be arbitrarily long, we
-# want to avoid having more than one $@ in the macro definition;
-# otherwise, the expansion would require twice the memory of the already
-# long list.  Hence, m4_join merely looks for the first non-empty element,
-# and outputs just that element; while _m4_join looks for all non-empty
-# elements, and outputs them following a separator.  The final trick to
-# note is that we decide between recursing with $0 or _$0 based on the
-# nested m4_if ending with `_'.
-#
-# Please keep foreach.m4 in sync with any adjustments made here.
-m4_define([m4_join],
-[m4_if([$#], [1], [],
-       [$#], [2], [[$2]],
-       [m4_if([$2], [], [], [[$2]_])$0([$1], m4_shift2($@))])])
-m4_define([_m4_join],
-[m4_if([$#$2], [2], [],
-       [m4_if([$2], [], [], [[$1$2]])$0([$1], m4_shift2($@))])])
-
-# m4_joinall(SEP, ARG1, ARG2...)
-# ------------------------------
-# Produce ARG1SEPARG2...SEPARGn.  An empty ARG results in back-to-back SEP.
-# No expansion is performed on SEP or ARGs.
-#
-# Please keep foreach.m4 in sync with any adjustments made here.
-m4_define([m4_joinall], [[$2]_$0([$1], m4_shift($@))])
-m4_define([_m4_joinall],
-[m4_if([$#], [2], [], [[$1$3]$0([$1], m4_shift2($@))])])
-
-# m4_combine([SEPARATOR], PREFIX-LIST, [INFIX], SUFFIX...)
-# --------------------------------------------------------
-# Produce the pairwise combination of every element in the quoted,
-# comma-separated PREFIX-LIST with every element from the SUFFIX arguments.
-# Each pair is joined with INFIX, and pairs are separated by SEPARATOR.
-# No expansion occurs on SEPARATOR, INFIX, or elements of either list.
-#
-# For example:
-#   m4_combine([, ], [[a], [b], [c]], [-], [1], [2], [3])
-#   => a-1, a-2, a-3, b-1, b-2, b-3, c-1, c-2, c-3
-#
-# This definition is a bit hairy; the thing to realize is that we want
-# to construct m4_map_args_sep([[prefix$3]], [], [[$1]], m4_shift3($@))
-# as the inner loop, using each prefix generated by the outer loop,
-# and without recalculating m4_shift3 every outer iteration.
-m4_define([m4_combine],
-[m4_if([$2], [], [], m4_eval([$# > 3]), [1],
-[m4_map_args_sep([m4_map_args_sep(m4_dquote(], [)[[$3]], [], [[$1]],]]]dnl
-[m4_dquote(m4_dquote(m4_shift3($@)))[[)], [[$1]], $2)])])
-
-
-# m4_append(MACRO-NAME, STRING, [SEPARATOR])
-# ------------------------------------------
-# Redefine MACRO-NAME to hold its former content plus `SEPARATOR`'STRING'
-# at the end.  It is valid to use this macro with MACRO-NAME undefined,
-# in which case no SEPARATOR is added.  Be aware that the criterion is
-# `not being defined', and not `not being empty'.
-#
-# Note that neither STRING nor SEPARATOR are expanded here; rather, when
-# you expand MACRO-NAME, they will be expanded at that point in time.
-#
-# This macro is robust to active symbols.  It can be used to grow
-# strings.
-#
-#    | m4_define(active, ACTIVE)dnl
-#    | m4_append([sentence], [This is an])dnl
-#    | m4_append([sentence], [ active ])dnl
-#    | m4_append([sentence], [symbol.])dnl
-#    | sentence
-#    | m4_undefine([active])dnl
-#    | sentence
-#    => This is an ACTIVE symbol.
-#    => This is an active symbol.
-#
-# It can be used to define hooks.
-#
-#    | m4_define(active, ACTIVE)dnl
-#    | m4_append([hooks], [m4_define([act1], [act2])])dnl
-#    | m4_append([hooks], [m4_define([act2], [active])])dnl
-#    | m4_undefine([active])dnl
-#    | act1
-#    | hooks
-#    | act1
-#    => act1
-#    =>
-#    => active
-#
-# It can also be used to create lists, although this particular usage was
-# broken prior to autoconf 2.62.
-#    | m4_append([list], [one], [, ])dnl
-#    | m4_append([list], [two], [, ])dnl
-#    | m4_append([list], [three], [, ])dnl
-#    | list
-#    | m4_dquote(list)
-#    => one, two, three
-#    => [one],[two],[three]
-#
-# Note that m4_append can benefit from amortized O(n) m4 behavior, if
-# the underlying m4 implementation is smart enough to avoid copying existing
-# contents when enlarging a macro's definition into any pre-allocated storage
-# (m4 1.4.x unfortunately does not implement this optimization).  We do
-# not implement m4_prepend, since it is inherently O(n^2) (pre-allocated
-# storage only occurs at the end of a macro, so the existing contents must
-# always be moved).
-#
-# Use _m4_defn for speed.
-m4_define([m4_append],
-[m4_define([$1], m4_ifdef([$1], [_m4_defn([$1])[$3]])[$2])])
-
-
-# m4_append_uniq(MACRO-NAME, STRING, [SEPARATOR], [IF-UNIQ], [IF-DUP])
-# --------------------------------------------------------------------
-# Like `m4_append', but append only if not yet present.  Additionally,
-# expand IF-UNIQ if STRING was appended, or IF-DUP if STRING was already
-# present.  Also, warn if SEPARATOR is not empty and occurs within STRING,
-# as the algorithm no longer guarantees uniqueness.
-#
-# Note that while m4_append can be O(n) (depending on the quality of the
-# underlying M4 implementation), m4_append_uniq is inherently O(n^2)
-# because each append operation searches the entire string.
-m4_define([m4_append_uniq],
-[m4_ifval([$3], [m4_if(m4_index([$2], [$3]), [-1], [],
-		       [m4_warn([syntax],
-				[$0: `$2' contains `$3'])])])_$0($@)])
-m4_define([_m4_append_uniq],
-[m4_ifdef([$1],
-	  [m4_if(m4_index([$3]_m4_defn([$1])[$3], [$3$2$3]), [-1],
-		 [m4_append([$1], [$2], [$3])$4], [$5])],
-	  [m4_define([$1], [$2])$4])])
-
-# m4_append_uniq_w(MACRO-NAME, STRINGS)
-# -------------------------------------
-# For each of the words in the whitespace separated list STRINGS, append
-# only the unique strings to the definition of MACRO-NAME.
-#
-# Use _m4_defn for speed.
-m4_define([m4_append_uniq_w],
-[m4_map_args_w([$2], [_m4_append_uniq([$1],], [, [ ])])])
-
-
-# m4_escape(STRING)
-# -----------------
-# Output quoted STRING, but with embedded #, $, [ and ] turned into
-# quadrigraphs.
-#
-# It is faster to check if STRING is already good using m4_translit
-# than to blindly perform four m4_bpatsubst.
-#
-# Because the translit is stripping quotes, it must also neutralize
-# anything that might be in a macro name, as well as comments, commas,
-# and parentheses.  All the problem characters are unified so that a
-# single m4_index can scan the result.
-#
-# Rather than expand m4_defn every time m4_escape is expanded, we
-# inline its expansion up front.
-m4_define([m4_escape],
-[m4_if(m4_index(m4_translit([$1],
-   [[]#,()]]m4_dquote(m4_defn([m4_cr_symbols2]))[, [$$$]), [$]),
-  [-1], [m4_echo], [_$0])([$1])])
-
-m4_define([_m4_escape],
-[m4_changequote([-=<{(],[)}>=-])]dnl
-[m4_bpatsubst(m4_bpatsubst(m4_bpatsubst(m4_bpatsubst(
-	  -=<{(-=<{(-=<{(-=<{(-=<{($1)}>=-)}>=-)}>=-)}>=-)}>=-,
-	-=<{(#)}>=-, -=<{(@%:@)}>=-),
-      -=<{(\[)}>=-, -=<{(@<:@)}>=-),
-    -=<{(\])}>=-, -=<{(@:>@)}>=-),
-  -=<{(\$)}>=-, -=<{(@S|@)}>=-)m4_changequote([,])])
-
-
-# m4_text_wrap(STRING, [PREFIX], [FIRST-PREFIX], [WIDTH])
-# -------------------------------------------------------
-# Expands into STRING wrapped to hold in WIDTH columns (default = 79).
-# If PREFIX is given, each line is prefixed with it.  If FIRST-PREFIX is
-# specified, then the first line is prefixed with it.  As a special case,
-# if the length of FIRST-PREFIX is greater than that of PREFIX, then
-# FIRST-PREFIX will be left alone on the first line.
-#
-# No expansion occurs on the contents STRING, PREFIX, or FIRST-PREFIX,
-# although quadrigraphs are correctly recognized.  More precisely,
-# you may redefine m4_qlen to recognize whatever escape sequences that
-# you will post-process.
-#
-# Typical outputs are:
-#
-# m4_text_wrap([Short string */], [   ], [/* ], 20)
-#  => /* Short string */
-#
-# m4_text_wrap([Much longer string */], [   ], [/* ], 20)
-#  => /* Much longer
-#  =>    string */
-#
-# m4_text_wrap([Short doc.], [          ], [  --short ], 30)
-#  =>   --short Short doc.
-#
-# m4_text_wrap([Short doc.], [          ], [  --too-wide ], 30)
-#  =>   --too-wide
-#  =>           Short doc.
-#
-# m4_text_wrap([Super long documentation.], [          ], [  --too-wide ], 30)
-#  =>   --too-wide
-#  =>      Super long
-#  =>      documentation.
-#
-# FIXME: there is no checking of a longer PREFIX than WIDTH, but do
-# we really want to bother with people trying each single corner
-# of a software?
-#
-# This macro does not leave a trailing space behind the last word of a line,
-# which complicates it a bit.  The algorithm is otherwise stupid and simple:
-# all the words are preceded by m4_Separator which is defined to empty for
-# the first word, and then ` ' (single space) for all the others.
-#
-# The algorithm uses a helper that uses $2 through $4 directly, rather than
-# using local variables, to avoid m4_defn overhead, or expansion swallowing
-# any $.  It also bypasses m4_popdef overhead with _m4_popdef since no user
-# macro expansion occurs in the meantime.  Also, the definition is written
-# with m4_do, to avoid time wasted on dnl during expansion (since this is
-# already a time-consuming macro).
-m4_define([m4_text_wrap],
-[_$0(m4_escape([$1]), [$2], m4_default_quoted([$3], [$2]),
-     m4_default_quoted([$4], [79]))])
-
-m4_define([_m4_text_wrap],
-m4_do(dnl set up local variables, to avoid repeated calculations
-[[m4_pushdef([m4_Indent], m4_qlen([$2]))]],
-[[m4_pushdef([m4_Cursor], m4_qlen([$3]))]],
-[[m4_pushdef([m4_Separator], [m4_define([m4_Separator], [ ])])]],
-dnl expand the first prefix, then check its length vs. regular prefix
-dnl same length: nothing special
-dnl prefix1 longer: output on line by itself, and reset cursor
-dnl prefix1 shorter: pad to length of prefix, and reset cursor
-[[[$3]m4_cond([m4_Cursor], m4_Indent, [],
-	      [m4_eval(m4_Cursor > m4_Indent)], [1], [
-[$2]m4_define([m4_Cursor], m4_Indent)],
-	      [m4_format([%*s], m4_max([0],
-  m4_eval(m4_Indent - m4_Cursor)), [])m4_define([m4_Cursor], m4_Indent)])]],
-dnl now, for each word, compute the cursor after the word is output, then
-dnl check if the cursor would exceed the wrap column
-dnl if so, reset cursor, and insert newline and prefix
-dnl if not, insert the separator (usually a space)
-dnl either way, insert the word
-[[m4_map_args_w([$1], [$0_word(], [, [$2], [$4])])]],
-dnl finally, clean up the local variables
-[[_m4_popdef([m4_Separator], [m4_Cursor], [m4_Indent])]]))
-
-m4_define([_m4_text_wrap_word],
-[m4_define([m4_Cursor], m4_eval(m4_Cursor + m4_qlen([$1]) + 1))]dnl
-[m4_if(m4_eval(m4_Cursor > ([$3])),
-      [1], [m4_define([m4_Cursor], m4_eval(m4_Indent + m4_qlen([$1]) + 1))
-[$2]],
-      [m4_Separator[]])[$1]])
-
-# m4_text_box(MESSAGE, [FRAME-CHARACTER = `-'])
-# ---------------------------------------------
-# Turn MESSAGE into:
-#  ## ------- ##
-#  ## MESSAGE ##
-#  ## ------- ##
-# using FRAME-CHARACTER in the border.
-#
-# Quadrigraphs are correctly recognized.  More precisely, you may
-# redefine m4_qlen to recognize whatever escape sequences that you
-# will post-process.
-m4_define([m4_text_box],
-[m4_pushdef([m4_Border],
-	    m4_translit(m4_format([[[%*s]]], m4_decr(m4_qlen(_m4_expand([$1
-]))), []), [ ], m4_default_quoted([$2], [-])))]dnl
-[[##] _m4_defn([m4_Border]) [##]
-[##] $1 [##]
-[##] _m4_defn([m4_Border]) [##]_m4_popdef([m4_Border])])
-
-
-# m4_qlen(STRING)
-# ---------------
-# Expands to the length of STRING after autom4te converts all quadrigraphs.
-#
-# If you use some other means of post-processing m4 output rather than
-# autom4te, then you may redefine this macro to recognize whatever
-# escape sequences your post-processor will handle.  For that matter,
-# m4_define([m4_qlen], m4_defn([m4_len])) is sufficient if you don't
-# do any post-processing.
-#
-# Avoid bpatsubsts for the common case of no quadrigraphs.  Cache
-# results, as configure scripts tend to ask about lengths of common
-# strings like `/*' and `*/' rather frequently.  Minimize the number
-# of times that $1 occurs in m4_qlen, so there is less text to parse
-# on a cache hit.
-m4_define([m4_qlen],
-[m4_ifdef([$0-$1], [_m4_defn([$0-]], [_$0(])[$1])])
-m4_define([_m4_qlen],
-[m4_define([m4_qlen-$1],
-m4_if(m4_index([$1], [@]), [-1], [m4_len([$1])],
-      [m4_len(m4_bpatsubst([[$1]],
-			   [@\(\(<:\|:>\|S|\|%:\|\{:\|:\}\)\(@\)\|&t@\)],
-			   [\3]))]))_m4_defn([m4_qlen-$1])])
-
-# m4_copyright_condense(TEXT)
-# ---------------------------
-# Condense the copyright notice in TEXT to only display the final
-# year, wrapping the results to fit in 80 columns.
-m4_define([m4_copyright_condense],
-[m4_text_wrap(m4_bpatsubst(m4_flatten([[$1]]),
-[(C)[-	 ,0-9]*\([1-9][0-9][0-9][0-9]\)], [(C) \1]))])
-
-## ----------------------- ##
-## 13. Number processing.  ##
-## ----------------------- ##
-
-# m4_cmp(A, B)
-# ------------
-# Compare two integer expressions.
-# A < B -> -1
-# A = B ->  0
-# A > B ->  1
-m4_define([m4_cmp],
-[m4_eval((([$1]) > ([$2])) - (([$1]) < ([$2])))])
-
-
-# m4_list_cmp(A, B)
-# -----------------
-#
-# Compare the two lists of integer expressions A and B.  For instance:
-#   m4_list_cmp([1, 0],     [1])    ->  0
-#   m4_list_cmp([1, 0],     [1, 0]) ->  0
-#   m4_list_cmp([1, 2],     [1, 0]) ->  1
-#   m4_list_cmp([1, 2, 3],  [1, 2]) ->  1
-#   m4_list_cmp([1, 2, -3], [1, 2]) -> -1
-#   m4_list_cmp([1, 0],     [1, 2]) -> -1
-#   m4_list_cmp([1],        [1, 2]) -> -1
-#   m4_define([xa], [oops])dnl
-#   m4_list_cmp([[0xa]],    [5+5])  -> 0
-#
-# Rather than face the overhead of m4_case, we use a helper function whose
-# expansion includes the name of the macro to invoke on the tail, either
-# m4_ignore or m4_unquote.  This is particularly useful when comparing
-# long lists, since less text is being expanded for deciding when to end
-# recursion.  The recursion is between a pair of macros that alternate
-# which list is trimmed by one element; this is more efficient than
-# calling m4_cdr on both lists from a single macro.  Guarantee exactly
-# one expansion of both lists' side effects.
-#
-# Please keep foreach.m4 in sync with any adjustments made here.
-m4_define([m4_list_cmp],
-[_$0_raw(m4_dquote($1), m4_dquote($2))])
-
-m4_define([_m4_list_cmp_raw],
-[m4_if([$1], [$2], [0], [_m4_list_cmp_1([$1], $2)])])
-
-m4_define([_m4_list_cmp],
-[m4_if([$1], [], [0m4_ignore], [$2], [0], [m4_unquote], [$2m4_ignore])])
-
-m4_define([_m4_list_cmp_1],
-[_m4_list_cmp_2([$2], [m4_shift2($@)], $1)])
-
-m4_define([_m4_list_cmp_2],
-[_m4_list_cmp([$1$3], m4_cmp([$3+0], [$1+0]))(
-  [_m4_list_cmp_1(m4_dquote(m4_shift3($@)), $2)])])
-
-# m4_max(EXPR, ...)
-# m4_min(EXPR, ...)
-# -----------------
-# Return the decimal value of the maximum (or minimum) in a series of
-# integer expressions.
-#
-# M4 1.4.x doesn't provide ?:.  Hence this huge m4_eval.  Avoid m4_eval
-# if both arguments are identical, but be aware of m4_max(0xa, 10) (hence
-# the use of <=, not just <, in the second multiply).
-#
-# Please keep foreach.m4 in sync with any adjustments made here.
-m4_define([m4_max],
-[m4_if([$#], [0], [m4_fatal([too few arguments to $0])],
-       [$#], [1], [m4_eval([$1])],
-       [$#$1], [2$2], [m4_eval([$1])],
-       [$#], [2], [_$0($@)],
-       [_m4_minmax([_$0], $@)])])
-
-m4_define([_m4_max],
-[m4_eval((([$1]) > ([$2])) * ([$1]) + (([$1]) <= ([$2])) * ([$2]))])
-
-m4_define([m4_min],
-[m4_if([$#], [0], [m4_fatal([too few arguments to $0])],
-       [$#], [1], [m4_eval([$1])],
-       [$#$1], [2$2], [m4_eval([$1])],
-       [$#], [2], [_$0($@)],
-       [_m4_minmax([_$0], $@)])])
-
-m4_define([_m4_min],
-[m4_eval((([$1]) < ([$2])) * ([$1]) + (([$1]) >= ([$2])) * ([$2]))])
-
-# _m4_minmax(METHOD, ARG1, ARG2...)
-# ---------------------------------
-# Common recursion code for m4_max and m4_min.  METHOD must be _m4_max
-# or _m4_min, and there must be at least two arguments to combine.
-#
-# Please keep foreach.m4 in sync with any adjustments made here.
-m4_define([_m4_minmax],
-[m4_if([$#], [3], [$1([$2], [$3])],
-       [$0([$1], $1([$2], [$3]), m4_shift3($@))])])
-
-
-# m4_sign(A)
-# ----------
-# The sign of the integer expression A.
-m4_define([m4_sign],
-[m4_eval((([$1]) > 0) - (([$1]) < 0))])
-
-
-
-## ------------------------ ##
-## 14. Version processing.  ##
-## ------------------------ ##
-
-
-# m4_version_unletter(VERSION)
-# ----------------------------
-# Normalize beta version numbers with letters to numeric expressions, which
-# can then be handed to m4_eval for the purpose of comparison.
-#
-#   Nl -> (N+1).-1.(l#)
-#
-# for example:
-#   [2.14a] -> [0,2,14+1,-1,[0r36:a]] -> 2.15.-1.10
-#   [2.14b] -> [0,2,15+1,-1,[0r36:b]] -> 2.15.-1.11
-#   [2.61aa.b] -> [0,2.61,1,-1,[0r36:aa],+1,-1,[0r36:b]] -> 2.62.-1.370.1.-1.11
-#   [08] -> [0,[0r10:0]8] -> 8
-#
-# This macro expects reasonable version numbers, but can handle double
-# letters and does not expand any macros.  Original version strings can
-# use both `.' and `-' separators.
-#
-# Inline constant expansions, to avoid m4_defn overhead.
-# _m4_version_unletter is the real workhorse used by m4_version_compare,
-# but since [0r36:a] and commas are less readable than 10 and dots, we
-# provide a wrapper for human use.
-m4_define([m4_version_unletter],
-[m4_substr(m4_map_args([.m4_eval], m4_unquote(_$0([$1]))), [3])])
-m4_define([_m4_version_unletter],
-[m4_bpatsubst(m4_bpatsubst(m4_translit([[[[0,$1]]]], [.-], [,,]),]dnl
-m4_dquote(m4_dquote(m4_defn([m4_cr_Letters])))[[+],
-	      [+1,-1,[0r36:\&]]), [,0], [,[0r10:0]])])
-
-
-# m4_version_compare(VERSION-1, VERSION-2)
-# ----------------------------------------
-# Compare the two version numbers and expand into
-#  -1 if VERSION-1 < VERSION-2
-#   0 if           =
-#   1 if           >
-#
-# Since _m4_version_unletter does not output side effects, we can
-# safely bypass the overhead of m4_version_cmp.
-m4_define([m4_version_compare],
-[_m4_list_cmp_raw(_m4_version_unletter([$1]), _m4_version_unletter([$2]))])
-
-
-# m4_PACKAGE_NAME
-# m4_PACKAGE_TARNAME
-# m4_PACKAGE_VERSION
-# m4_PACKAGE_STRING
-# m4_PACKAGE_BUGREPORT
-# --------------------
-# If m4sugar/version.m4 is present, then define version strings.  This
-# file is optional, provided by Autoconf but absent in Bison.
-m4_sinclude([m4sugar/version.m4])
-
-
-# m4_version_prereq(VERSION, [IF-OK], [IF-NOT = FAIL])
-# ----------------------------------------------------
-# Check this Autoconf version against VERSION.
-m4_define([m4_version_prereq],
-m4_ifdef([m4_PACKAGE_VERSION],
-[[m4_if(m4_version_compare(]m4_dquote(m4_defn([m4_PACKAGE_VERSION]))[, [$1]),
-	[-1],
-	[m4_default([$3],
-		    [m4_fatal([Autoconf version $1 or higher is required],
-			      [63])])],
-	[$2])]],
-[[m4_fatal([m4sugar/version.m4 not found])]]))
-
-
-## ------------------ ##
-## 15. Set handling.  ##
-## ------------------ ##
-
-# Autoconf likes to create arbitrarily large sets; for example, as of
-# this writing, the configure.ac for coreutils tracks a set of more
-# than 400 AC_SUBST.  How do we track all of these set members,
-# without introducing duplicates?  We could use m4_append_uniq, with
-# the set NAME residing in the contents of the macro NAME.
-# Unfortunately, m4_append_uniq is quadratic for set creation, because
-# it costs O(n) to search the string for each of O(n) insertions; not
-# to mention that with m4 1.4.x, even using m4_append is slow, costing
-# O(n) rather than O(1) per insertion.  Other set operations, not used
-# by Autoconf but still possible by manipulation of the definition
-# tracked in macro NAME, include O(n) deletion of one element and O(n)
-# computation of set size.  Because the set is exposed to the user via
-# the definition of a single macro, we cannot cache any data about the
-# set without risking the cache being invalidated by the user
-# redefining NAME.
-#
-# Can we do better?  Yes, because m4 gives us an O(1) search function
-# for free: ifdef.  Additionally, even m4 1.4.x gives us an O(1)
-# insert operation for free: pushdef.  But to use these, we must
-# represent the set via a group of macros; to keep the set consistent,
-# we must hide the set so that the user can only manipulate it through
-# accessor macros.  The contents of the set are maintained through two
-# access points; _m4_set([name]) is a pushdef stack of values in the
-# set, useful for O(n) traversal of the set contents; while the
-# existence of _m4_set([name],value) with no particular value is
-# useful for O(1) querying of set membership.  And since the user
-# cannot externally manipulate the set, we are free to add additional
-# caching macros for other performance improvements.  Deletion can be
-# O(1) per element rather than O(n), by reworking the definition of
-# _m4_set([name],value) to be 0 or 1 based on current membership, and
-# adding _m4_set_cleanup(name) to defer the O(n) cleanup of
-# _m4_set([name]) until we have another reason to do an O(n)
-# traversal.  The existence of _m4_set_cleanup(name) can then be used
-# elsewhere to determine if we must dereference _m4_set([name],value),
-# or assume that definition implies set membership.  Finally, size can
-# be tracked in an O(1) fashion with _m4_set_size(name).
-#
-# The quoting in _m4_set([name],value) is chosen so that there is no
-# ambiguity with a set whose name contains a comma, and so that we can
-# supply the value via _m4_defn([_m4_set([name])]) without needing any
-# quote manipulation.
-
-# m4_set_add(SET, VALUE, [IF-UNIQ], [IF-DUP])
-# -------------------------------------------
-# Add VALUE as an element of SET.  Expand IF-UNIQ on the first
-# addition, and IF-DUP if it is already in the set.  Addition of one
-# element is O(1), such that overall set creation is O(n).
-#
-# We do not want to add a duplicate for a previously deleted but
-# unpruned element, but it is just as easy to check existence directly
-# as it is to query _m4_set_cleanup($1).
-m4_define([m4_set_add],
-[m4_ifdef([_m4_set([$1],$2)],
-	  [m4_if(m4_indir([_m4_set([$1],$2)]), [0],
-		 [m4_define([_m4_set([$1],$2)],
-			    [1])_m4_set_size([$1], [m4_incr])$3], [$4])],
-	  [m4_define([_m4_set([$1],$2)],
-		     [1])m4_pushdef([_m4_set([$1])],
-				    [$2])_m4_set_size([$1], [m4_incr])$3])])
-
-# m4_set_add_all(SET, VALUE...)
-# -----------------------------
-# Add each VALUE into SET.  This is O(n) in the number of VALUEs, and
-# can be faster than calling m4_set_add for each VALUE.
-#
-# Implement two recursion helpers; the check variant is slower but
-# handles the case where an element has previously been removed but
-# not pruned.  The recursion helpers ignore their second argument, so
-# that we can use the faster m4_shift2 and 2 arguments, rather than
-# _m4_shift2 and one argument, as the signal to end recursion.
-#
-# Please keep foreach.m4 in sync with any adjustments made here.
-m4_define([m4_set_add_all],
-[m4_define([_m4_set_size($1)], m4_eval(m4_set_size([$1])
-  + m4_len(m4_ifdef([_m4_set_cleanup($1)], [_$0_check], [_$0])([$1], $@))))])
-
-m4_define([_m4_set_add_all],
-[m4_if([$#], [2], [],
-       [m4_ifdef([_m4_set([$1],$3)], [],
-		 [m4_define([_m4_set([$1],$3)], [1])m4_pushdef([_m4_set([$1])],
-	   [$3])-])$0([$1], m4_shift2($@))])])
-
-m4_define([_m4_set_add_all_check],
-[m4_if([$#], [2], [],
-       [m4_set_add([$1], [$3])$0([$1], m4_shift2($@))])])
-
-# m4_set_contains(SET, VALUE, [IF-PRESENT], [IF-ABSENT])
-# ------------------------------------------------------
-# Expand IF-PRESENT if SET contains VALUE, otherwise expand IF-ABSENT.
-# This is always O(1).
-m4_define([m4_set_contains],
-[m4_ifdef([_m4_set_cleanup($1)],
-	  [m4_if(m4_ifdef([_m4_set([$1],$2)],
-		    [m4_indir([_m4_set([$1],$2)])], [0]), [1], [$3], [$4])],
-	  [m4_ifdef([_m4_set([$1],$2)], [$3], [$4])])])
-
-# m4_set_contents(SET, [SEP])
-# ---------------------------
-# Expand to a single string containing all the elements in SET,
-# separated by SEP, without modifying SET.  No provision is made for
-# disambiguating set elements that contain non-empty SEP as a
-# sub-string, or for recognizing a set that contains only the empty
-# string.  Order of the output is not guaranteed.  If any elements
-# have been previously removed from the set, this action will prune
-# the unused memory.  This is O(n) in the size of the set before
-# pruning.
-#
-# Use _m4_popdef for speed.  The existence of _m4_set_cleanup($1)
-# determines which version of _1 helper we use.
-m4_define([m4_set_contents],
-[m4_set_map_sep([$1], [], [], [[$2]])])
-
-# _m4_set_contents_1(SET)
-# _m4_set_contents_1c(SET)
-# _m4_set_contents_2(SET, [PRE], [POST], [SEP])
-# ---------------------------------------------
-# Expand to a list of quoted elements currently in the set, each
-# surrounded by PRE and POST, and moving SEP in front of PRE on
-# recursion.  To avoid nesting limit restrictions, the algorithm must
-# be broken into two parts; _1 destructively copies the stack in
-# reverse into _m4_set_($1), producing no output; then _2
-# destructively copies _m4_set_($1) back into the stack in reverse.
-# If no elements were deleted, then this visits the set in the order
-# that elements were inserted.  Behavior is undefined if PRE/POST/SEP
-# tries to recursively list or modify SET in any way other than
-# calling m4_set_remove on the current element.  Use _1 if all entries
-# in the stack are guaranteed to be in the set, and _1c to prune
-# removed entries.  Uses _m4_defn and _m4_popdef for speed.
-m4_define([_m4_set_contents_1],
-[_m4_stack_reverse([_m4_set([$1])], [_m4_set_($1)])])
-
-m4_define([_m4_set_contents_1c],
-[m4_ifdef([_m4_set([$1])],
-	  [m4_set_contains([$1], _m4_defn([_m4_set([$1])]),
-		   [m4_pushdef([_m4_set_($1)], _m4_defn([_m4_set([$1])]))],
-		   [_m4_popdef([_m4_set([$1],]_m4_defn(
-      [_m4_set([$1])])[)])])_m4_popdef([_m4_set([$1])])$0([$1])],
-	  [_m4_popdef([_m4_set_cleanup($1)])])])
-
-m4_define([_m4_set_contents_2],
-[_m4_stack_reverse([_m4_set_($1)], [_m4_set([$1])],
-  [$2[]_m4_defn([_m4_set_($1)])$3], [$4[]])])
-
-# m4_set_delete(SET)
-# ------------------
-# Delete all elements in SET, and reclaim any memory occupied by the
-# set.  This is O(n) in the set size.
-#
-# Use _m4_defn and _m4_popdef for speed.
-m4_define([m4_set_delete],
-[m4_ifdef([_m4_set([$1])],
-	  [_m4_popdef([_m4_set([$1],]_m4_defn([_m4_set([$1])])[)],
-		      [_m4_set([$1])])$0([$1])],
-	  [m4_ifdef([_m4_set_cleanup($1)],
-		    [_m4_popdef([_m4_set_cleanup($1)])])m4_ifdef(
-		    [_m4_set_size($1)],
-		    [_m4_popdef([_m4_set_size($1)])])])])
-
-# m4_set_difference(SET1, SET2)
-# -----------------------------
-# Produce a LIST of quoted elements that occur in SET1 but not SET2.
-# Output a comma prior to any elements, to distinguish the empty
-# string from no elements.  This can be directly used as a series of
-# arguments, such as for m4_join, or wrapped inside quotes for use in
-# m4_foreach.  Order of the output is not guaranteed.
-#
-# Short-circuit the idempotence relation.
-m4_define([m4_set_difference],
-[m4_if([$1], [$2], [], [m4_set_map_sep([$1], [_$0([$2],], [)])])])
-
-m4_define([_m4_set_difference],
-[m4_set_contains([$1], [$2], [], [,[$2]])])
-
-# m4_set_dump(SET, [SEP])
-# -----------------------
-# Expand to a single string containing all the elements in SET,
-# separated by SEP, then delete SET.  In general, if you only need to
-# list the contents once, this is faster than m4_set_contents.  No
-# provision is made for disambiguating set elements that contain
-# non-empty SEP as a sub-string.  Order of the output is not
-# guaranteed.  This is O(n) in the size of the set before pruning.
-#
-# Use _m4_popdef for speed.  Use existence of _m4_set_cleanup($1) to
-# decide if more expensive recursion is needed.
-m4_define([m4_set_dump],
-[m4_ifdef([_m4_set_size($1)],
-	  [_m4_popdef([_m4_set_size($1)])])m4_ifdef([_m4_set_cleanup($1)],
-    [_$0_check], [_$0])([$1], [], [$2])])
-
-# _m4_set_dump(SET, [SEP], [PREP])
-# _m4_set_dump_check(SET, [SEP], [PREP])
-# --------------------------------------
-# Print SEP and the current element, then delete the element and
-# recurse with empty SEP changed to PREP.  The check variant checks
-# whether the element has been previously removed.  Use _m4_defn and
-# _m4_popdef for speed.
-m4_define([_m4_set_dump],
-[m4_ifdef([_m4_set([$1])],
-	  [[$2]_m4_defn([_m4_set([$1])])_m4_popdef([_m4_set([$1],]_m4_defn(
-		[_m4_set([$1])])[)], [_m4_set([$1])])$0([$1], [$2$3])])])
-
-m4_define([_m4_set_dump_check],
-[m4_ifdef([_m4_set([$1])],
-	  [m4_set_contains([$1], _m4_defn([_m4_set([$1])]),
-			   [[$2]_m4_defn([_m4_set([$1])])])_m4_popdef(
-    [_m4_set([$1],]_m4_defn([_m4_set([$1])])[)],
-    [_m4_set([$1])])$0([$1], [$2$3])],
-	  [_m4_popdef([_m4_set_cleanup($1)])])])
-
-# m4_set_empty(SET, [IF-EMPTY], [IF-ELEMENTS])
-# --------------------------------------------
-# Expand IF-EMPTY if SET has no elements, otherwise IF-ELEMENTS.
-m4_define([m4_set_empty],
-[m4_ifdef([_m4_set_size($1)],
-	  [m4_if(m4_indir([_m4_set_size($1)]), [0], [$2], [$3])], [$2])])
-
-# m4_set_foreach(SET, VAR, ACTION)
-# --------------------------------
-# For each element of SET, define VAR to the element and expand
-# ACTION.  ACTION should not recursively list SET's contents, add
-# elements to SET, nor delete any element from SET except the one
-# currently in VAR.  The order that the elements are visited in is not
-# guaranteed.  This is faster than the corresponding m4_foreach([VAR],
-#   m4_indir([m4_dquote]m4_set_listc([SET])), [ACTION])
-m4_define([m4_set_foreach],
-[m4_pushdef([$2])m4_set_map_sep([$1],
-[m4_define([$2],], [)$3])m4_popdef([$2])])
-
-# m4_set_intersection(SET1, SET2)
-# -------------------------------
-# Produce a LIST of quoted elements that occur in both SET1 or SET2.
-# Output a comma prior to any elements, to distinguish the empty
-# string from no elements.  This can be directly used as a series of
-# arguments, such as for m4_join, or wrapped inside quotes for use in
-# m4_foreach.  Order of the output is not guaranteed.
-#
-# Iterate over the smaller set, and short-circuit the idempotence
-# relation.
-m4_define([m4_set_intersection],
-[m4_if([$1], [$2], [m4_set_listc([$1])],
-       m4_eval(m4_set_size([$2]) < m4_set_size([$1])), [1], [$0([$2], [$1])],
-       [m4_set_map_sep([$1], [_$0([$2],], [)])])])
-
-m4_define([_m4_set_intersection],
-[m4_set_contains([$1], [$2], [,[$2]])])
-
-# m4_set_list(SET)
-# m4_set_listc(SET)
-# -----------------
-# Produce a LIST of quoted elements of SET.  This can be directly used
-# as a series of arguments, such as for m4_join or m4_set_add_all, or
-# wrapped inside quotes for use in m4_foreach or m4_map.  With
-# m4_set_list, there is no way to distinguish an empty set from a set
-# containing only the empty string; with m4_set_listc, a leading comma
-# is output if there are any elements.
-m4_define([m4_set_list],
-[m4_set_map_sep([$1], [], [], [,])])
-
-m4_define([m4_set_listc],
-[m4_set_map_sep([$1], [,])])
-
-# m4_set_map(SET, ACTION)
-# -----------------------
-# For each element of SET, expand ACTION with a single argument of the
-# current element.  ACTION should not recursively list SET's contents,
-# add elements to SET, nor delete any element from SET except the one
-# passed as an argument.  The order that the elements are visited in
-# is not guaranteed.  This is faster than either of the corresponding
-#   m4_map_args([ACTION]m4_set_listc([SET]))
-#   m4_set_foreach([SET], [VAR], [ACTION(m4_defn([VAR]))])
-m4_define([m4_set_map],
-[m4_set_map_sep([$1], [$2(], [)])])
-
-# m4_set_map_sep(SET, [PRE], [POST], [SEP])
-# -----------------------------------------
-# For each element of SET, expand PRE[value]POST[], and expand SEP
-# between elements.
-m4_define([m4_set_map_sep],
-[m4_ifdef([_m4_set_cleanup($1)], [_m4_set_contents_1c],
-	  [_m4_set_contents_1])([$1])_m4_set_contents_2($@)])
-
-# m4_set_remove(SET, VALUE, [IF-PRESENT], [IF-ABSENT])
-# ----------------------------------------------------
-# If VALUE is an element of SET, delete it and expand IF-PRESENT.
-# Otherwise expand IF-ABSENT.  Deleting a single value is O(1),
-# although it leaves memory occupied until the next O(n) traversal of
-# the set which will compact the set.
-#
-# Optimize if the element being removed is the most recently added,
-# since defining _m4_set_cleanup($1) slows down so many other macros.
-# In particular, this plays well with m4_set_foreach and m4_set_map.
-m4_define([m4_set_remove],
-[m4_set_contains([$1], [$2], [_m4_set_size([$1],
-    [m4_decr])m4_if(_m4_defn([_m4_set([$1])]), [$2],
-		    [_m4_popdef([_m4_set([$1],$2)], [_m4_set([$1])])],
-		    [m4_define([_m4_set_cleanup($1)])m4_define(
-		      [_m4_set([$1],$2)], [0])])$3], [$4])])
-
-# m4_set_size(SET)
-# ----------------
-# Expand to the number of elements currently in SET.  This operation
-# is O(1), and thus more efficient than m4_count(m4_set_list([SET])).
-m4_define([m4_set_size],
-[m4_ifdef([_m4_set_size($1)], [m4_indir([_m4_set_size($1)])], [0])])
-
-# _m4_set_size(SET, ACTION)
-# -------------------------
-# ACTION must be either m4_incr or m4_decr, and the size of SET is
-# changed accordingly.  If the set is empty, ACTION must not be
-# m4_decr.
-m4_define([_m4_set_size],
-[m4_define([_m4_set_size($1)],
-	   m4_ifdef([_m4_set_size($1)], [$2(m4_indir([_m4_set_size($1)]))],
-		    [1]))])
-
-# m4_set_union(SET1, SET2)
-# ------------------------
-# Produce a LIST of double quoted elements that occur in either SET1
-# or SET2, without duplicates.  Output a comma prior to any elements,
-# to distinguish the empty string from no elements.  This can be
-# directly used as a series of arguments, such as for m4_join, or
-# wrapped inside quotes for use in m4_foreach.  Order of the output is
-# not guaranteed.
-#
-# We can rely on the fact that m4_set_listc prunes SET1, so we don't
-# need to check _m4_set([$1],element) for 0.  Short-circuit the
-# idempotence relation.
-m4_define([m4_set_union],
-[m4_set_listc([$1])m4_if([$1], [$2], [],
-  [m4_set_map_sep([$2], [_$0([$1],], [)])])])
-
-m4_define([_m4_set_union],
-[m4_ifdef([_m4_set([$1],$2)], [], [,[$2]])])
-
-
-## ------------------- ##
-## 16. File handling.  ##
-## ------------------- ##
-
-
-# It is a real pity that M4 comes with no macros to bind a diversion
-# to a file.  So we have to deal without, which makes us a lot more
-# fragile than we should.
-
-
-# m4_file_append(FILE-NAME, CONTENT)
-# ----------------------------------
-m4_define([m4_file_append],
-[m4_syscmd([cat >>$1 <<_m4eof
-$2
-_m4eof
-])
-m4_if(m4_sysval, [0], [],
-      [m4_fatal([$0: cannot write: $1])])])
-
-
-
-## ------------------------ ##
-## 17. Setting M4sugar up.  ##
-## ------------------------ ##
-
-# _m4_divert_diversion should be defined.
-m4_divert_push([KILL])
-
-# m4_init
-# -------
-# Initialize the m4sugar language.
-m4_define([m4_init],
-[# All the M4sugar macros start with `m4_', except `dnl' kept as is
-# for sake of simplicity.
-m4_pattern_forbid([^_?m4_])
-m4_pattern_forbid([^dnl$])
-
-# If __m4_version__ is defined, we assume that we are being run by M4
-# 1.6 or newer, thus $@ recursion is linear, and debugmode(+do)
-# is available for faster checks of dereferencing undefined macros
-# and forcing dumpdef to print to stderr regardless of debugfile.
-# But if it is missing, we assume we are being run by M4 1.4.x, that
-# $@ recursion is quadratic, and that we need foreach-based
-# replacement macros.  Also, m4 prior to 1.4.8 loses track of location
-# during m4wrap text; __line__ should never be 0.
-#
-# Use the raw builtin to avoid tripping up include tracing.
-# Meanwhile, avoid m4_copy, since it temporarily undefines m4_defn.
-m4_ifdef([__m4_version__],
-[m4_debugmode([+do])
-m4_define([m4_defn], _m4_defn([_m4_defn]))
-m4_define([m4_dumpdef], _m4_defn([_m4_dumpdef]))
-m4_define([m4_popdef], _m4_defn([_m4_popdef]))
-m4_define([m4_undefine], _m4_defn([_m4_undefine]))],
-[m4_builtin([include], [m4sugar/foreach.m4])
-m4_wrap_lifo([m4_if(__line__, [0], [m4_pushdef([m4_location],
-]]m4_dquote(m4_dquote(m4_dquote(__file__:__line__)))[[)])])])
-
-# Rewrite the first entry of the diversion stack.
-m4_divert([KILL])
-
-# Check the divert push/pop perfect balance.
-# Some users are prone to also use m4_wrap to register last-minute
-# m4_divert_text; so after our diversion cleanups, we restore
-# KILL as the bottom of the diversion stack.
-m4_wrap([m4_popdef([_m4_divert_diversion])m4_ifdef(
-  [_m4_divert_diversion], [m4_fatal([$0: unbalanced m4_divert_push:
-]m4_divert_stack)])_m4_popdef([_m4_divert_stack])m4_divert_push([KILL])])
-])
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/LICENSE b/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/LICENSE
deleted file mode 100644
index 94a9ed024d3..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/LICENSE
+++ /dev/null
@@ -1,674 +0,0 @@
-                    GNU GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The GNU General Public License is a free, copyleft license for
-software and other kinds of works.
-
-  The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works.  By contrast,
-the GNU General Public License is intended to guarantee your freedom to
-share and change all versions of a program--to make sure it remains free
-software for all its users.  We, the Free Software Foundation, use the
-GNU General Public License for most of our software; it applies also to
-any other work released this way by its authors.  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-  To protect your rights, we need to prevent others from denying you
-these rights or asking you to surrender the rights.  Therefore, you have
-certain responsibilities if you distribute copies of the software, or if
-you modify it: responsibilities to respect the freedom of others.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must pass on to the recipients the same
-freedoms that you received.  You must make sure that they, too, receive
-or can get the source code.  And you must show them these terms so they
-know their rights.
-
-  Developers that use the GNU GPL protect your rights with two steps:
-(1) assert copyright on the software, and (2) offer you this License
-giving you legal permission to copy, distribute and/or modify it.
-
-  For the developers' and authors' protection, the GPL clearly explains
-that there is no warranty for this free software.  For both users' and
-authors' sake, the GPL requires that modified versions be marked as
-changed, so that their problems will not be attributed erroneously to
-authors of previous versions.
-
-  Some devices are designed to deny users access to install or run
-modified versions of the software inside them, although the manufacturer
-can do so.  This is fundamentally incompatible with the aim of
-protecting users' freedom to change the software.  The systematic
-pattern of such abuse occurs in the area of products for individuals to
-use, which is precisely where it is most unacceptable.  Therefore, we
-have designed this version of the GPL to prohibit the practice for those
-products.  If such problems arise substantially in other domains, we
-stand ready to extend this provision to those domains in future versions
-of the GPL, as needed to protect the freedom of users.
-
-  Finally, every program is threatened constantly by software patents.
-States should not allow patents to restrict development and use of
-software on general-purpose computers, but in those that do, we wish to
-avoid the special danger that patents applied to a free program could
-make it effectively proprietary.  To prevent this, the GPL assures that
-patents cannot be used to render the program non-free.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                       TERMS AND CONDITIONS
-
-  0. Definitions.
-
-  "This License" refers to version 3 of the GNU General Public License.
-
-  "Copyright" also means copyright-like laws that apply to other kinds of
-works, such as semiconductor masks.
-
-  "The Program" refers to any copyrightable work licensed under this
-License.  Each licensee is addressed as "you".  "Licensees" and
-"recipients" may be individuals or organizations.
-
-  To "modify" a work means to copy from or adapt all or part of the work
-in a fashion requiring copyright permission, other than the making of an
-exact copy.  The resulting work is called a "modified version" of the
-earlier work or a work "based on" the earlier work.
-
-  A "covered work" means either the unmodified Program or a work based
-on the Program.
-
-  To "propagate" a work means to do anything with it that, without
-permission, would make you directly or secondarily liable for
-infringement under applicable copyright law, except executing it on a
-computer or modifying a private copy.  Propagation includes copying,
-distribution (with or without modification), making available to the
-public, and in some countries other activities as well.
-
-  To "convey" a work means any kind of propagation that enables other
-parties to make or receive copies.  Mere interaction with a user through
-a computer network, with no transfer of a copy, is not conveying.
-
-  An interactive user interface displays "Appropriate Legal Notices"
-to the extent that it includes a convenient and prominently visible
-feature that (1) displays an appropriate copyright notice, and (2)
-tells the user that there is no warranty for the work (except to the
-extent that warranties are provided), that licensees may convey the
-work under this License, and how to view a copy of this License.  If
-the interface presents a list of user commands or options, such as a
-menu, a prominent item in the list meets this criterion.
-
-  1. Source Code.
-
-  The "source code" for a work means the preferred form of the work
-for making modifications to it.  "Object code" means any non-source
-form of a work.
-
-  A "Standard Interface" means an interface that either is an official
-standard defined by a recognized standards body, or, in the case of
-interfaces specified for a particular programming language, one that
-is widely used among developers working in that language.
-
-  The "System Libraries" of an executable work include anything, other
-than the work as a whole, that (a) is included in the normal form of
-packaging a Major Component, but which is not part of that Major
-Component, and (b) serves only to enable use of the work with that
-Major Component, or to implement a Standard Interface for which an
-implementation is available to the public in source code form.  A
-"Major Component", in this context, means a major essential component
-(kernel, window system, and so on) of the specific operating system
-(if any) on which the executable work runs, or a compiler used to
-produce the work, or an object code interpreter used to run it.
-
-  The "Corresponding Source" for a work in object code form means all
-the source code needed to generate, install, and (for an executable
-work) run the object code and to modify the work, including scripts to
-control those activities.  However, it does not include the work's
-System Libraries, or general-purpose tools or generally available free
-programs which are used unmodified in performing those activities but
-which are not part of the work.  For example, Corresponding Source
-includes interface definition files associated with source files for
-the work, and the source code for shared libraries and dynamically
-linked subprograms that the work is specifically designed to require,
-such as by intimate data communication or control flow between those
-subprograms and other parts of the work.
-
-  The Corresponding Source need not include anything that users
-can regenerate automatically from other parts of the Corresponding
-Source.
-
-  The Corresponding Source for a work in source code form is that
-same work.
-
-  2. Basic Permissions.
-
-  All rights granted under this License are granted for the term of
-copyright on the Program, and are irrevocable provided the stated
-conditions are met.  This License explicitly affirms your unlimited
-permission to run the unmodified Program.  The output from running a
-covered work is covered by this License only if the output, given its
-content, constitutes a covered work.  This License acknowledges your
-rights of fair use or other equivalent, as provided by copyright law.
-
-  You may make, run and propagate covered works that you do not
-convey, without conditions so long as your license otherwise remains
-in force.  You may convey covered works to others for the sole purpose
-of having them make modifications exclusively for you, or provide you
-with facilities for running those works, provided that you comply with
-the terms of this License in conveying all material for which you do
-not control copyright.  Those thus making or running the covered works
-for you must do so exclusively on your behalf, under your direction
-and control, on terms that prohibit them from making any copies of
-your copyrighted material outside their relationship with you.
-
-  Conveying under any other circumstances is permitted solely under
-the conditions stated below.  Sublicensing is not allowed; section 10
-makes it unnecessary.
-
-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-
-  No covered work shall be deemed part of an effective technological
-measure under any applicable law fulfilling obligations under article
-11 of the WIPO copyright treaty adopted on 20 December 1996, or
-similar laws prohibiting or restricting circumvention of such
-measures.
-
-  When you convey a covered work, you waive any legal power to forbid
-circumvention of technological measures to the extent such circumvention
-is effected by exercising rights under this License with respect to
-the covered work, and you disclaim any intention to limit operation or
-modification of the work as a means of enforcing, against the work's
-users, your or third parties' legal rights to forbid circumvention of
-technological measures.
-
-  4. Conveying Verbatim Copies.
-
-  You may convey verbatim copies of the Program's source code as you
-receive it, in any medium, provided that you conspicuously and
-appropriately publish on each copy an appropriate copyright notice;
-keep intact all notices stating that this License and any
-non-permissive terms added in accord with section 7 apply to the code;
-keep intact all notices of the absence of any warranty; and give all
-recipients a copy of this License along with the Program.
-
-  You may charge any price or no price for each copy that you convey,
-and you may offer support or warranty protection for a fee.
-
-  5. Conveying Modified Source Versions.
-
-  You may convey a work based on the Program, or the modifications to
-produce it from the Program, in the form of source code under the
-terms of section 4, provided that you also meet all of these conditions:
-
-    a) The work must carry prominent notices stating that you modified
-    it, and giving a relevant date.
-
-    b) The work must carry prominent notices stating that it is
-    released under this License and any conditions added under section
-    7.  This requirement modifies the requirement in section 4 to
-    "keep intact all notices".
-
-    c) You must license the entire work, as a whole, under this
-    License to anyone who comes into possession of a copy.  This
-    License will therefore apply, along with any applicable section 7
-    additional terms, to the whole of the work, and all its parts,
-    regardless of how they are packaged.  This License gives no
-    permission to license the work in any other way, but it does not
-    invalidate such permission if you have separately received it.
-
-    d) If the work has interactive user interfaces, each must display
-    Appropriate Legal Notices; however, if the Program has interactive
-    interfaces that do not display Appropriate Legal Notices, your
-    work need not make them do so.
-
-  A compilation of a covered work with other separate and independent
-works, which are not by their nature extensions of the covered work,
-and which are not combined with it such as to form a larger program,
-in or on a volume of a storage or distribution medium, is called an
-"aggregate" if the compilation and its resulting copyright are not
-used to limit the access or legal rights of the compilation's users
-beyond what the individual works permit.  Inclusion of a covered work
-in an aggregate does not cause this License to apply to the other
-parts of the aggregate.
-
-  6. Conveying Non-Source Forms.
-
-  You may convey a covered work in object code form under the terms
-of sections 4 and 5, provided that you also convey the
-machine-readable Corresponding Source under the terms of this License,
-in one of these ways:
-
-    a) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by the
-    Corresponding Source fixed on a durable physical medium
-    customarily used for software interchange.
-
-    b) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by a
-    written offer, valid for at least three years and valid for as
-    long as you offer spare parts or customer support for that product
-    model, to give anyone who possesses the object code either (1) a
-    copy of the Corresponding Source for all the software in the
-    product that is covered by this License, on a durable physical
-    medium customarily used for software interchange, for a price no
-    more than your reasonable cost of physically performing this
-    conveying of source, or (2) access to copy the
-    Corresponding Source from a network server at no charge.
-
-    c) Convey individual copies of the object code with a copy of the
-    written offer to provide the Corresponding Source.  This
-    alternative is allowed only occasionally and noncommercially, and
-    only if you received the object code with such an offer, in accord
-    with subsection 6b.
-
-    d) Convey the object code by offering access from a designated
-    place (gratis or for a charge), and offer equivalent access to the
-    Corresponding Source in the same way through the same place at no
-    further charge.  You need not require recipients to copy the
-    Corresponding Source along with the object code.  If the place to
-    copy the object code is a network server, the Corresponding Source
-    may be on a different server (operated by you or a third party)
-    that supports equivalent copying facilities, provided you maintain
-    clear directions next to the object code saying where to find the
-    Corresponding Source.  Regardless of what server hosts the
-    Corresponding Source, you remain obligated to ensure that it is
-    available for as long as needed to satisfy these requirements.
-
-    e) Convey the object code using peer-to-peer transmission, provided
-    you inform other peers where the object code and Corresponding
-    Source of the work are being offered to the general public at no
-    charge under subsection 6d.
-
-  A separable portion of the object code, whose source code is excluded
-from the Corresponding Source as a System Library, need not be
-included in conveying the object code work.
-
-  A "User Product" is either (1) a "consumer product", which means any
-tangible personal property which is normally used for personal, family,
-or household purposes, or (2) anything designed or sold for incorporation
-into a dwelling.  In determining whether a product is a consumer product,
-doubtful cases shall be resolved in favor of coverage.  For a particular
-product received by a particular user, "normally used" refers to a
-typical or common use of that class of product, regardless of the status
-of the particular user or of the way in which the particular user
-actually uses, or expects or is expected to use, the product.  A product
-is a consumer product regardless of whether the product has substantial
-commercial, industrial or non-consumer uses, unless such uses represent
-the only significant mode of use of the product.
-
-  "Installation Information" for a User Product means any methods,
-procedures, authorization keys, or other information required to install
-and execute modified versions of a covered work in that User Product from
-a modified version of its Corresponding Source.  The information must
-suffice to ensure that the continued functioning of the modified object
-code is in no case prevented or interfered with solely because
-modification has been made.
-
-  If you convey an object code work under this section in, or with, or
-specifically for use in, a User Product, and the conveying occurs as
-part of a transaction in which the right of possession and use of the
-User Product is transferred to the recipient in perpetuity or for a
-fixed term (regardless of how the transaction is characterized), the
-Corresponding Source conveyed under this section must be accompanied
-by the Installation Information.  But this requirement does not apply
-if neither you nor any third party retains the ability to install
-modified object code on the User Product (for example, the work has
-been installed in ROM).
-
-  The requirement to provide Installation Information does not include a
-requirement to continue to provide support service, warranty, or updates
-for a work that has been modified or installed by the recipient, or for
-the User Product in which it has been modified or installed.  Access to a
-network may be denied when the modification itself materially and
-adversely affects the operation of the network or violates the rules and
-protocols for communication across the network.
-
-  Corresponding Source conveyed, and Installation Information provided,
-in accord with this section must be in a format that is publicly
-documented (and with an implementation available to the public in
-source code form), and must require no special password or key for
-unpacking, reading or copying.
-
-  7. Additional Terms.
-
-  "Additional permissions" are terms that supplement the terms of this
-License by making exceptions from one or more of its conditions.
-Additional permissions that are applicable to the entire Program shall
-be treated as though they were included in this License, to the extent
-that they are valid under applicable law.  If additional permissions
-apply only to part of the Program, that part may be used separately
-under those permissions, but the entire Program remains governed by
-this License without regard to the additional permissions.
-
-  When you convey a copy of a covered work, you may at your option
-remove any additional permissions from that copy, or from any part of
-it.  (Additional permissions may be written to require their own
-removal in certain cases when you modify the work.)  You may place
-additional permissions on material, added by you to a covered work,
-for which you have or can give appropriate copyright permission.
-
-  Notwithstanding any other provision of this License, for material you
-add to a covered work, you may (if authorized by the copyright holders of
-that material) supplement the terms of this License with terms:
-
-    a) Disclaiming warranty or limiting liability differently from the
-    terms of sections 15 and 16 of this License; or
-
-    b) Requiring preservation of specified reasonable legal notices or
-    author attributions in that material or in the Appropriate Legal
-    Notices displayed by works containing it; or
-
-    c) Prohibiting misrepresentation of the origin of that material, or
-    requiring that modified versions of such material be marked in
-    reasonable ways as different from the original version; or
-
-    d) Limiting the use for publicity purposes of names of licensors or
-    authors of the material; or
-
-    e) Declining to grant rights under trademark law for use of some
-    trade names, trademarks, or service marks; or
-
-    f) Requiring indemnification of licensors and authors of that
-    material by anyone who conveys the material (or modified versions of
-    it) with contractual assumptions of liability to the recipient, for
-    any liability that these contractual assumptions directly impose on
-    those licensors and authors.
-
-  All other non-permissive additional terms are considered "further
-restrictions" within the meaning of section 10.  If the Program as you
-received it, or any part of it, contains a notice stating that it is
-governed by this License along with a term that is a further
-restriction, you may remove that term.  If a license document contains
-a further restriction but permits relicensing or conveying under this
-License, you may add to a covered work material governed by the terms
-of that license document, provided that the further restriction does
-not survive such relicensing or conveying.
-
-  If you add terms to a covered work in accord with this section, you
-must place, in the relevant source files, a statement of the
-additional terms that apply to those files, or a notice indicating
-where to find the applicable terms.
-
-  Additional terms, permissive or non-permissive, may be stated in the
-form of a separately written license, or stated as exceptions;
-the above requirements apply either way.
-
-  8. Termination.
-
-  You may not propagate or modify a covered work except as expressly
-provided under this License.  Any attempt otherwise to propagate or
-modify it is void, and will automatically terminate your rights under
-this License (including any patent licenses granted under the third
-paragraph of section 11).
-
-  However, if you cease all violation of this License, then your
-license from a particular copyright holder is reinstated (a)
-provisionally, unless and until the copyright holder explicitly and
-finally terminates your license, and (b) permanently, if the copyright
-holder fails to notify you of the violation by some reasonable means
-prior to 60 days after the cessation.
-
-  Moreover, your license from a particular copyright holder is
-reinstated permanently if the copyright holder notifies you of the
-violation by some reasonable means, this is the first time you have
-received notice of violation of this License (for any work) from that
-copyright holder, and you cure the violation prior to 30 days after
-your receipt of the notice.
-
-  Termination of your rights under this section does not terminate the
-licenses of parties who have received copies or rights from you under
-this License.  If your rights have been terminated and not permanently
-reinstated, you do not qualify to receive new licenses for the same
-material under section 10.
-
-  9. Acceptance Not Required for Having Copies.
-
-  You are not required to accept this License in order to receive or
-run a copy of the Program.  Ancillary propagation of a covered work
-occurring solely as a consequence of using peer-to-peer transmission
-to receive a copy likewise does not require acceptance.  However,
-nothing other than this License grants you permission to propagate or
-modify any covered work.  These actions infringe copyright if you do
-not accept this License.  Therefore, by modifying or propagating a
-covered work, you indicate your acceptance of this License to do so.
-
-  10. Automatic Licensing of Downstream Recipients.
-
-  Each time you convey a covered work, the recipient automatically
-receives a license from the original licensors, to run, modify and
-propagate that work, subject to this License.  You are not responsible
-for enforcing compliance by third parties with this License.
-
-  An "entity transaction" is a transaction transferring control of an
-organization, or substantially all assets of one, or subdividing an
-organization, or merging organizations.  If propagation of a covered
-work results from an entity transaction, each party to that
-transaction who receives a copy of the work also receives whatever
-licenses to the work the party's predecessor in interest had or could
-give under the previous paragraph, plus a right to possession of the
-Corresponding Source of the work from the predecessor in interest, if
-the predecessor has it or can get it with reasonable efforts.
-
-  You may not impose any further restrictions on the exercise of the
-rights granted or affirmed under this License.  For example, you may
-not impose a license fee, royalty, or other charge for exercise of
-rights granted under this License, and you may not initiate litigation
-(including a cross-claim or counterclaim in a lawsuit) alleging that
-any patent claim is infringed by making, using, selling, offering for
-sale, or importing the Program or any portion of it.
-
-  11. Patents.
-
-  A "contributor" is a copyright holder who authorizes use under this
-License of the Program or a work on which the Program is based.  The
-work thus licensed is called the contributor's "contributor version".
-
-  A contributor's "essential patent claims" are all patent claims
-owned or controlled by the contributor, whether already acquired or
-hereafter acquired, that would be infringed by some manner, permitted
-by this License, of making, using, or selling its contributor version,
-but do not include claims that would be infringed only as a
-consequence of further modification of the contributor version.  For
-purposes of this definition, "control" includes the right to grant
-patent sublicenses in a manner consistent with the requirements of
-this License.
-
-  Each contributor grants you a non-exclusive, worldwide, royalty-free
-patent license under the contributor's essential patent claims, to
-make, use, sell, offer for sale, import and otherwise run, modify and
-propagate the contents of its contributor version.
-
-  In the following three paragraphs, a "patent license" is any express
-agreement or commitment, however denominated, not to enforce a patent
-(such as an express permission to practice a patent or covenant not to
-sue for patent infringement).  To "grant" such a patent license to a
-party means to make such an agreement or commitment not to enforce a
-patent against the party.
-
-  If you convey a covered work, knowingly relying on a patent license,
-and the Corresponding Source of the work is not available for anyone
-to copy, free of charge and under the terms of this License, through a
-publicly available network server or other readily accessible means,
-then you must either (1) cause the Corresponding Source to be so
-available, or (2) arrange to deprive yourself of the benefit of the
-patent license for this particular work, or (3) arrange, in a manner
-consistent with the requirements of this License, to extend the patent
-license to downstream recipients.  "Knowingly relying" means you have
-actual knowledge that, but for the patent license, your conveying the
-covered work in a country, or your recipient's use of the covered work
-in a country, would infringe one or more identifiable patents in that
-country that you have reason to believe are valid.
-
-  If, pursuant to or in connection with a single transaction or
-arrangement, you convey, or propagate by procuring conveyance of, a
-covered work, and grant a patent license to some of the parties
-receiving the covered work authorizing them to use, propagate, modify
-or convey a specific copy of the covered work, then the patent license
-you grant is automatically extended to all recipients of the covered
-work and works based on it.
-
-  A patent license is "discriminatory" if it does not include within
-the scope of its coverage, prohibits the exercise of, or is
-conditioned on the non-exercise of one or more of the rights that are
-specifically granted under this License.  You may not convey a covered
-work if you are a party to an arrangement with a third party that is
-in the business of distributing software, under which you make payment
-to the third party based on the extent of your activity of conveying
-the work, and under which the third party grants, to any of the
-parties who would receive the covered work from you, a discriminatory
-patent license (a) in connection with copies of the covered work
-conveyed by you (or copies made from those copies), or (b) primarily
-for and in connection with specific products or compilations that
-contain the covered work, unless you entered into that arrangement,
-or that patent license was granted, prior to 28 March 2007.
-
-  Nothing in this License shall be construed as excluding or limiting
-any implied license or other defenses to infringement that may
-otherwise be available to you under applicable patent law.
-
-  12. No Surrender of Others' Freedom.
-
-  If conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot convey a
-covered work so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you may
-not convey it at all.  For example, if you agree to terms that obligate you
-to collect a royalty for further conveying from those to whom you convey
-the Program, the only way you could satisfy both those terms and this
-License would be to refrain entirely from conveying the Program.
-
-  13. Use with the GNU Affero General Public License.
-
-  Notwithstanding any other provision of this License, you have
-permission to link or combine any covered work with a work licensed
-under version 3 of the GNU Affero General Public License into a single
-combined work, and to convey the resulting work.  The terms of this
-License will continue to apply to the part which is the covered work,
-but the special requirements of the GNU Affero General Public License,
-section 13, concerning interaction through a network will apply to the
-combination as such.
-
-  14. Revised Versions of this License.
-
-  The Free Software Foundation may publish revised and/or new versions of
-the GNU General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-  Each version is given a distinguishing version number.  If the
-Program specifies that a certain numbered version of the GNU General
-Public License "or any later version" applies to it, you have the
-option of following the terms and conditions either of that numbered
-version or of any later version published by the Free Software
-Foundation.  If the Program does not specify a version number of the
-GNU General Public License, you may choose any version ever published
-by the Free Software Foundation.
-
-  If the Program specifies that a proxy can decide which future
-versions of the GNU General Public License can be used, that proxy's
-public statement of acceptance of a version permanently authorizes you
-to choose that version for the Program.
-
-  Later license versions may give you additional or different
-permissions.  However, no additional obligations are imposed on any
-author or copyright holder as a result of your choosing to follow a
-later version.
-
-  15. Disclaimer of Warranty.
-
-  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
-OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
-IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. Limitation of Liability.
-
-  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
-THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
-GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
-USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
-DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
-EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGES.
-
-  17. Interpretation of Sections 15 and 16.
-
-  If the disclaimer of warranty and limitation of liability provided
-above cannot be given local legal effect according to their terms,
-reviewing courts shall apply local law that most closely approximates
-an absolute waiver of all civil liability in connection with the
-Program, unless a warranty or assumption of liability accompanies a
-copy of the Program in return for a fee.
-
-                     END OF TERMS AND CONDITIONS
-
-            How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-state the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-Also add information on how to contact you by electronic and paper mail.
-
-  If the program does terminal interaction, make it output a short
-notice like this when it starts in an interactive mode:
-
-    <program>  Copyright (C) <year>  <name of author>
-    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, your program's commands
-might be different; for a GUI interface, you would use an "about box".
-
-  You should also get your employer (if you work as a programmer) or school,
-if any, to sign a "copyright disclaimer" for the program, if necessary.
-For more information on this, and how to apply and follow the GNU GPL, see
-<http://www.gnu.org/licenses/>.
-
-  The GNU General Public License does not permit incorporating your program
-into proprietary programs.  If your program is a subroutine library, you
-may consider it more useful to permit linking proprietary applications with
-the library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.  But first, please read
-<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/README.chromium b/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/README.chromium
deleted file mode 100644
index 215d82e6366..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/README.chromium
+++ /dev/null
@@ -1,10 +0,0 @@
-Name: Bison skeletons
-URL: https://www.gnu.org/software/bison/
-Version: 3.3.2
-License: GPL
-License File: LICENSE
-Security critical: no
-
-Description:
-Bison is a parser generator. It uses skeleton files as templates for building
-similar languages.
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/bison.m4 b/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/bison.m4
deleted file mode 100644
index e3591875c0f..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/bison.m4
+++ /dev/null
@@ -1,1111 +0,0 @@
-                                                            -*- Autoconf -*-
-
-# Language-independent M4 Macros for Bison.
-
-# Copyright (C) 2002, 2004-2015, 2018-2019 Free Software Foundation,
-# Inc.
-
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-
-## ---------------- ##
-## Identification.  ##
-## ---------------- ##
-
-# b4_generated_by
-# ---------------
-m4_define([b4_generated_by],
-[b4_comment([A Bison parser, made by GNU Bison b4_version.])
-])
-
-# b4_copyright(TITLE, [YEARS])
-# ----------------------------
-# If YEARS are not defined, use b4_copyright_years.
-m4_define([b4_copyright],
-[b4_generated_by
-b4_comment([$1
-
-]m4_dquote(m4_text_wrap([Copyright (C)
-]m4_ifval([$2], [[$2]], [m4_defn([b4_copyright_years])])[
-Free Software Foundation, Inc.]))[
-
-This program is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program.  If not, see <http://www.gnu.org/licenses/>.])
-
-b4_comment([As a special exception, you may create a larger work that contains
-part or all of the Bison parser skeleton and distribute that work
-under terms of your choice, so long as that work isn't itself a
-parser generator using the skeleton or a modified version thereof
-as a parser skeleton.  Alternatively, if you modify or redistribute
-the parser skeleton itself, you may (at your option) remove this
-special exception, which will cause the skeleton and the resulting
-Bison output files to be licensed under the GNU General Public
-License without this special exception.
-
-This special exception was added by the Free Software Foundation in
-version 2.2 of Bison.])
-])
-
-
-# b4_disclaimer
-# -------------
-# Issue a warning about private implementation details.
-m4_define([b4_disclaimer],
-[b4_comment([Undocumented macros, especially those whose name start with YY_,
-are private implementation details.  Do not rely on them.])
-])
-
-
-
-# b4_required_version_if(VERSION, IF_NEWER, IF_OLDER)
-# ---------------------------------------------------
-# If the version %require'd by the user is VERSION (or newer) expand
-# IF_NEWER, otherwise IF_OLDER.  VERSION should be an integer, e.g.,
-# 302 for 3.2.
-m4_define([b4_required_version_if],
-[m4_if(m4_eval($1 <= b4_required_version),
-              [1], [$2], [$3])])
-
-
-## -------- ##
-## Output.  ##
-## -------- ##
-
-# b4_output_begin(FILE1, FILE2)
-# -----------------------------
-# Enable output, i.e., send to diversion 0, expand after "#", and
-# generate the tag to output into FILE.  Must be followed by EOL.
-# FILE is FILE1 concatenated to FILE2.  FILE2 can be empty, or be
-# absolute: do the right thing.
-m4_define([b4_output_begin],
-[m4_changecom()
-m4_divert_push(0)dnl
-@output(m4_unquote([$1])@,m4_unquote([$2])@)@dnl
-])
-
-
-# b4_output_end
-# -------------
-# Output nothing, restore # as comment character (no expansions after #).
-m4_define([b4_output_end],
-[m4_divert_pop(0)
-m4_changecom([#])
-])
-
-
-# b4_divert_kill(CODE)
-# --------------------
-# Expand CODE for its side effects, discard its output.
-m4_define([b4_divert_kill],
-[m4_divert_text([KILL], [$1])])
-
-
-# b4_define_silent(MACRO, CODE)
-# -----------------------------
-# Same as m4_define, but throw away the expansion of CODE.
-m4_define([b4_define_silent],
-[m4_define([$1], [b4_divert_kill([$2])])])
-
-
-## ---------------- ##
-## Error handling.  ##
-## ---------------- ##
-
-# The following error handling macros print error directives that should not
-# become arguments of other macro invocations since they would likely then be
-# mangled.  Thus, they print to stdout directly.
-
-# b4_cat(TEXT)
-# ------------
-# Write TEXT to stdout.  Precede the final newline with an @ so that it's
-# escaped.  For example:
-#
-#   b4_cat([[@complain(invalid input@)]])
-m4_define([b4_cat],
-[m4_syscmd([cat <<'_m4eof'
-]m4_bpatsubst(m4_dquote($1), [_m4eof], [_m4@`eof])[@
-_m4eof
-])dnl
-m4_if(m4_sysval, [0], [], [m4_fatal([$0: cannot write to stdout])])])
-
-# b4_error(KIND, START, END, FORMAT, [ARG1], [ARG2], ...)
-# -------------------------------------------------------
-# Write @KIND(START@,END@,FORMAT@,ARG1@,ARG2@,...@) to stdout.
-#
-# For example:
-#
-#   b4_error([[complain]], [[input.y:2.3]], [[input.y:5.4]],
-#            [[invalid %s]], [[foo]])
-m4_define([b4_error],
-[b4_cat([[@complain][(]$1[@,]$2[@,]$3[@,]$4[]]dnl
-[m4_if([$#], [4], [],
-       [m4_foreach([b4_arg],
-                   m4_dquote(m4_shift(m4_shift(m4_shift(m4_shift($@))))),
-                   [[@,]b4_arg])])[@)]])])
-
-# b4_warn(FORMAT, [ARG1], [ARG2], ...)
-# ------------------------------------
-# Write @warn(FORMAT@,ARG1@,ARG2@,...@) to stdout.
-#
-# For example:
-#
-#   b4_warn([[invalid value for '%s': %s]], [[foo]], [[3]])
-#
-# As a simple test suite, this:
-#
-#   m4_divert(-1)
-#   m4_define([asdf], [ASDF])
-#   m4_define([fsa], [FSA])
-#   m4_define([fdsa], [FDSA])
-#   b4_warn_at([[[asdf), asdf]]], [[[fsa), fsa]]], [[[fdsa), fdsa]]])
-#   b4_warn_at([[asdf), asdf]], [[fsa), fsa]], [[fdsa), fdsa]])
-#   b4_warn_at()
-#   b4_warn_at(1)
-#   b4_warn_at(1, 2)
-#
-# Should produce this without newlines:
-#
-#   @warn_at([asdf), asdf]@,@,@,[fsa), fsa]@,[fdsa), fdsa]@)
-#   @warn(asdf), asdf@,@,@,fsa), fsa@,fdsa), fdsa@)
-#   @warn(@)
-#   @warn(1@)
-#   @warn(1@,2@)
-m4_define([b4_warn],
-[b4_error([[warn]], [], [], $@)])
-
-# b4_warn_at(START, END, FORMAT, [ARG1], [ARG2], ...)
-# ---------------------------------------------------
-# Write @warn(START@,END@,FORMAT@,ARG1@,ARG2@,...@) to stdout.
-#
-# For example:
-#
-#   b4_warn_at([[input.y:2.3]], [[input.y:5.4]], [[invalid %s]], [[foo]])
-m4_define([b4_warn_at],
-[b4_error([[warn]], $@)])
-
-# b4_complain(FORMAT, [ARG1], [ARG2], ...)
-# ----------------------------------------
-# Bounce to b4_complain_at.
-#
-# See b4_warn example.
-m4_define([b4_complain],
-[b4_error([[complain]], [], [], $@)])
-
-# b4_complain_at(START, END, FORMAT, [ARG1], [ARG2], ...)
-# -------------------------------------------------------
-# Write @complain(START@,END@,FORMAT@,ARG1@,ARG2@,...@) to stdout.
-#
-# See b4_warn_at example.
-m4_define([b4_complain_at],
-[b4_error([[complain]], $@)])
-
-# b4_fatal(FORMAT, [ARG1], [ARG2], ...)
-# -------------------------------------
-# Bounce to b4_fatal_at.
-#
-# See b4_warn example.
-m4_define([b4_fatal],
-[b4_error([[fatal]], [], [], $@)dnl
-m4_exit(1)])
-
-# b4_fatal_at(START, END, FORMAT, [ARG1], [ARG2], ...)
-# ----------------------------------------------------
-# Write @fatal(START@,END@,FORMAT@,ARG1@,ARG2@,...@) to stdout and exit.
-#
-# See b4_warn_at example.
-m4_define([b4_fatal_at],
-[b4_error([[fatal]], $@)dnl
-m4_exit(1)])
-
-
-## ------------ ##
-## Data Types.  ##
-## ------------ ##
-
-# b4_ints_in(INT1, INT2, LOW, HIGH)
-# ---------------------------------
-# Return 1 iff both INT1 and INT2 are in [LOW, HIGH], 0 otherwise.
-m4_define([b4_ints_in],
-[m4_eval([$3 <= $1 && $1 <= $4 && $3 <= $2 && $2 <= $4])])
-
-
-# b4_subtract(LHS, RHS)
-# ---------------------
-# Evaluate LHS - RHS if they are integer literals, otherwise expand
-# to (LHS) - (RHS).
-m4_define([b4_subtract],
-[m4_bmatch([$1$2], [^[0123456789]*$],
-           [m4_eval([$1 - $2])],
-           [($1) - ($2)])])
-
-# b4_join(ARG1, ...)
-# _b4_join(ARG1, ...)
-# -------------------
-# Join with comma, skipping empty arguments.
-# b4_join calls itself recursively until it sees the first non-empty
-# argument, then calls _b4_join (i.e., `_$0`) which prepends each
-# non-empty argument with a comma.
-m4_define([b4_join],
-[m4_if([$#$1],
-       [1], [],
-       [m4_ifval([$1],
-                 [$1[]_$0(m4_shift($@))],
-                 [$0(m4_shift($@))])])])
-
-# _b4_join(ARGS1, ...)
-# --------------------
-m4_define([_b4_join],
-[m4_if([$#$1],
-       [1], [],
-       [m4_ifval([$1], [, $1])[]$0(m4_shift($@))])])
-
-
-
-
-# b4_integral_parser_tables_map(MACRO)
-# -------------------------------------
-# Map MACRO on all the integral tables.  MACRO is expected to have
-# the signature MACRO(TABLE-NAME, CONTENT, COMMENT).
-m4_define([b4_integral_parser_tables_map],
-[$1([pact], [b4_pact],
-    [[YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-STATE-NUM.]])
-
-$1([defact], [b4_defact],
-   [[YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
-Performed when YYTABLE does not specify something else to do.  Zero
-means the default is an error.]])
-
-$1([pgoto], [b4_pgoto], [[YYPGOTO[NTERM-NUM].]])
-
-$1([defgoto], [b4_defgoto], [[YYDEFGOTO[NTERM-NUM].]])
-
-$1([table], [b4_table],
-   [[YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
-positive, shift that token.  If negative, reduce the rule whose
-number is the opposite.  If YYTABLE_NINF, syntax error.]])
-
-$1([check], [b4_check])
-
-$1([stos], [b4_stos],
-   [[YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-symbol of state STATE-NUM.]])
-
-$1([r1], [b4_r1],
-   [[YYR1[YYN] -- Symbol number of symbol that rule YYN derives.]])
-
-$1([r2], [b4_r2],
-   [[YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.]])
-])
-
-
-# b4_parser_tables_declare
-# b4_parser_tables_define
-# ------------------------
-# Define/declare the (deterministic) parser tables.
-m4_define([b4_parser_tables_declare],
-[b4_integral_parser_tables_map([b4_integral_parser_table_declare])])
-
-m4_define([b4_parser_tables_define],
-[b4_integral_parser_tables_map([b4_integral_parser_table_define])])
-
-
-
-## ------------------ ##
-## Decoding options.  ##
-## ------------------ ##
-
-# b4_flag_if(FLAG, IF-TRUE, IF-FALSE)
-# -----------------------------------
-# Run IF-TRUE if b4_FLAG_flag is 1, IF-FALSE if FLAG is 0, otherwise fail.
-m4_define([b4_flag_if],
-[m4_case(b4_$1_flag,
-         [0], [$3],
-         [1], [$2],
-         [m4_fatal([invalid $1 value: ]b4_$1_flag)])])
-
-
-# b4_define_flag_if(FLAG)
-# -----------------------
-# Define "b4_FLAG_if(IF-TRUE, IF-FALSE)" that depends on the
-# value of the Boolean FLAG.
-m4_define([b4_define_flag_if],
-[_b4_define_flag_if($[1], $[2], [$1])])
-
-# _b4_define_flag_if($1, $2, FLAG)
-# --------------------------------
-# Work around the impossibility to define macros inside macros,
-# because issuing '[$1]' is not possible in M4.  GNU M4 should provide
-# $$1 a la M5/TeX.
-m4_define([_b4_define_flag_if],
-[m4_if([$1$2], $[1]$[2], [],
-       [m4_fatal([$0: Invalid arguments: $@])])dnl
-m4_define([b4_$3_if],
-          [b4_flag_if([$3], [$1], [$2])])])
-
-
-# b4_FLAG_if(IF-TRUE, IF-FALSE)
-# -----------------------------
-# Expand IF-TRUE, if FLAG is true, IF-FALSE otherwise.
-b4_define_flag_if([defines])            # Whether headers are requested.
-b4_define_flag_if([glr])                # Whether a GLR parser is requested.
-b4_define_flag_if([nondeterministic])   # Whether conflicts should be handled.
-b4_define_flag_if([token_table])        # Whether yytoken_table is demanded.
-b4_define_flag_if([yacc])               # Whether POSIX Yacc is emulated.
-
-
-# b4_glr_cc_if([IF-TRUE], [IF-FALSE])
-# -----------------------------------
-m4_define([b4_glr_cc_if],
-          [m4_if(b4_skeleton, ["glr.cc"], $@)])
-
-
-## --------- ##
-## Symbols.  ##
-## --------- ##
-
-# For a description of the Symbol handling, see README.
-#
-# The following macros provide access to symbol related values.
-
-# __b4_symbol(NUM, FIELD)
-# -----------------------
-# Recover a FIELD about symbol #NUM.  Thanks to m4_indir, fails if
-# undefined.
-m4_define([__b4_symbol],
-[m4_indir([b4_symbol($1, $2)])])
-
-
-# _b4_symbol(NUM, FIELD)
-# ----------------------
-# Recover a FIELD about symbol #NUM (or "orig NUM").  Fails if
-# undefined.
-m4_define([_b4_symbol],
-[m4_ifdef([b4_symbol($1, number)],
-          [__b4_symbol(m4_indir([b4_symbol($1, number)]), $2)],
-          [__b4_symbol([$1], [$2])])])
-
-
-
-# b4_symbol(NUM, FIELD)
-# ---------------------
-# Recover a FIELD about symbol #NUM (or "orig NUM").  Fails if
-# undefined.  If FIELD = id, prepend the token prefix.
-m4_define([b4_symbol],
-[m4_case([$2],
-         [id],    [m4_do([b4_percent_define_get([api.token.prefix])],
-                         [_b4_symbol([$1], [id])])],
-         [_b4_symbol($@)])])
-
-
-# b4_symbol_if(NUM, FIELD, IF-TRUE, IF-FALSE)
-# -------------------------------------------
-# If FIELD about symbol #NUM is 1 expand IF-TRUE, if is 0, expand IF-FALSE.
-# Otherwise an error.
-m4_define([b4_symbol_if],
-[m4_case(b4_symbol([$1], [$2]),
-         [1], [$3],
-         [0], [$4],
-         [m4_fatal([$0: field $2 of $1 is not a Boolean:] b4_symbol([$1], [$2]))])])
-
-
-# b4_symbol_tag_comment(SYMBOL-NUM)
-# ---------------------------------
-# Issue a comment giving the tag of symbol NUM.
-m4_define([b4_symbol_tag_comment],
-[b4_comment([b4_symbol([$1], [tag])])
-])
-
-
-# b4_symbol_action_location(SYMBOL-NUM, KIND)
-# -------------------------------------------
-# Report the location of the KIND action as FILE:LINE.
-m4_define([b4_symbol_action_location],
-[b4_symbol([$1], [$2_file]):b4_syncline([b4_symbol([$1], [$2_line])])])
-
-
-# b4_symbol_action(SYMBOL-NUM, KIND)
-# ----------------------------------
-# Run the action KIND (destructor or printer) for SYMBOL-NUM.
-m4_define([b4_symbol_action],
-[b4_symbol_if([$1], [has_$2],
-[b4_dollar_pushdef([(*yyvaluep)],
-                   [$1],
-                   [],
-                   [(*yylocationp)])dnl
-    _b4_symbol_case([$1])[]dnl
-b4_syncline([b4_symbol([$1], [$2_line])], [b4_symbol([$1], [$2_file])])
-      b4_symbol([$1], [$2])
-b4_syncline([@oline@], [@ofile@])
-        break;
-
-b4_dollar_popdef[]dnl
-])])
-
-
-# b4_symbol_destructor(SYMBOL-NUM)
-# b4_symbol_printer(SYMBOL-NUM)
-# --------------------------------
-m4_define([b4_symbol_destructor], [b4_symbol_action([$1], [destructor])])
-m4_define([b4_symbol_printer],    [b4_symbol_action([$1], [printer])])
-
-
-# b4_symbol_actions(KIND, [TYPE = yytype])
-# ----------------------------------------
-# Emit the symbol actions for KIND ("printer" or "destructor").
-# Dispatch on TYPE.
-m4_define([b4_symbol_actions],
-[m4_pushdef([b4_actions_], m4_expand([b4_symbol_foreach([b4_symbol_$1])]))dnl
-m4_ifval(m4_defn([b4_actions_]),
-[switch (m4_default([$2], [yytype]))
-    {
-m4_defn([b4_actions_])[]dnl
-      default:
-        break;
-    }dnl
-],
-[YYUSE (m4_default([$2], [yytype]));])dnl
-m4_popdef([b4_actions_])dnl
-])
-
-# _b4_symbol_case(SYMBOL-NUM)
-# ---------------------------
-# Issue a "case NUM" for SYMBOL-NUM.  Ends with its EOL to make it
-# easier to use with m4_map, but then, use []dnl to suppress the last
-# one.
-m4_define([_b4_symbol_case],
-[case b4_symbol([$1], [number]): b4_symbol_tag_comment([$1])])
-])
-
-
-# b4_symbol_foreach(MACRO)
-# ------------------------
-# Invoke MACRO(SYMBOL-NUM) for each SYMBOL-NUM.
-m4_define([b4_symbol_foreach],
-          [m4_map([$1], m4_defn([b4_symbol_numbers]))])
-
-# b4_symbol_map(MACRO)
-# --------------------
-# Return a list (possibly empty elements) of MACRO invoked for each
-# SYMBOL-NUM.
-m4_define([b4_symbol_map],
-[m4_map_args_sep([$1(], [)], [,], b4_symbol_numbers)])
-
-
-# b4_token_visible_if(NUM, IF-TRUE, IF-FALSE)
-# -------------------------------------------
-# Whether NUM denotes a token that has an exported definition (i.e.,
-# shows in enum yytokentype).
-m4_define([b4_token_visible_if],
-[b4_symbol_if([$1], [is_token],
-              [b4_symbol_if([$1], [has_id], [$2], [$3])],
-              [$3])])
-
-# b4_token_has_definition(NUM)
-# ----------------------------
-# 1 if NUM is visible, nothing otherwise.
-m4_define([b4_token_has_definition],
-[b4_token_visible_if([$1], [1])])
-
-# b4_any_token_visible_if([IF-TRUE], [IF-FALSE])
-# ----------------------------------------------
-# Whether there is a token that needs to be defined.
-m4_define([b4_any_token_visible_if],
-[m4_ifval(b4_symbol_foreach([b4_token_has_definition]),
-          [$1], [$2])])
-
-
-# b4_token_format(FORMAT, NUM)
-# ----------------------------
-m4_define([b4_token_format],
-[b4_token_visible_if([$2],
-[m4_quote(m4_format([$1],
-                     [b4_symbol([$2], [id])],
-                     [b4_symbol([$2], [user_number])]))])])
-
-
-## ------- ##
-## Types.  ##
-## ------- ##
-
-# _b4_type_action(NUMS)
-# ---------------------
-# Run actions for the symbol NUMS that all have the same type-name.
-# Skip NUMS that have no type-name.
-#
-# To specify the action to run, define b4_dollar_dollar(SYMBOL-NUM,
-# TAG, TYPE).
-m4_define([_b4_type_action],
-[b4_symbol_if([$1], [has_type],
-[m4_map([      _b4_symbol_case], [$@])[]dnl
-        b4_dollar_dollar([b4_symbol([$1], [number])],
-                         [b4_symbol([$1], [tag])],
-                         [b4_symbol([$1], [type])]);
-        break;
-
-])])
-
-# b4_type_foreach(MACRO)
-# ----------------------
-# Invoke MACRO(SYMBOL-NUMS) for each set of SYMBOL-NUMS for each type set.
-m4_define([b4_type_foreach],
-          [m4_map([$1], m4_defn([b4_type_names]))])
-
-
-
-## ----------- ##
-## Synclines.  ##
-## ----------- ##
-
-# b4_basename(NAME)
-# -----------------
-# Similar to POSIX basename; the differences don't matter here.
-# Beware that NAME is not evaluated.
-m4_define([b4_basename],
-[m4_bpatsubst([$1], [^.*/\([^/]+\)/*$], [\1])])
-
-
-# b4_syncline(LINE, FILE)
-# -----------------------
-m4_define([b4_syncline],
-[b4_flag_if([synclines],
-[b4_sync_start([$1], [$2]) b4_sync_end([__line__],
-                                       [b4_basename(m4_quote(__file__))])[]dnl
-])])
-
-# b4_sync_start(LINE, FILE)
-# -----------------------
-# Syncline for the new place.  Typically a directive for the compiler.
-m4_define([b4_sync_start], [b4_comment([$2:$1])])
-
-# b4_sync_end(LINE, FILE)
-# -----------------------
-# Syncline for the current place, which ends.  Typically a comment
-# left for the reader.
-m4_define([b4_sync_end],   [b4_comment([$2:$1])])
-
-
-# b4_user_code(USER-CODE)
-# -----------------------
-# Emit code from the user, ending it with synclines.
-m4_define([b4_user_code],
-[$1
-b4_syncline([@oline@], [@ofile@])])
-
-
-# b4_define_user_code(MACRO, COMMENT)
-# -----------------------------------
-# From b4_MACRO, if defined, build b4_user_MACRO that includes the synclines.
-m4_define([b4_define_user_code],
-[m4_define([b4_user_$1],
-           [m4_ifdef([b4_$1],
-                     [m4_ifval([$2],
-                               [b4_comment([$2])
-])b4_user_code([b4_$1])])])])
-
-# b4_user_actions
-# b4_user_initial_action
-# b4_user_post_prologue
-# b4_user_pre_prologue
-# b4_user_union_members
-# ----------------------
-# Macros that issue user code, ending with synclines.
-b4_define_user_code([actions])
-b4_define_user_code([initial_action], [User initialization code.])
-b4_define_user_code([post_prologue], [Second part of user prologue.])
-b4_define_user_code([pre_prologue], [First part of user prologue.])
-b4_define_user_code([union_members])
-
-
-# b4_check_user_names(WHAT, USER-LIST, BISON-NAMESPACE)
-# -----------------------------------------------------
-# Complain if any name of type WHAT is used by the user (as recorded in
-# USER-LIST) but is not used by Bison (as recorded by macros in the
-# namespace BISON-NAMESPACE).
-#
-# USER-LIST must expand to a list specifying all user occurrences of all names
-# of type WHAT.   Each item in the list must be a triplet specifying one
-# occurrence: name, start boundary, and end boundary.  Empty string names are
-# fine.  An empty list is fine.
-#
-# For example, to define b4_foo_user_names to be used for USER-LIST with three
-# name occurrences and with correct quoting:
-#
-#   m4_define([b4_foo_user_names],
-#             [[[[[[bar]], [[parser.y:1.7]], [[parser.y:1.16]]]],
-#               [[[[bar]], [[parser.y:5.7]], [[parser.y:5.16]]]],
-#               [[[[baz]], [[parser.y:8.7]], [[parser.y:8.16]]]]]])
-#
-# The macro BISON-NAMESPACE(bar) must be defined iff the name bar of type WHAT
-# is used by Bison (in the front-end or in the skeleton).  Empty string names
-# are fine, but it would be ugly for Bison to actually use one.
-#
-# For example, to use b4_foo_bison_names for BISON-NAMESPACE and define that
-# the names bar and baz are used by Bison:
-#
-#   m4_define([b4_foo_bison_names(bar)])
-#   m4_define([b4_foo_bison_names(baz)])
-#
-# To invoke b4_check_user_names with TYPE foo, with USER-LIST
-# b4_foo_user_names, with BISON-NAMESPACE b4_foo_bison_names, and with correct
-# quoting:
-#
-#   b4_check_user_names([[foo]], [b4_foo_user_names],
-#                       [[b4_foo_bison_names]])
-m4_define([b4_check_user_names],
-[m4_foreach([b4_occurrence], $2,
-[m4_pushdef([b4_occurrence], b4_occurrence)dnl
-m4_pushdef([b4_user_name], m4_car(b4_occurrence))dnl
-m4_pushdef([b4_start], m4_car(m4_shift(b4_occurrence)))dnl
-m4_pushdef([b4_end], m4_shift(m4_shift(b4_occurrence)))dnl
-m4_ifndef($3[(]m4_quote(b4_user_name)[)],
-          [b4_complain_at([b4_start], [b4_end],
-                          [[%s '%s' is not used]],
-                          [$1], [b4_user_name])])[]dnl
-m4_popdef([b4_occurrence])dnl
-m4_popdef([b4_user_name])dnl
-m4_popdef([b4_start])dnl
-m4_popdef([b4_end])dnl
-])])
-
-
-
-## --------------------- ##
-## b4_percent_define_*.  ##
-## --------------------- ##
-
-
-# b4_percent_define_use(VARIABLE)
-# -------------------------------
-# Declare that VARIABLE was used.
-m4_define([b4_percent_define_use],
-[m4_define([b4_percent_define_bison_variables(]$1[)])dnl
-])
-
-# b4_percent_define_get(VARIABLE, [DEFAULT])
-# ------------------------------------------
-# Mimic muscle_percent_define_get in ../src/muscle-tab.h.  That is, if
-# the %define variable VARIABLE is defined, emit its value.  Contrary
-# to its C counterpart, return DEFAULT otherwise.  Also, record
-# Bison's usage of VARIABLE by defining
-# b4_percent_define_bison_variables(VARIABLE).
-#
-# For example:
-#
-#   b4_percent_define_get([[foo]])
-m4_define([b4_percent_define_get],
-[b4_percent_define_use([$1])dnl
-_b4_percent_define_ifdef([$1],
-                         [m4_indir([b4_percent_define(]$1[)])],
-                         [$2])])
-
-# b4_percent_define_get_loc(VARIABLE)
-# -----------------------------------
-# Mimic muscle_percent_define_get_loc in ../src/muscle-tab.h exactly.  That is,
-# if the %define variable VARIABLE is undefined, complain fatally since that's
-# a Bison or skeleton error.  Otherwise, return its definition location in a
-# form appropriate for the first two arguments of b4_warn_at, b4_complain_at, or
-# b4_fatal_at.  Don't record this as a Bison usage of VARIABLE as there's no
-# reason to suspect that the user-supplied value has yet influenced the output.
-#
-# For example:
-#
-#   b4_complain_at(b4_percent_define_get_loc([[foo]]), [[invalid foo]])
-m4_define([b4_percent_define_get_loc],
-[m4_ifdef([b4_percent_define_loc(]$1[)],
-          [m4_pushdef([b4_loc], m4_indir([b4_percent_define_loc(]$1[)]))dnl
-b4_loc[]dnl
-m4_popdef([b4_loc])],
-          [b4_fatal([[$0: undefined %%define variable '%s']], [$1])])])
-
-# b4_percent_define_get_kind(VARIABLE)
-# ------------------------------------
-# Get the kind (code, keyword, string) of VARIABLE, i.e., how its
-# value was defined (braces, not delimiters, quotes).
-#
-# If the %define variable VARIABLE is undefined, complain fatally
-# since that's a Bison or skeleton error.  Don't record this as a
-# Bison usage of VARIABLE as there's no reason to suspect that the
-# user-supplied value has yet influenced the output.
-m4_define([b4_percent_define_get_kind],
-[m4_ifdef([b4_percent_define_kind(]$1[)],
-          [m4_indir([b4_percent_define_kind(]$1[)])],
-          [b4_fatal([[$0: undefined %%define variable '%s']], [$1])])])
-
-# b4_percent_define_get_syncline(VARIABLE)
-# ----------------------------------------
-# Mimic muscle_percent_define_get_syncline in ../src/muscle-tab.h exactly.
-# That is, if the %define variable VARIABLE is undefined, complain fatally
-# since that's a Bison or skeleton error.  Otherwise, return its definition
-# location as a b4_syncline invocation.  Don't record this as a Bison usage of
-# VARIABLE as there's no reason to suspect that the user-supplied value has yet
-# influenced the output.
-#
-# For example:
-#
-#   b4_percent_define_get_syncline([[foo]])
-m4_define([b4_percent_define_get_syncline],
-[m4_ifdef([b4_percent_define_syncline(]$1[)],
-          [m4_indir([b4_percent_define_syncline(]$1[)])],
-          [b4_fatal([[$0: undefined %%define variable '%s']], [$1])])])
-
-# _b4_percent_define_ifdef(VARIABLE, IF-TRUE, [IF-FALSE])
-# ------------------------------------------------------
-# If the %define variable VARIABLE is defined, expand IF-TRUE, else expand
-# IF-FALSE.  Don't record usage of VARIABLE.
-#
-# For example:
-#
-#   _b4_percent_define_ifdef([[foo]], [[it's defined]], [[it's undefined]])
-m4_define([_b4_percent_define_ifdef],
-[m4_ifdef([b4_percent_define(]$1[)],
-          [$2],
-          [$3])])
-
-# b4_percent_define_ifdef(VARIABLE, IF-TRUE, [IF-FALSE])
-# ------------------------------------------------------
-# Mimic muscle_percent_define_ifdef in ../src/muscle-tab.h exactly.  That is,
-# if the %define variable VARIABLE is defined, expand IF-TRUE, else expand
-# IF-FALSE.  Also, record Bison's usage of VARIABLE by defining
-# b4_percent_define_bison_variables(VARIABLE).
-#
-# For example:
-#
-#   b4_percent_define_ifdef([[foo]], [[it's defined]], [[it's undefined]])
-m4_define([b4_percent_define_ifdef],
-[_b4_percent_define_ifdef([$1],
-                         [b4_percent_define_use([$1])$2],
-                         [$3])])
-
-
-# b4_percent_define_check_file_complain(VARIABLE)
-# -----------------------------------------------
-# Warn about %define variable VARIABLE having an incorrect
-# value.
-m4_define([b4_percent_define_check_file_complain],
-[b4_complain_at(b4_percent_define_get_loc([$1]),
-                [[%%define variable '%s' requires 'none' or '"..."' values]],
-                [$1])])
-
-
-# b4_percent_define_check_file(MACRO, VARIABLE, DEFAULT)
-# ------------------------------------------------------
-# If the %define variable VARIABLE:
-# - is undefined, then if DEFAULT is non-empty, define MACRO to DEFAULT
-# - is a string, define MACRO to its value
-# - is the keyword 'none', do nothing
-# - otherwise, warn about the incorrect value.
-m4_define([b4_percent_define_check_file],
-[b4_percent_define_ifdef([$2],
-  [m4_case(b4_percent_define_get_kind([$2]),
-    [string],
-         [m4_define([$1], b4_percent_define_get([$2]))],
-    [keyword],
-         [m4_if(b4_percent_define_get([$2]), [none], [],
-                [b4_percent_define_check_file_complain([$2])])],
-    [b4_percent_define_check_file_complain([$2])])
-   ],
-   [m4_ifval([$3],
-             [m4_define([$1], [$3])])])
-])
-
-
-
-## --------- ##
-## Options.  ##
-## --------- ##
-
-
-# b4_percent_define_flag_if(VARIABLE, IF-TRUE, [IF-FALSE])
-# --------------------------------------------------------
-# Mimic muscle_percent_define_flag_if in ../src/muscle-tab.h exactly.  That is,
-# if the %define variable VARIABLE is defined to "" or "true", expand IF-TRUE.
-# If it is defined to "false", expand IF-FALSE.  Complain if it is undefined
-# (a Bison or skeleton error since the default value should have been set
-# already) or defined to any other value (possibly a user error).  Also, record
-# Bison's usage of VARIABLE by defining
-# b4_percent_define_bison_variables(VARIABLE).
-#
-# For example:
-#
-#   b4_percent_define_flag_if([[foo]], [[it's true]], [[it's false]])
-m4_define([b4_percent_define_flag_if],
-[b4_percent_define_ifdef([$1],
-  [m4_case(b4_percent_define_get([$1]),
-           [], [$2], [true], [$2], [false], [$3],
-           [m4_expand_once([b4_complain_at(b4_percent_define_get_loc([$1]),
-                                           [[invalid value for %%define Boolean variable '%s']],
-                                           [$1])],
-                           [[b4_percent_define_flag_if($1)]])])],
-  [b4_fatal([[$0: undefined %%define variable '%s']], [$1])])])
-
-
-# b4_percent_define_default(VARIABLE, DEFAULT, [KIND = keyword])
-# --------------------------------------------------------------
-# Mimic muscle_percent_define_default in ../src/muscle-tab.h exactly.  That is,
-# if the %define variable VARIABLE is undefined, set its value to DEFAULT.
-# Don't record this as a Bison usage of VARIABLE as there's no reason to
-# suspect that the value has yet influenced the output.
-#
-# For example:
-#
-#   b4_percent_define_default([[foo]], [[default value]])
-m4_define([b4_percent_define_default],
-[_b4_percent_define_ifdef([$1], [],
-           [m4_define([b4_percent_define(]$1[)], [$2])dnl
-            m4_define([b4_percent_define_kind(]$1[)],
-                      [m4_default([$3], [keyword])])dnl
-            m4_define([b4_percent_define_loc(]$1[)],
-                      [[[[<skeleton default value>:-1.-1]],
-                        [[<skeleton default value>:-1.-1]]]])dnl
-            m4_define([b4_percent_define_syncline(]$1[)], [[]])])])
-
-
-# b4_percent_define_if_define(NAME, [VARIABLE = NAME])
-# ----------------------------------------------------
-# Define b4_NAME_if that executes its $1 or $2 depending whether
-# VARIABLE was %defined.  The characters '.' and `-' in VARIABLE are mapped
-# to '_'.
-m4_define([_b4_percent_define_if_define],
-[m4_define(m4_bpatsubst([b4_$1_if], [[-.]], [_]),
-           [b4_percent_define_flag_if(m4_default([$2], [$1]),
-                                      [$3], [$4])])])
-m4_define([b4_percent_define_if_define],
-[b4_percent_define_default([m4_default([$2], [$1])], [[false]])
-_b4_percent_define_if_define([$1], [$2], $[1], $[2])])
-
-
-# b4_percent_define_check_kind(VARIABLE, KIND, [DIAGNOSTIC = complain])
-# ---------------------------------------------------------------------
-m4_define([b4_percent_define_check_kind],
-[_b4_percent_define_ifdef([$1],
-  [m4_if(b4_percent_define_get_kind([$1]), [$2], [],
-    [b4_error([m4_default([$3], [complain])],
-              b4_percent_define_get_loc([$1]),
-              [m4_case([$2],
-                 [code],    [[%%define variable '%s' requires '{...}' values]],
-                 [keyword], [[%%define variable '%s' requires keyword values]],
-                 [string],  [[%%define variable '%s' requires '"..."' values]])],
-              [$1])])])dnl
-])
-
-
-# b4_percent_define_check_values(VALUES)
-# --------------------------------------
-# Mimic muscle_percent_define_check_values in ../src/muscle-tab.h exactly
-# except that the VALUES structure is more appropriate for M4.  That is, VALUES
-# is a list of sublists of strings.  For each sublist, the first string is the
-# name of a %define variable, and all remaining strings in that sublist are the
-# valid values for that variable.  Complain if such a variable is undefined (a
-# Bison error since the default value should have been set already) or defined
-# to any other value (possibly a user error).  Don't record this as a Bison
-# usage of the variable as there's no reason to suspect that the value has yet
-# influenced the output.
-#
-# For example:
-#
-#   b4_percent_define_check_values([[[[foo]], [[foo-value1]], [[foo-value2]]]],
-#                                  [[[[bar]], [[bar-value1]]]])
-m4_define([b4_percent_define_check_values],
-[m4_foreach([b4_sublist], m4_quote($@),
-            [_b4_percent_define_check_values(b4_sublist)])])
-
-m4_define([_b4_percent_define_check_values],
-[_b4_percent_define_ifdef([$1],
-  [b4_percent_define_check_kind(]$1[, [keyword], [deprecated])dnl
-   m4_pushdef([b4_good_value], [0])dnl
-   m4_if($#, 1, [],
-         [m4_foreach([b4_value], m4_dquote(m4_shift($@)),
-                     [m4_if(m4_indir([b4_percent_define(]$1[)]), b4_value,
-                            [m4_define([b4_good_value], [1])])])])dnl
-   m4_if(b4_good_value, [0],
-         [b4_complain_at(b4_percent_define_get_loc([$1]),
-                         [[invalid value for %%define variable '%s': '%s']],
-                         [$1],
-                         m4_dquote(m4_indir([b4_percent_define(]$1[)])))
-          m4_foreach([b4_value], m4_dquote(m4_shift($@)),
-                     [b4_error([[note]], b4_percent_define_get_loc([$1]), []
-                                     [[accepted value: '%s']],
-                                     m4_dquote(b4_value))])])dnl
-   m4_popdef([b4_good_value])],
-  [b4_fatal([[$0: undefined %%define variable '%s']], [$1])])])
-
-# b4_percent_code_get([QUALIFIER])
-# --------------------------------
-# If any %code blocks for QUALIFIER are defined, emit them beginning with a
-# comment and ending with synclines and a newline.  If QUALIFIER is not
-# specified or empty, do this for the unqualified %code blocks.  Also, record
-# Bison's usage of QUALIFIER (if specified) by defining
-# b4_percent_code_bison_qualifiers(QUALIFIER).
-#
-# For example, to emit any unqualified %code blocks followed by any %code
-# blocks for the qualifier foo:
-#
-#   b4_percent_code_get
-#   b4_percent_code_get([[foo]])
-m4_define([b4_percent_code_get],
-[m4_pushdef([b4_macro_name], [[b4_percent_code(]$1[)]])dnl
-m4_ifval([$1], [m4_define([b4_percent_code_bison_qualifiers(]$1[)])])dnl
-m4_ifdef(b4_macro_name,
-[b4_comment([m4_if([$#], [0], [[Unqualified %code]],
-                   [["%code ]$1["]])[ blocks.]])
-b4_user_code([m4_indir(b4_macro_name)])
-])dnl
-m4_popdef([b4_macro_name])])
-
-# b4_percent_code_ifdef(QUALIFIER, IF-TRUE, [IF-FALSE])
-# -----------------------------------------------------
-# If any %code blocks for QUALIFIER (or unqualified %code blocks if
-# QUALIFIER is empty) are defined, expand IF-TRUE, else expand IF-FALSE.
-# Also, record Bison's usage of QUALIFIER (if specified) by defining
-# b4_percent_code_bison_qualifiers(QUALIFIER).
-m4_define([b4_percent_code_ifdef],
-[m4_ifdef([b4_percent_code(]$1[)],
-          [m4_ifval([$1], [m4_define([b4_percent_code_bison_qualifiers(]$1[)])])$2],
-          [$3])])
-
-
-## ------------------ ##
-## Common variables.  ##
-## ------------------ ##
-
-
-# b4_parse_assert_if([IF-ASSERTIONS-ARE-USED], [IF-NOT])
-# b4_parse_trace_if([IF-DEBUG-TRACES-ARE-ENABLED], [IF-NOT])
-# b4_token_ctor_if([IF-YYLEX-RETURNS-A-TOKEN], [IF-NOT])
-# ----------------------------------------------------------
-b4_percent_define_if_define([token_ctor], [api.token.constructor])
-b4_percent_define_if_define([locations])     # Whether locations are tracked.
-b4_percent_define_if_define([parse.assert])
-b4_percent_define_if_define([parse.trace])
-
-
-# b4_bison_locations_if([IF-TRUE])
-# --------------------------------
-# Expand IF-TRUE if using locations, and using the default location
-# type.
-m4_define([b4_bison_locations_if],
-[b4_locations_if([b4_percent_define_ifdef([[api.location.type]], [], [$1])])])
-
-
-# b4_error_verbose_if([IF-ERRORS-ARE-VERBOSE], [IF-NOT])
-# ------------------------------------------------------
-# Map %define parse.error "(simple|verbose)" to b4_error_verbose_if and
-# b4_error_verbose_flag.
-b4_percent_define_default([[parse.error]], [[simple]])
-b4_percent_define_check_values([[[[parse.error]],
-                                 [[simple]], [[verbose]]]])
-m4_define([b4_error_verbose_flag],
-          [m4_case(b4_percent_define_get([[parse.error]]),
-                   [simple],  [[0]],
-                   [verbose], [[1]])])
-b4_define_flag_if([error_verbose])
-
-# yytoken_table is needed to support verbose errors.
-b4_error_verbose_if([m4_define([b4_token_table_flag], [1])])
-
-
-# b4_variant_if([IF-VARIANT-ARE-USED], [IF-NOT])
-# ----------------------------------------------
-b4_percent_define_if_define([variant])
-m4_define([b4_variant_flag], [[0]])
-b4_percent_define_ifdef([[api.value.type]],
-   [m4_case(b4_percent_define_get_kind([[api.value.type]]), [keyword],
-            [m4_case(b4_percent_define_get([[api.value.type]]), [variant],
-                    [m4_define([b4_variant_flag], [[1]])])])])
-b4_define_flag_if([variant])
-
-
-## ----------------------------------------------------------- ##
-## After processing the skeletons, check that all the user's   ##
-## %define variables and %code qualifiers were used by Bison.  ##
-## ----------------------------------------------------------- ##
-
-m4_define([b4_check_user_names_wrap],
-[m4_ifdef([b4_percent_]$1[_user_]$2[s],
-          [b4_check_user_names([[%]$1 $2],
-                               [b4_percent_]$1[_user_]$2[s],
-                               [[b4_percent_]$1[_bison_]$2[s]])])])
-
-m4_wrap_lifo([
-b4_check_user_names_wrap([[define]], [[variable]])
-b4_check_user_names_wrap([[code]], [[qualifier]])
-])
-
-
-## ---------------- ##
-## Default values.  ##
-## ---------------- ##
-
-# m4_define_default([b4_lex_param], [])   dnl breaks other skeletons
-m4_define_default([b4_epilogue], [])
-m4_define_default([b4_parse_param], [])
-
-# The initial column and line.
-m4_define_default([b4_location_initial_column], [1])
-m4_define_default([b4_location_initial_line],   [1])
-
-
-## --------------- ##
-## Sanity checks.  ##
-## --------------- ##
-
-# api.location.prefix={...} (Java and C++).
-b4_percent_define_check_kind([api.location.type], [code], [deprecated])
-
-# api.position.prefix={...} (Java).
-b4_percent_define_check_kind([api.position.type], [code], [deprecated])
-
-# api.prefix >< %name-prefix.
-b4_percent_define_check_kind([api.prefix], [code], [deprecated])
-b4_percent_define_ifdef([api.prefix],
-[m4_ifdef([b4_prefix],
-[b4_complain_at(b4_percent_define_get_loc([api.prefix]),
-                [['%s' and '%s' cannot be used together]],
-                [%name-prefix],
-                [%define api.prefix])])])
-
-# api.token.prefix={...}
-# Make it a warning for those who used betas of Bison 3.0.
-b4_percent_define_check_kind([api.token.prefix], [code], [deprecated])
-
-# api.value.type >< %union.
-b4_percent_define_ifdef([api.value.type],
-[m4_ifdef([b4_union_members],
-[b4_complain_at(b4_percent_define_get_loc([api.value.type]),
-                [['%s' and '%s' cannot be used together]],
-                [%union],
-                [%define api.value.type])])])
-
-# api.value.type=union >< %yacc.
-b4_percent_define_ifdef([api.value.type],
-[m4_if(b4_percent_define_get([api.value.type]), [union],
-[b4_yacc_if(dnl
-[b4_complain_at(b4_percent_define_get_loc([api.value.type]),
-                [['%s' and '%s' cannot be used together]],
-                [%yacc],
-                [%define api.value.type "union"])])])])
-
-# api.value.union.name.
-b4_percent_define_check_kind([api.value.union.name], [keyword])
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/c-like.m4 b/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/c-like.m4
deleted file mode 100644
index 8d891b67ef9..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/c-like.m4
+++ /dev/null
@@ -1,66 +0,0 @@
-                                                            -*- Autoconf -*-
-
-# Common code for C-like languages (C, C++, Java, etc.)
-
-# Copyright (C) 2012-2015, 2018-2019 Free Software Foundation, Inc.
-
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-# _b4_comment(TEXT, OPEN, CONTINUE, END)
-# --------------------------------------
-# Put TEXT in comment.  Avoid trailing spaces: don't indent empty lines.
-# Avoid adding indentation to the first line, as the indentation comes
-# from OPEN.  That's why we don't patsubst([$1], [^\(.\)], [   \1]).
-#
-# Prefix all the output lines with PREFIX.
-m4_define([_b4_comment],
-[$2[]m4_bpatsubst(m4_expand([[$1]]), [
-\(.\)], [
-$3\1])$4])
-
-
-# b4_comment(TEXT, [PREFIX])
-# --------------------------
-# Put TEXT in comment.  Prefix all the output lines with PREFIX.
-m4_define([b4_comment],
-[_b4_comment([$1], [$2/* ], [$2   ], [  */])])
-
-
-
-
-# _b4_dollar_dollar(VALUE, SYMBOL-NUM, FIELD, DEFAULT-FIELD)
-# ----------------------------------------------------------
-# If FIELD (or DEFAULT-FIELD) is non-null, return "VALUE.FIELD",
-# otherwise just VALUE.  Be sure to pass "(VALUE)" if VALUE is a
-# pointer.
-m4_define([_b4_dollar_dollar],
-[b4_symbol_value([$1],
-                 [$2],
-                 m4_if([$3], [[]],
-                       [[$4]], [[$3]]))])
-
-# b4_dollar_pushdef(VALUE-POINTER, SYMBOL-NUM, [TYPE_TAG], LOCATION)
-# b4_dollar_popdef
-# ------------------------------------------------------------------
-# Define b4_dollar_dollar for VALUE-POINTER and DEFAULT-FIELD,
-# and b4_at_dollar for LOCATION.
-m4_define([b4_dollar_pushdef],
-[m4_pushdef([b4_dollar_dollar],
-            [_b4_dollar_dollar([$1], [$2], m4_dquote($][1), [$3])])dnl
-m4_pushdef([b4_at_dollar], [$4])dnl
-])
-m4_define([b4_dollar_popdef],
-[m4_popdef([b4_at_dollar])dnl
-m4_popdef([b4_dollar_dollar])dnl
-])
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/c.m4 b/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/c.m4
deleted file mode 100644
index 3cde04a9571..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/c.m4
+++ /dev/null
@@ -1,883 +0,0 @@
-                                                            -*- Autoconf -*-
-
-# C M4 Macros for Bison.
-
-# Copyright (C) 2002, 2004-2015, 2018-2019 Free Software Foundation,
-# Inc.
-
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-m4_include(b4_skeletonsdir/[c-like.m4])
-
-# b4_tocpp(STRING)
-# ----------------
-# Convert STRING into a valid C macro name.
-m4_define([b4_tocpp],
-[m4_toupper(m4_bpatsubst(m4_quote($1), [[^a-zA-Z0-9]+], [_]))])
-
-
-# b4_cpp_guard(FILE)
-# ------------------
-# A valid C macro name to use as a CPP header guard for FILE.
-m4_define([b4_cpp_guard],
-[[YY_]b4_tocpp(m4_defn([b4_prefix])/[$1])[_INCLUDED]])
-
-
-# b4_cpp_guard_open(FILE)
-# b4_cpp_guard_close(FILE)
-# ------------------------
-# If FILE does not expand to nothing, open/close CPP inclusion guards for FILE.
-m4_define([b4_cpp_guard_open],
-[m4_ifval(m4_quote($1),
-[#ifndef b4_cpp_guard([$1])
-# define b4_cpp_guard([$1])])])
-
-m4_define([b4_cpp_guard_close],
-[m4_ifval(m4_quote($1),
-[#endif b4_comment([!b4_cpp_guard([$1])])])])
-
-
-## ---------------- ##
-## Identification.  ##
-## ---------------- ##
-
-# b4_identification
-# -----------------
-# Depends on individual skeletons to define b4_pure_flag, b4_push_flag, or
-# b4_pull_flag if they use the values of the %define variables api.pure or
-# api.push-pull.
-m4_define([b4_identification],
-[[/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Bison version.  */
-#define YYBISON_VERSION "]b4_version["
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME ]b4_skeleton[]m4_ifdef([b4_pure_flag], [[
-
-/* Pure parsers.  */
-#define YYPURE ]b4_pure_flag])[]m4_ifdef([b4_push_flag], [[
-
-/* Push parsers.  */
-#define YYPUSH ]b4_push_flag])[]m4_ifdef([b4_pull_flag], [[
-
-/* Pull parsers.  */
-#define YYPULL ]b4_pull_flag])[
-]])
-
-
-## ---------------- ##
-## Default values.  ##
-## ---------------- ##
-
-# b4_api_prefix, b4_api_PREFIX
-# ----------------------------
-# Corresponds to %define api.prefix
-b4_percent_define_default([[api.prefix]], [[yy]])
-m4_define([b4_api_prefix],
-[b4_percent_define_get([[api.prefix]])])
-m4_define([b4_api_PREFIX],
-[m4_toupper(b4_api_prefix)])
-
-
-# b4_prefix
-# ---------
-# If the %name-prefix is not given, it is api.prefix.
-m4_define_default([b4_prefix], [b4_api_prefix])
-
-# If the %union is not named, its name is YYSTYPE.
-b4_percent_define_default([[api.value.union.name]],
-                          [b4_api_PREFIX[][STYPE]])
-
-
-## ------------------------ ##
-## Pure/impure interfaces.  ##
-## ------------------------ ##
-
-# b4_lex_formals
-# --------------
-# All the yylex formal arguments.
-# b4_lex_param arrives quoted twice, but we want to keep only one level.
-m4_define([b4_lex_formals],
-[b4_pure_if([[[[YYSTYPE *yylvalp]], [[&yylval]]][]dnl
-b4_locations_if([, [[YYLTYPE *yyllocp], [&yylloc]]])])dnl
-m4_ifdef([b4_lex_param], [, ]b4_lex_param)])
-
-
-# b4_lex
-# ------
-# Call yylex.
-m4_define([b4_lex],
-[b4_function_call([yylex], [int], b4_lex_formals)])
-
-
-# b4_user_args
-# ------------
-m4_define([b4_user_args],
-[m4_ifset([b4_parse_param], [, b4_args(b4_parse_param)])])
-
-
-# b4_parse_param
-# --------------
-# If defined, b4_parse_param arrives double quoted, but below we prefer
-# it to be single quoted.
-m4_define([b4_parse_param],
-b4_parse_param)
-
-
-# b4_parse_param_for(DECL, FORMAL, BODY)
-# ---------------------------------------
-# Iterate over the user parameters, binding the declaration to DECL,
-# the formal name to FORMAL, and evaluating the BODY.
-m4_define([b4_parse_param_for],
-[m4_foreach([$1_$2], m4_defn([b4_parse_param]),
-[m4_pushdef([$1], m4_unquote(m4_car($1_$2)))dnl
-m4_pushdef([$2], m4_shift($1_$2))dnl
-$3[]dnl
-m4_popdef([$2])dnl
-m4_popdef([$1])dnl
-])])
-
-# b4_parse_param_use([VAL], [LOC])
-# --------------------------------
-# 'YYUSE' VAL, LOC if locations are enabled, and all the parse-params.
-m4_define([b4_parse_param_use],
-[m4_ifvaln([$1], [  YYUSE ([$1]);])dnl
-b4_locations_if([m4_ifvaln([$2], [  YYUSE ([$2]);])])dnl
-b4_parse_param_for([Decl], [Formal], [  YYUSE (Formal);
-])dnl
-])
-
-
-## ------------ ##
-## Data Types.  ##
-## ------------ ##
-
-# b4_int_type(MIN, MAX)
-# ---------------------
-# Return the smallest int type able to handle numbers ranging from
-# MIN to MAX (included).
-m4_define([b4_int_type],
-[m4_if(b4_ints_in($@,      [0],   [255]), [1], [unsigned char],
-       b4_ints_in($@,   [-128],   [127]), [1], [signed char],
-
-       b4_ints_in($@,      [0], [65535]), [1], [unsigned short],
-       b4_ints_in($@, [-32768], [32767]), [1], [short],
-
-       m4_eval([0 <= $1]),                [1], [unsigned],
-
-                                               [int])])
-
-
-# b4_int_type_for(NAME)
-# ---------------------
-# Return the smallest int type able to handle numbers ranging from
-# 'NAME_min' to 'NAME_max' (included).
-m4_define([b4_int_type_for],
-[b4_int_type($1_min, $1_max)])
-
-
-# b4_table_value_equals(TABLE, VALUE, LITERAL)
-# --------------------------------------------
-# Without inducing a comparison warning from the compiler, check if the
-# literal value LITERAL equals VALUE from table TABLE, which must have
-# TABLE_min and TABLE_max defined.
-m4_define([b4_table_value_equals],
-[m4_if(m4_eval($3 < m4_indir([b4_]$1[_min])
-               || m4_indir([b4_]$1[_max]) < $3), [1],
-       [[0]],
-       [(!!(($2) == ($3)))])])
-
-
-## ----------------- ##
-## Compiler issues.  ##
-## ----------------- ##
-
-# b4_attribute_define([noreturn])
-# -------------------------------
-# Provide portable compiler "attributes".  If "noreturn" is passed, define
-# _Noreturn.
-m4_define([b4_attribute_define],
-[[#ifndef YY_ATTRIBUTE
-# if (defined __GNUC__                                               \
-      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
-     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
-#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
-# else
-#  define YY_ATTRIBUTE(Spec) /* empty */
-# endif
-#endif
-
-#ifndef YY_ATTRIBUTE_PURE
-# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
-#endif
-
-#ifndef YY_ATTRIBUTE_UNUSED
-# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
-#endif
-
-]m4_bmatch([$1], [\bnoreturn\b], [[/* The _Noreturn keyword of C11.  */
-#if ! defined _Noreturn
-# if defined __cplusplus && 201103L <= __cplusplus
-#  define _Noreturn [[noreturn]]
-# elif !(defined __STDC_VERSION__ && 201112 <= __STDC_VERSION__)
-#  if (3 <= __GNUC__ || (__GNUC__ == 2 && 8 <= __GNUC_MINOR__) \
-       || 0x5110 <= __SUNPRO_C)
-#   define _Noreturn __attribute__ ((__noreturn__))
-#  elif defined _MSC_VER && 1200 <= _MSC_VER
-#   define _Noreturn __declspec (noreturn)
-#  else
-#   define _Noreturn
-#  endif
-# endif
-#endif
-
-]])[/* Suppress unused-variable warnings by "using" E.  */
-#if ! defined lint || defined __GNUC__
-# define YYUSE(E) ((void) (E))
-#else
-# define YYUSE(E) /* empty */
-#endif
-
-#if defined __GNUC__ && ! defined __ICC && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
-/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
-# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
-    _Pragma ("GCC diagnostic push") \
-    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
-    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
-# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
-    _Pragma ("GCC diagnostic pop")
-#else
-# define YY_INITIAL_VALUE(Value) Value
-#endif
-#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-# define YY_IGNORE_MAYBE_UNINITIALIZED_END
-#endif
-#ifndef YY_INITIAL_VALUE
-# define YY_INITIAL_VALUE(Value) /* Nothing. */
-#endif
-]])
-
-
-# b4_null_define
-# --------------
-# Portability issues: define a YY_NULLPTR appropriate for the current
-# language (C, C++98, or C++11).
-#
-# In C++ pre C++11 it is standard practice to use 0 (not NULL) for the
-# null pointer.  In C, prefer ((void*)0) to avoid having to include stdlib.h.
-m4_define([b4_null_define],
-[# ifndef YY_NULLPTR
-#  if defined __cplusplus
-#   if 201103L <= __cplusplus
-#    define YY_NULLPTR nullptr
-#   else
-#    define YY_NULLPTR 0
-#   endif
-#  else
-#   define YY_NULLPTR ((void*)0)
-#  endif
-# endif[]dnl
-])
-
-
-# b4_null
-# -------
-# Return a null pointer constant.
-m4_define([b4_null], [YY_NULLPTR])
-
-
-
-## ---------##
-## Values.  ##
-## ---------##
-
-# b4_integral_parser_table_define(TABLE-NAME, CONTENT, COMMENT)
-# -------------------------------------------------------------
-# Define "yy<TABLE-NAME>" whose contents is CONTENT.
-m4_define([b4_integral_parser_table_define],
-[m4_ifvaln([$3], [b4_comment([$3], [  ])])dnl
-static const b4_int_type_for([$2]) yy$1[[]] =
-{
-  $2
-};dnl
-])
-
-
-## ------------------------- ##
-## Assigning token numbers.  ##
-## ------------------------- ##
-
-# b4_token_define(TOKEN-NUM)
-# --------------------------
-# Output the definition of this token as #define.
-m4_define([b4_token_define],
-[b4_token_format([#define %s %s], [$1])])
-
-# b4_token_defines
-# ----------------
-# Output the definition of the tokens.
-m4_define([b4_token_defines],
-[b4_any_token_visible_if([/* Tokens.  */
-m4_join([
-], b4_symbol_map([b4_token_define]))
-])])
-
-
-# b4_token_enum(TOKEN-NUM)
-# ------------------------
-# Output the definition of this token as an enum.
-m4_define([b4_token_enum],
-[b4_token_format([%s = %s], [$1])])
-
-
-# b4_token_enums
-# --------------
-# Output the definition of the tokens (if there are) as enums.
-m4_define([b4_token_enums],
-[b4_any_token_visible_if([[/* Token type.  */
-#ifndef ]b4_api_PREFIX[TOKENTYPE
-# define ]b4_api_PREFIX[TOKENTYPE
-  enum ]b4_api_prefix[tokentype
-  {
-    ]m4_join([,
-    ],
-             b4_symbol_map([b4_token_enum]))[
-  };
-#endif
-]])])
-
-
-# b4_token_enums_defines
-# ----------------------
-# Output the definition of the tokens (if there are any) as enums and,
-# if POSIX Yacc is enabled, as #defines.
-m4_define([b4_token_enums_defines],
-[b4_token_enums[]b4_yacc_if([b4_token_defines])])
-
-
-## ----------------- ##
-## Semantic Values.  ##
-## ----------------- ##
-
-
-# b4_symbol_value(VAL, [SYMBOL-NUM], [TYPE-TAG])
-# ----------------------------------------------
-# See README.
-m4_define([b4_symbol_value],
-[m4_ifval([$3],
-          [($1.$3)],
-          [m4_ifval([$2],
-                    [b4_symbol_if([$2], [has_type],
-                                  [($1.b4_symbol([$2], [type]))],
-                                  [$1])],
-                    [$1])])])
-
-
-## ---------------------- ##
-## Defining C functions.  ##
-## ---------------------- ##
-
-
-# b4_function_define(NAME, RETURN-VALUE, [DECL1, NAME1], ...)
-# -----------------------------------------------------------
-# Declare the function NAME in C.
-m4_define([b4_function_define],
-[$2
-$1 (b4_formals(m4_shift2($@)))[]dnl
-])
-
-
-# b4_formals([DECL1, NAME1], ...)
-# -------------------------------
-# The formal arguments of a C function definition.
-m4_define([b4_formals],
-[m4_if([$#], [0], [void],
-       [$#$1], [1], [void],
-               [m4_map_sep([b4_formal], [, ], [$@])])])
-
-m4_define([b4_formal],
-[$1])
-
-
-
-## ----------------------- ##
-## Declaring C functions.  ##
-## ----------------------- ##
-
-
-# b4_function_declare(NAME, RETURN-VALUE, [DECL1, NAME1], ...)
-# ------------------------------------------------------------
-# Declare the function NAME.
-m4_define([b4_function_declare],
-[$2 $1 (b4_formals(m4_shift2($@)));[]dnl
-])
-
-
-
-
-## --------------------- ##
-## Calling C functions.  ##
-## --------------------- ##
-
-
-# b4_function_call(NAME, RETURN-VALUE, [DECL1, NAME1], ...)
-# -----------------------------------------------------------
-# Call the function NAME with arguments NAME1, NAME2 etc.
-m4_define([b4_function_call],
-[$1 (b4_args(m4_shift2($@)))[]dnl
-])
-
-
-# b4_args([DECL1, NAME1], ...)
-# ----------------------------
-# Output the arguments NAME1, NAME2...
-m4_define([b4_args],
-[m4_map_sep([b4_arg], [, ], [$@])])
-
-m4_define([b4_arg],
-[$2])
-
-
-## ----------- ##
-## Synclines.  ##
-## ----------- ##
-
-# b4_sync_start(LINE, FILE)
-# -------------------------
-m4_define([b4_sync_start], [[#]line $1 $2])
-
-
-## -------------- ##
-## User actions.  ##
-## -------------- ##
-
-# b4_case(LABEL, STATEMENTS)
-# --------------------------
-m4_define([b4_case],
-[  case $1:
-$2
-b4_syncline([@oline@], [@ofile@])
-    break;])
-
-
-# b4_predicate_case(LABEL, CONDITIONS)
-# ------------------------------------
-m4_define([b4_predicate_case],
-[  case $1:
-    if (! (
-$2)) YYERROR;
-b4_syncline([@oline@], [@ofile@])
-    break;])
-
-
-# b4_yydestruct_define
-# --------------------
-# Define the "yydestruct" function.
-m4_define_default([b4_yydestruct_define],
-[[/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-]b4_function_define([yydestruct],
-    [static void],
-    [[const char *yymsg],    [yymsg]],
-    [[int yytype],           [yytype]],
-    [[YYSTYPE *yyvaluep],    [yyvaluep]][]dnl
-b4_locations_if(            [, [[YYLTYPE *yylocationp], [yylocationp]]])[]dnl
-m4_ifset([b4_parse_param], [, b4_parse_param]))[
-{
-]b4_parse_param_use([yyvaluep], [yylocationp])dnl
-[  if (!yymsg)
-    yymsg = "Deleting";
-  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
-
-  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  ]b4_symbol_actions([destructor])[
-  YY_IGNORE_MAYBE_UNINITIALIZED_END
-}]dnl
-])
-
-
-# b4_yy_symbol_print_define
-# -------------------------
-# Define the "yy_symbol_print" function.
-m4_define_default([b4_yy_symbol_print_define],
-[[
-/*-----------------------------------.
-| Print this symbol's value on YYO.  |
-`-----------------------------------*/
-
-]b4_function_define([yy_symbol_value_print],
-    [static void],
-               [[FILE *yyo],                            [yyo]],
-               [[int yytype],                           [yytype]],
-               [[YYSTYPE const * const yyvaluep],       [yyvaluep]][]dnl
-b4_locations_if([, [[YYLTYPE const * const yylocationp], [yylocationp]]])[]dnl
-m4_ifset([b4_parse_param], [, b4_parse_param]))[
-{
-  FILE *yyoutput = yyo;
-]b4_parse_param_use([yyoutput], [yylocationp])dnl
-[  if (!yyvaluep)
-    return;]
-dnl glr.c does not feature yytoknum.
-m4_if(b4_skeleton, ["yacc.c"],
-[[# ifdef YYPRINT
-  if (yytype < YYNTOKENS)
-    YYPRINT (yyo, yytoknum[yytype], *yyvaluep);
-# endif
-]])dnl
-  b4_symbol_actions([printer])[
-}
-
-
-/*---------------------------.
-| Print this symbol on YYO.  |
-`---------------------------*/
-
-]b4_function_define([yy_symbol_print],
-    [static void],
-               [[FILE *yyo],                            [yyo]],
-               [[int yytype],                           [yytype]],
-               [[YYSTYPE const * const yyvaluep],       [yyvaluep]][]dnl
-b4_locations_if([, [[YYLTYPE const * const yylocationp], [yylocationp]]])[]dnl
-m4_ifset([b4_parse_param], [, b4_parse_param]))[
-{
-  YYFPRINTF (yyo, "%s %s (",
-             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
-
-]b4_locations_if([  YY_LOCATION_PRINT (yyo, *yylocationp);
-  YYFPRINTF (yyo, ": ");
-])dnl
-[  yy_symbol_value_print (yyo, yytype, yyvaluep]dnl
-b4_locations_if([, yylocationp])[]b4_user_args[);
-  YYFPRINTF (yyo, ")");
-}]dnl
-])
-
-
-## ---------------- ##
-## api.value.type.  ##
-## ---------------- ##
-
-
-# ---------------------- #
-# api.value.type=union.  #
-# ---------------------- #
-
-# b4_symbol_type_register(SYMBOL-NUM)
-# -----------------------------------
-# Symbol SYMBOL-NUM has a type (for variant) instead of a type-tag.
-# Extend the definition of %union's body (b4_union_members) with a
-# field of that type, and extend the symbol's "type" field to point to
-# the field name, instead of the type name.
-m4_define([b4_symbol_type_register],
-[m4_define([b4_symbol($1, type_tag)],
-           [b4_symbol_if([$1], [has_id],
-                         [b4_symbol([$1], [id])],
-                         [yytype_[]b4_symbol([$1], [number])])])dnl
-m4_append([b4_union_members],
-m4_expand([
-  b4_symbol_tag_comment([$1])dnl
-  b4_symbol([$1], [type]) b4_symbol([$1], [type_tag]);]))
-])
-
-
-# b4_type_define_tag(SYMBOL1-NUM, ...)
-# ------------------------------------
-# For the batch of symbols SYMBOL1-NUM... (which all have the same
-# type), enhance the %union definition for each of them, and set
-# there "type" field to the field tag name, instead of the type name.
-m4_define([b4_type_define_tag],
-[b4_symbol_if([$1], [has_type],
-              [m4_map([b4_symbol_type_register], [$@])])
-])
-
-
-# b4_symbol_value_union(VAL, SYMBOL-NUM, [TYPE])
-# ----------------------------------------------
-# Same of b4_symbol_value, but when api.value.type=union.
-m4_define([b4_symbol_value_union],
-[m4_ifval([$3],
-          [(*($3*)(&$1))],
-          [m4_ifval([$2],
-                    [b4_symbol_if([$2], [has_type],
-                                  [($1.b4_symbol([$2], [type_tag]))],
-                                  [$1])],
-                    [$1])])])
-
-
-# b4_value_type_setup_union
-# -------------------------
-# Setup support for api.value.type=union.  Symbols are defined with a
-# type instead of a union member name: build the corresponding union,
-# and give the symbols their tag.
-m4_define([b4_value_type_setup_union],
-[m4_define([b4_union_members])
-b4_type_foreach([b4_type_define_tag])
-m4_copy_force([b4_symbol_value_union], [b4_symbol_value])
-])
-
-
-# -------------------------- #
-# api.value.type = variant.  #
-# -------------------------- #
-
-# b4_value_type_setup_variant
-# ---------------------------
-# Setup support for api.value.type=variant.  By default, fail, specialized
-# by other skeletons.
-m4_define([b4_value_type_setup_variant],
-[b4_complain_at(b4_percent_define_get_loc([[api.value.type]]),
-                [['%s' does not support '%s']],
-                [b4_skeleton],
-                [%define api.value.type variant])])
-
-
-# _b4_value_type_setup_keyword
-# ----------------------------
-# api.value.type is defined with a keyword/string syntax.  Check if
-# that is properly defined, and prepare its use.
-m4_define([_b4_value_type_setup_keyword],
-[b4_percent_define_check_values([[[[api.value.type]],
-                                  [[none]],
-                                  [[union]],
-                                  [[union-directive]],
-                                  [[variant]],
-                                  [[yystype]]]])dnl
-m4_case(b4_percent_define_get([[api.value.type]]),
-        [union],   [b4_value_type_setup_union],
-        [variant], [b4_value_type_setup_variant])])
-
-
-# b4_value_type_setup
-# -------------------
-# Check if api.value.type is properly defined, and possibly prepare
-# its use.
-b4_define_silent([b4_value_type_setup],
-[# Define default value.
-b4_percent_define_ifdef([[api.value.type]], [],
-[# %union => api.value.type=union-directive
-m4_ifdef([b4_union_members],
-[m4_define([b4_percent_define_kind(api.value.type)], [keyword])
-m4_define([b4_percent_define(api.value.type)], [union-directive])],
-[# no tag seen => api.value.type={int}
-m4_if(b4_tag_seen_flag, 0,
-[m4_define([b4_percent_define_kind(api.value.type)], [code])
-m4_define([b4_percent_define(api.value.type)], [int])],
-[# otherwise api.value.type=yystype
-m4_define([b4_percent_define_kind(api.value.type)], [keyword])
-m4_define([b4_percent_define(api.value.type)], [yystype])])])])
-
-# Set up.
-m4_bmatch(b4_percent_define_get_kind([[api.value.type]]),
-   [keyword\|string], [_b4_value_type_setup_keyword])
-])
-
-
-## -------------- ##
-## Declarations.  ##
-## -------------- ##
-
-
-# b4_value_type_define
-# --------------------
-m4_define([b4_value_type_define],
-[b4_value_type_setup[]dnl
-/* Value type.  */
-m4_bmatch(b4_percent_define_get_kind([[api.value.type]]),
-[code],
-[[#if ! defined ]b4_api_PREFIX[STYPE && ! defined ]b4_api_PREFIX[STYPE_IS_DECLARED
-typedef ]b4_percent_define_get([[api.value.type]])[ ]b4_api_PREFIX[STYPE;
-# define ]b4_api_PREFIX[STYPE_IS_TRIVIAL 1
-# define ]b4_api_PREFIX[STYPE_IS_DECLARED 1
-#endif
-]],
-[m4_bmatch(b4_percent_define_get([[api.value.type]]),
-[union\|union-directive],
-[[#if ! defined ]b4_api_PREFIX[STYPE && ! defined ]b4_api_PREFIX[STYPE_IS_DECLARED
-]b4_percent_define_get_syncline([[api.value.union.name]])[
-union ]b4_percent_define_get([[api.value.union.name]])[
-{
-]b4_user_union_members[
-};
-]b4_percent_define_get_syncline([[api.value.union.name]])[
-typedef union ]b4_percent_define_get([[api.value.union.name]])[ ]b4_api_PREFIX[STYPE;
-# define ]b4_api_PREFIX[STYPE_IS_TRIVIAL 1
-# define ]b4_api_PREFIX[STYPE_IS_DECLARED 1
-#endif
-]])])])
-
-
-# b4_location_type_define
-# -----------------------
-m4_define([b4_location_type_define],
-[[/* Location type.  */
-#if ! defined ]b4_api_PREFIX[LTYPE && ! defined ]b4_api_PREFIX[LTYPE_IS_DECLARED
-typedef struct ]b4_api_PREFIX[LTYPE ]b4_api_PREFIX[LTYPE;
-struct ]b4_api_PREFIX[LTYPE
-{
-  int first_line;
-  int first_column;
-  int last_line;
-  int last_column;
-};
-# define ]b4_api_PREFIX[LTYPE_IS_DECLARED 1
-# define ]b4_api_PREFIX[LTYPE_IS_TRIVIAL 1
-#endif
-]])
-
-
-# b4_declare_yylstype
-# -------------------
-# Declarations that might either go into the header (if --defines) or
-# in the parser body.  Declare YYSTYPE/YYLTYPE, and yylval/yylloc.
-m4_define([b4_declare_yylstype],
-[b4_value_type_define[]b4_locations_if([
-b4_location_type_define])
-
-b4_pure_if([], [[extern ]b4_api_PREFIX[STYPE ]b4_prefix[lval;
-]b4_locations_if([[extern ]b4_api_PREFIX[LTYPE ]b4_prefix[lloc;]])])[]dnl
-])
-
-
-# b4_YYDEBUG_define
-# -----------------
-m4_define([b4_YYDEBUG_define],
-[[/* Debug traces.  */
-]m4_if(b4_api_prefix, [yy],
-[[#ifndef YYDEBUG
-# define YYDEBUG ]b4_parse_trace_if([1], [0])[
-#endif]],
-[[#ifndef ]b4_api_PREFIX[DEBUG
-# if defined YYDEBUG
-#if YYDEBUG
-#   define ]b4_api_PREFIX[DEBUG 1
-#  else
-#   define ]b4_api_PREFIX[DEBUG 0
-#  endif
-# else /* ! defined YYDEBUG */
-#  define ]b4_api_PREFIX[DEBUG ]b4_parse_trace_if([1], [0])[
-# endif /* ! defined YYDEBUG */
-#endif  /* ! defined ]b4_api_PREFIX[DEBUG */]])[]dnl
-])
-
-# b4_declare_yydebug
-# ------------------
-m4_define([b4_declare_yydebug],
-[b4_YYDEBUG_define[
-#if ]b4_api_PREFIX[DEBUG
-extern int ]b4_prefix[debug;
-#endif][]dnl
-])
-
-# b4_yylloc_default_define
-# ------------------------
-# Define YYLLOC_DEFAULT.
-m4_define([b4_yylloc_default_define],
-[[/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
-   If N is 0, then set CURRENT to the empty location which ends
-   the previous symbol: RHS[0] (always defined).  */
-
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)                                \
-    do                                                                  \
-      if (N)                                                            \
-        {                                                               \
-          (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;        \
-          (Current).first_column = YYRHSLOC (Rhs, 1).first_column;      \
-          (Current).last_line    = YYRHSLOC (Rhs, N).last_line;         \
-          (Current).last_column  = YYRHSLOC (Rhs, N).last_column;       \
-        }                                                               \
-      else                                                              \
-        {                                                               \
-          (Current).first_line   = (Current).last_line   =              \
-            YYRHSLOC (Rhs, 0).last_line;                                \
-          (Current).first_column = (Current).last_column =              \
-            YYRHSLOC (Rhs, 0).last_column;                              \
-        }                                                               \
-    while (0)
-#endif
-]])
-
-# b4_yy_location_print_define
-# ---------------------------
-# Define YY_LOCATION_PRINT.
-m4_define([b4_yy_location_print_define],
-[b4_locations_if([[
-/* YY_LOCATION_PRINT -- Print the location on the stream.
-   This macro was not mandated originally: define only if we know
-   we won't break user code: when these are the locations we know.  */
-
-#ifndef YY_LOCATION_PRINT
-# if defined ]b4_api_PREFIX[LTYPE_IS_TRIVIAL && ]b4_api_PREFIX[LTYPE_IS_TRIVIAL
-
-/* Print *YYLOCP on YYO.  Private, do not rely on its existence. */
-
-YY_ATTRIBUTE_UNUSED
-]b4_function_define([yy_location_print_],
-    [static int],
-               [[FILE *yyo],                    [yyo]],
-               [[YYLTYPE const * const yylocp], [yylocp]])[
-{
-  int res = 0;
-  int end_col = 0 != yylocp->last_column ? yylocp->last_column - 1 : 0;
-  if (0 <= yylocp->first_line)
-    {
-      res += YYFPRINTF (yyo, "%d", yylocp->first_line);
-      if (0 <= yylocp->first_column)
-        res += YYFPRINTF (yyo, ".%d", yylocp->first_column);
-    }
-  if (0 <= yylocp->last_line)
-    {
-      if (yylocp->first_line < yylocp->last_line)
-        {
-          res += YYFPRINTF (yyo, "-%d", yylocp->last_line);
-          if (0 <= end_col)
-            res += YYFPRINTF (yyo, ".%d", end_col);
-        }
-      else if (0 <= end_col && yylocp->first_column < end_col)
-        res += YYFPRINTF (yyo, "-%d", end_col);
-    }
-  return res;
- }
-
-#  define YY_LOCATION_PRINT(File, Loc)          \
-  yy_location_print_ (File, &(Loc))
-
-# else
-#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-# endif
-#endif]],
-[[/* This macro is provided for backward compatibility. */
-#ifndef YY_LOCATION_PRINT
-# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-#endif]])
-])
-
-# b4_yyloc_default
-# ----------------
-# Expand to a possible default value for yylloc.
-m4_define([b4_yyloc_default],
-[[
-# if defined ]b4_api_PREFIX[LTYPE_IS_TRIVIAL && ]b4_api_PREFIX[LTYPE_IS_TRIVIAL
-  = { ]m4_join([, ],
-               m4_defn([b4_location_initial_line]),
-               m4_defn([b4_location_initial_column]),
-               m4_defn([b4_location_initial_line]),
-               m4_defn([b4_location_initial_column]))[ }
-# endif
-]])
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/yacc.c b/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/yacc.c
deleted file mode 100644
index 54e40e67412..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/third_party/skeletons/yacc.c
+++ /dev/null
@@ -1,1927 +0,0 @@
-                                                             -*- C -*-
-# Yacc compatible skeleton for Bison
-
-# Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2019 Free Software
-# Foundation, Inc.
-
-m4_pushdef([b4_copyright_years],
-           [1984, 1989-1990, 2000-2015, 2018-2019])
-
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-# Check the value of %define api.push-pull.
-b4_percent_define_default([[api.push-pull]], [[pull]])
-b4_percent_define_check_values([[[[api.push-pull]],
-                                 [[pull]], [[push]], [[both]]]])
-b4_define_flag_if([pull]) m4_define([b4_pull_flag], [[1]])
-b4_define_flag_if([push]) m4_define([b4_push_flag], [[1]])
-m4_case(b4_percent_define_get([[api.push-pull]]),
-        [pull], [m4_define([b4_push_flag], [[0]])],
-        [push], [m4_define([b4_pull_flag], [[0]])])
-
-# Handle BISON_USE_PUSH_FOR_PULL for the test suite.  So that push parsing
-# tests function as written, do not let BISON_USE_PUSH_FOR_PULL modify the
-# behavior of Bison at all when push parsing is already requested.
-b4_define_flag_if([use_push_for_pull])
-b4_use_push_for_pull_if([
-  b4_push_if([m4_define([b4_use_push_for_pull_flag], [[0]])],
-             [m4_define([b4_push_flag], [[1]])])])
-
-# Check the value of %define parse.lac and friends, where LAC stands for
-# lookahead correction.
-b4_percent_define_default([[parse.lac]], [[none]])
-b4_percent_define_default([[parse.lac.es-capacity-initial]], [[20]])
-b4_percent_define_default([[parse.lac.memory-trace]], [[failures]])
-b4_percent_define_check_values([[[[parse.lac]], [[full]], [[none]]]],
-                               [[[[parse.lac.memory-trace]],
-                                 [[failures]], [[full]]]])
-b4_define_flag_if([lac])
-m4_define([b4_lac_flag],
-          [m4_if(b4_percent_define_get([[parse.lac]]),
-                 [none], [[0]], [[1]])])
-
-m4_include(b4_skeletonsdir/[c.m4])
-
-## ---------------- ##
-## Default values.  ##
-## ---------------- ##
-
-# Stack parameters.
-m4_define_default([b4_stack_depth_max], [10000])
-m4_define_default([b4_stack_depth_init],  [200])
-
-
-## ------------------------ ##
-## Pure/impure interfaces.  ##
-## ------------------------ ##
-
-b4_percent_define_default([[api.pure]], [[false]])
-b4_percent_define_check_values([[[[api.pure]],
-                                 [[false]], [[true]], [[]], [[full]]]])
-
-m4_define([b4_pure_flag], [[0]])
-m4_case(b4_percent_define_get([[api.pure]]),
-        [false], [m4_define([b4_pure_flag], [[0]])],
-        [true],  [m4_define([b4_pure_flag], [[1]])],
-        [],      [m4_define([b4_pure_flag], [[1]])],
-        [full],  [m4_define([b4_pure_flag], [[2]])])
-
-m4_define([b4_pure_if],
-[m4_case(b4_pure_flag,
-         [0], [$2],
-         [1], [$1],
-         [2], [$1])])
-         [m4_fatal([invalid api.pure value: ]$1)])])
-
-# b4_yyerror_arg_loc_if(ARG)
-# --------------------------
-# Expand ARG iff yyerror is to be given a location as argument.
-m4_define([b4_yyerror_arg_loc_if],
-[b4_locations_if([m4_case(b4_pure_flag,
-                          [1], [m4_ifset([b4_parse_param], [$1])],
-                          [2], [$1])])])
-
-# b4_yyerror_args
-# ---------------
-# Arguments passed to yyerror: user args plus yylloc.
-m4_define([b4_yyerror_args],
-[b4_yyerror_arg_loc_if([&yylloc, ])dnl
-m4_ifset([b4_parse_param], [b4_args(b4_parse_param), ])])
-
-
-
-## ------------ ##
-## Data Types.  ##
-## ------------ ##
-
-# b4_int_type(MIN, MAX)
-# ---------------------
-# Return the smallest int type able to handle numbers ranging from
-# MIN to MAX (included).  Overwrite the version from c.m4, which
-# uses only C89 types, so that the user can override the shorter
-# types, and so that pre-C89 compilers are handled correctly.
-m4_define([b4_int_type],
-[m4_if(b4_ints_in($@,      [0],   [255]), [1], [yytype_uint8],
-       b4_ints_in($@,   [-128],   [127]), [1], [yytype_int8],
-
-       b4_ints_in($@,      [0], [65535]), [1], [yytype_uint16],
-       b4_ints_in($@, [-32768], [32767]), [1], [yytype_int16],
-
-       m4_eval([0 <= $1]),                [1], [unsigned],
-
-                                               [int])])
-
-
-## ----------------- ##
-## Semantic Values.  ##
-## ----------------- ##
-
-
-# b4_lhs_value(SYMBOL-NUM, [TYPE])
-# --------------------------------
-# See README.
-m4_define([b4_lhs_value],
-[b4_symbol_value(yyval, [$1], [$2])])
-
-
-# b4_rhs_value(RULE-LENGTH, POS, [SYMBOL-NUM], [TYPE])
-# ----------------------------------------------------
-# See README.
-m4_define([b4_rhs_value],
-[b4_symbol_value([yyvsp@{b4_subtract([$2], [$1])@}], [$3], [$4])])
-
-
-## ----------- ##
-## Locations.  ##
-## ----------- ##
-
-# b4_lhs_location()
-# -----------------
-# Expansion of @$.
-m4_define([b4_lhs_location],
-[(yyloc)])
-
-
-# b4_rhs_location(RULE-LENGTH, POS)
-# ---------------------------------
-# Expansion of @POS, where the current rule has RULE-LENGTH symbols
-# on RHS.
-m4_define([b4_rhs_location],
-[(yylsp@{b4_subtract([$2], [$1])@})])
-
-
-## -------------- ##
-## Declarations.  ##
-## -------------- ##
-
-# b4_declare_scanner_communication_variables
-# ------------------------------------------
-# Declare the variables that are global, or local to YYPARSE if
-# pure-parser.
-m4_define([b4_declare_scanner_communication_variables], [[
-/* The lookahead symbol.  */
-int yychar;
-
-]b4_pure_if([[
-/* The semantic value of the lookahead symbol.  */
-/* Default value used for initialization, for pacifying older GCCs
-   or non-GCC compilers.  */
-YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
-YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);]b4_locations_if([[
-
-/* Location data for the lookahead symbol.  */
-static YYLTYPE yyloc_default]b4_yyloc_default[;
-YYLTYPE yylloc = yyloc_default;]])],
-[[/* The semantic value of the lookahead symbol.  */
-YYSTYPE yylval;]b4_locations_if([[
-/* Location data for the lookahead symbol.  */
-YYLTYPE yylloc]b4_yyloc_default[;]])[
-/* Number of syntax errors so far.  */
-int yynerrs;]])])
-
-
-# b4_declare_parser_state_variables
-# ---------------------------------
-# Declare all the variables that are needed to maintain the parser state
-# between calls to yypush_parse.
-m4_define([b4_declare_parser_state_variables], [b4_pure_if([[
-    /* Number of syntax errors so far.  */
-    int yynerrs;
-]])[
-    int yystate;
-    /* Number of tokens to shift before error messages enabled.  */
-    int yyerrstatus;
-
-    /* The stacks and their tools:
-       'yyss': related to states.
-       'yyvs': related to semantic values.]b4_locations_if([[
-       'yyls': related to locations.]])[
-
-       Refer to the stacks through separate pointers, to allow yyoverflow
-       to reallocate them elsewhere.  */
-
-    /* The state stack.  */
-    yytype_int16 yyssa[YYINITDEPTH];
-    yytype_int16 *yyss;
-    yytype_int16 *yyssp;
-
-    /* The semantic value stack.  */
-    YYSTYPE yyvsa[YYINITDEPTH];
-    YYSTYPE *yyvs;
-    YYSTYPE *yyvsp;]b4_locations_if([[
-
-    /* The location stack.  */
-    YYLTYPE yylsa[YYINITDEPTH];
-    YYLTYPE *yyls;
-    YYLTYPE *yylsp;
-
-    /* The locations where the error started and ended.  */
-    YYLTYPE yyerror_range[3];]])[
-
-    YYSIZE_T yystacksize;]b4_lac_if([[
-
-    yytype_int16 yyesa@{]b4_percent_define_get([[parse.lac.es-capacity-initial]])[@};
-    yytype_int16 *yyes;
-    YYSIZE_T yyes_capacity;]])])
-
-
-# _b4_declare_yyparse_push
-# ------------------------
-# Declaration of yyparse (and dependencies) when using the push parser
-# (including in pull mode).
-m4_define([_b4_declare_yyparse_push],
-[[#ifndef YYPUSH_MORE_DEFINED
-# define YYPUSH_MORE_DEFINED
-enum { YYPUSH_MORE = 4 };
-#endif
-
-typedef struct ]b4_prefix[pstate ]b4_prefix[pstate;
-
-]b4_pull_if([b4_function_declare([b4_prefix[parse]], [[int]], b4_parse_param)
-])b4_function_declare([b4_prefix[push_parse]], [[int]],
-  [[b4_prefix[pstate *ps]], [[ps]]]b4_pure_if([,
-  [[[int pushed_char]], [[pushed_char]]],
-  [[b4_api_PREFIX[STYPE const *pushed_val]], [[pushed_val]]]b4_locations_if([,
-  [[b4_api_PREFIX[LTYPE *pushed_loc]], [[pushed_loc]]]])])m4_ifset([b4_parse_param], [,
-  b4_parse_param]))
-b4_pull_if([b4_function_declare([b4_prefix[pull_parse]], [[int]],
-  [[b4_prefix[pstate *ps]], [[ps]]]m4_ifset([b4_parse_param], [,
-  b4_parse_param]))])
-b4_function_declare([b4_prefix[pstate_new]], [b4_prefix[pstate *]],
-                    [[[void]], []])
-b4_function_declare([b4_prefix[pstate_delete]], [[void]],
-                   [[b4_prefix[pstate *ps]], [[ps]]])dnl
-])
-
-# _b4_declare_yyparse
-# -------------------
-# When not the push parser.
-m4_define([_b4_declare_yyparse],
-[b4_function_declare(b4_prefix[parse], [int], b4_parse_param)])
-
-
-# b4_declare_yyparse
-# ------------------
-m4_define([b4_declare_yyparse],
-[b4_push_if([_b4_declare_yyparse_push],
-            [_b4_declare_yyparse])[]dnl
-])
-
-
-# b4_shared_declarations
-# ----------------------
-# Declaration that might either go into the header (if --defines)
-# or open coded in the parser body.
-m4_define([b4_shared_declarations],
-[b4_cpp_guard_open([b4_spec_defines_file])[
-]b4_declare_yydebug[
-]b4_percent_code_get([[requires]])[
-]b4_token_enums_defines[
-]b4_declare_yylstype[
-]b4_declare_yyparse[
-]b4_percent_code_get([[provides]])[
-]b4_cpp_guard_close([b4_spec_defines_file])[]dnl
-])
-
-## -------------- ##
-## Output files.  ##
-## -------------- ##
-
-b4_output_begin([b4_parser_file_name])[
-]b4_copyright([Bison implementation for Yacc-like parsers in C])[
-/* C LALR(1) parser skeleton written by Richard Stallman, by
-   simplifying the original so-called "semantic" parser.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-]b4_disclaimer[
-]b4_identification[
-]b4_percent_code_get([[top]])[]dnl
-m4_if(b4_api_prefix, [yy], [],
-[[/* Substitute the type names.  */
-#define YYSTYPE         ]b4_api_PREFIX[STYPE]b4_locations_if([[
-#define YYLTYPE         ]b4_api_PREFIX[LTYPE]])])[
-]m4_if(b4_prefix, [yy], [],
-[[/* Substitute the variable and function names.  */]b4_pull_if([[
-#define yyparse         ]b4_prefix[parse]])b4_push_if([[
-#define yypush_parse    ]b4_prefix[push_parse]b4_pull_if([[
-#define yypull_parse    ]b4_prefix[pull_parse]])[
-#define yypstate_new    ]b4_prefix[pstate_new
-#define yypstate_delete ]b4_prefix[pstate_delete
-#define yypstate        ]b4_prefix[pstate]])[
-#define yylex           ]b4_prefix[lex
-#define yyerror         ]b4_prefix[error
-#define yydebug         ]b4_prefix[debug
-#define yynerrs         ]b4_prefix[nerrs
-]]b4_pure_if([], [[
-#define yylval          ]b4_prefix[lval
-#define yychar          ]b4_prefix[char]b4_locations_if([[
-#define yylloc          ]b4_prefix[lloc]])]))[
-
-]b4_user_pre_prologue[
-]b4_null_define[
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE ]b4_error_verbose_if([1], [0])[
-#endif
-
-]m4_ifval(m4_quote(b4_spec_defines_file),
-[[/* In a future release of Bison, this section will be replaced
-   by #include "@basename(]b4_spec_defines_file[@)".  */
-]])dnl
-b4_shared_declarations[
-
-]b4_user_post_prologue[
-]b4_percent_code_get[]dnl
-
-[#ifdef short
-# undef short
-#endif
-
-#ifdef YYTYPE_UINT8
-typedef YYTYPE_UINT8 yytype_uint8;
-#else
-typedef unsigned char yytype_uint8;
-#endif
-
-#ifdef YYTYPE_INT8
-typedef YYTYPE_INT8 yytype_int8;
-#else
-typedef signed char yytype_int8;
-#endif
-
-#ifdef YYTYPE_UINT16
-typedef YYTYPE_UINT16 yytype_uint16;
-#else
-typedef unsigned short yytype_uint16;
-#endif
-
-#ifdef YYTYPE_INT16
-typedef YYTYPE_INT16 yytype_int16;
-#else
-typedef short yytype_int16;
-#endif
-
-#ifndef YYSIZE_T
-# ifdef __SIZE_TYPE__
-#  define YYSIZE_T __SIZE_TYPE__
-# elif defined size_t
-#  define YYSIZE_T size_t
-# elif ! defined YYSIZE_T
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# else
-#  define YYSIZE_T unsigned
-# endif
-#endif
-
-#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
-
-#ifndef YY_
-# if defined YYENABLE_NLS && YYENABLE_NLS
-#  if ENABLE_NLS
-#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
-#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
-#  endif
-# endif
-# ifndef YY_
-#  define YY_(Msgid) Msgid
-# endif
-#endif
-
-]b4_attribute_define[
-
-#if ]b4_lac_if([[1]], [[! defined yyoverflow || YYERROR_VERBOSE]])[
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */]dnl
-b4_push_if([], [b4_lac_if([], [[
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   elif defined __BUILTIN_VA_ARG_INCR
-#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
-#   elif defined _AIX
-#    define YYSTACK_ALLOC __alloca
-#   elif defined _MSC_VER
-#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
-#    define alloca _alloca
-#   else
-#    define YYSTACK_ALLOC alloca
-#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
-#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
-#     ifndef EXIT_SUCCESS
-#      define EXIT_SUCCESS 0
-#     endif
-#    endif
-#   endif
-#  endif
-# endif]])])[
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's 'empty if-body' warning.  */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-    /* The OS might guarantee only one guard page at the bottom of the stack,
-       and a page size can be as small as 4096 bytes.  So we cannot safely
-       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
-       to allow for a few compiler-allocated temporary stack slots.  */
-#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
-#  endif
-# else
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
-#  endif
-#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
-       && ! ((defined YYMALLOC || defined malloc) \
-             && (defined YYFREE || defined free)))
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   ifndef EXIT_SUCCESS
-#    define EXIT_SUCCESS 0
-#   endif
-#  endif
-#  ifndef YYMALLOC
-#   define YYMALLOC malloc
-#   if ! defined malloc && ! defined EXIT_SUCCESS
-void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-#  ifndef YYFREE
-#   define YYFREE free
-#   if ! defined free && ! defined EXIT_SUCCESS
-void free (void *); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-# endif]b4_lac_if([[
-# define YYCOPY_NEEDED 1]])[
-#endif]b4_lac_if([], [[ /* ! defined yyoverflow || YYERROR_VERBOSE */]])[
-
-
-#if (! defined yyoverflow \
-     && (! defined __cplusplus \
-         || (]b4_locations_if([[defined ]b4_api_PREFIX[LTYPE_IS_TRIVIAL && ]b4_api_PREFIX[LTYPE_IS_TRIVIAL \
-             && ]])[defined ]b4_api_PREFIX[STYPE_IS_TRIVIAL && ]b4_api_PREFIX[STYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  yytype_int16 yyss_alloc;
-  YYSTYPE yyvs_alloc;]b4_locations_if([
-  YYLTYPE yyls_alloc;])[
-};
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-]b4_locations_if(
-[# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE) + sizeof (YYLTYPE)) \
-      + 2 * YYSTACK_GAP_MAXIMUM)],
-[# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
-      + YYSTACK_GAP_MAXIMUM)])[
-
-# define YYCOPY_NEEDED 1
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
-    do                                                                  \
-      {                                                                 \
-        YYSIZE_T yynewbytes;                                            \
-        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
-        Stack = &yyptr->Stack_alloc;                                    \
-        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-        yyptr += yynewbytes / sizeof (*yyptr);                          \
-      }                                                                 \
-    while (0)
-
-#endif
-
-#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
-/* Copy COUNT objects from SRC to DST.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined __GNUC__ && 1 < __GNUC__
-#   define YYCOPY(Dst, Src, Count) \
-      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
-#  else
-#   define YYCOPY(Dst, Src, Count)              \
-      do                                        \
-        {                                       \
-          YYSIZE_T yyi;                         \
-          for (yyi = 0; yyi < (Count); yyi++)   \
-            (Dst)[yyi] = (Src)[yyi];            \
-        }                                       \
-      while (0)
-#  endif
-# endif
-#endif /* !YYCOPY_NEEDED */
-
-/* YYFINAL -- State number of the termination state.  */
-#define YYFINAL  ]b4_final_state_number[
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   ]b4_last[
-
-/* YYNTOKENS -- Number of terminals.  */
-#define YYNTOKENS  ]b4_tokens_number[
-/* YYNNTS -- Number of nonterminals.  */
-#define YYNNTS  ]b4_nterms_number[
-/* YYNRULES -- Number of rules.  */
-#define YYNRULES  ]b4_rules_number[
-/* YYNSTATES -- Number of states.  */
-#define YYNSTATES  ]b4_states_number[
-
-#define YYUNDEFTOK  ]b4_undef_token_number[
-#define YYMAXUTOK   ]b4_user_token_number_max[
-
-/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
-   as returned by yylex, with out-of-bounds checking.  */
-#define YYTRANSLATE(YYX)                                                \
-  ((unsigned) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
-   as returned by yylex.  */
-static const ]b4_int_type_for([b4_translate])[ yytranslate[] =
-{
-  ]b4_translate[
-};
-
-#if ]b4_api_PREFIX[DEBUG
-]b4_integral_parser_table_define([rline], [b4_rline],
-     [[YYRLINE[YYN] -- Source line where rule number YYN was defined.]])[
-#endif
-
-#if ]b4_api_PREFIX[DEBUG || YYERROR_VERBOSE || ]b4_token_table_flag[
-/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
-static const char *const yytname[] =
-{
-  ]b4_tname[
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[NUM] -- (External) token number corresponding to the
-   (internal) symbol number NUM (which must be that of a token).  */
-static const ]b4_int_type_for([b4_toknum])[ yytoknum[] =
-{
-  ]b4_toknum[
-};
-# endif
-
-#define YYPACT_NINF ]b4_pact_ninf[
-
-#define yypact_value_is_default(Yystate) \
-  ]b4_table_value_equals([[pact]], [[Yystate]], [b4_pact_ninf])[
-
-#define YYTABLE_NINF ]b4_table_ninf[
-
-#define yytable_value_is_error(Yytable_value) \
-  ]b4_table_value_equals([[table]], [[Yytable_value]], [b4_table_ninf])[
-
-]b4_parser_tables_define[
-
-#define yyerrok         (yyerrstatus = 0)
-#define yyclearin       (yychar = YYEMPTY)
-#define YYEMPTY         (-2)
-#define YYEOF           0
-
-#define YYACCEPT        goto yyacceptlab
-#define YYABORT         goto yyabortlab
-#define YYERROR         goto yyerrorlab
-
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)                                    \
-  do                                                              \
-    if (yychar == YYEMPTY)                                        \
-      {                                                           \
-        yychar = (Token);                                         \
-        yylval = (Value);                                         \
-        YYPOPSTACK (yylen);                                       \
-        yystate = *yyssp;                                         \]b4_lac_if([[
-        YY_LAC_DISCARD ("YYBACKUP");                              \]])[
-        goto yybackup;                                            \
-      }                                                           \
-    else                                                          \
-      {                                                           \
-        yyerror (]b4_yyerror_args[YY_("syntax error: cannot back up")); \
-        YYERROR;                                                  \
-      }                                                           \
-  while (0)
-
-/* Error token number */
-#define YYTERROR        1
-#define YYERRCODE       256
-
-]b4_locations_if([[
-]b4_yylloc_default_define[
-#define YYRHSLOC(Rhs, K) ((Rhs)[K])
-]])[
-
-/* Enable debugging if requested.  */
-#if ]b4_api_PREFIX[DEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)                        \
-do {                                            \
-  if (yydebug)                                  \
-    YYFPRINTF Args;                             \
-} while (0)
-
-]b4_yy_location_print_define[
-
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
-do {                                                                      \
-  if (yydebug)                                                            \
-    {                                                                     \
-      YYFPRINTF (stderr, "%s ", Title);                                   \
-      yy_symbol_print (stderr,                                            \
-                  Type, Value]b4_locations_if([, Location])[]b4_user_args[); \
-      YYFPRINTF (stderr, "\n");                                           \
-    }                                                                     \
-} while (0)
-
-]b4_yy_symbol_print_define[
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-]b4_function_define([yy_stack_print], [static void],
-                   [[yytype_int16 *yybottom], [yybottom]],
-                   [[yytype_int16 *yytop],    [yytop]])[
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (; yybottom <= yytop; yybottom++)
-    {
-      int yybot = *yybottom;
-      YYFPRINTF (stderr, " %d", yybot);
-    }
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)                            \
-do {                                                            \
-  if (yydebug)                                                  \
-    yy_stack_print ((Bottom), (Top));                           \
-} while (0)
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-]b4_function_define([yy_reduce_print], [static void],
-                   [[yytype_int16 *yyssp], [yyssp]],
-                   [[YYSTYPE *yyvsp], [yyvsp]],
-    b4_locations_if([[[YYLTYPE *yylsp], [yylsp]],
-                   ])[[int yyrule], [yyrule]]m4_ifset([b4_parse_param], [,
-                   b4_parse_param]))[
-{
-  unsigned long yylno = yyrline[yyrule];
-  int yynrhs = yyr2[yyrule];
-  int yyi;
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
-             yyrule - 1, yylno);
-  /* The symbols being reduced.  */
-  for (yyi = 0; yyi < yynrhs; yyi++)
-    {
-      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
-      yy_symbol_print (stderr,
-                       yystos[yyssp[yyi + 1 - yynrhs]],
-                       &]b4_rhs_value(yynrhs, yyi + 1)[
-                       ]b4_locations_if([, &]b4_rhs_location(yynrhs, yyi + 1))[]dnl
-                       b4_user_args[);
-      YYFPRINTF (stderr, "\n");
-    }
-}
-
-# define YY_REDUCE_PRINT(Rule)          \
-do {                                    \
-  if (yydebug)                          \
-    yy_reduce_print (yyssp, yyvsp, ]b4_locations_if([yylsp, ])[Rule]b4_user_args[); \
-} while (0)
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !]b4_api_PREFIX[DEBUG */
-# define YYDPRINTF(Args)
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !]b4_api_PREFIX[DEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef YYINITDEPTH
-# define YYINITDEPTH ]b4_stack_depth_init[
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH ]b4_stack_depth_max[
-#endif]b4_lac_if([[
-
-/* Given a state stack such that *YYBOTTOM is its bottom, such that
-   *YYTOP is either its top or is YYTOP_EMPTY to indicate an empty
-   stack, and such that *YYCAPACITY is the maximum number of elements it
-   can hold without a reallocation, make sure there is enough room to
-   store YYADD more elements.  If not, allocate a new stack using
-   YYSTACK_ALLOC, copy the existing elements, and adjust *YYBOTTOM,
-   *YYTOP, and *YYCAPACITY to reflect the new capacity and memory
-   location.  If *YYBOTTOM != YYBOTTOM_NO_FREE, then free the old stack
-   using YYSTACK_FREE.  Return 0 if successful or if no reallocation is
-   required.  Return 1 if memory is exhausted.  */
-static int
-yy_lac_stack_realloc (YYSIZE_T *yycapacity, YYSIZE_T yyadd,
-#if ]b4_api_PREFIX[DEBUG
-                      char const *yydebug_prefix,
-                      char const *yydebug_suffix,
-#endif
-                      yytype_int16 **yybottom,
-                      yytype_int16 *yybottom_no_free,
-                      yytype_int16 **yytop, yytype_int16 *yytop_empty)
-{
-  YYSIZE_T yysize_old =
-    (YYSIZE_T) (*yytop == yytop_empty ? 0 : *yytop - *yybottom + 1);
-  YYSIZE_T yysize_new = yysize_old + yyadd;
-  if (*yycapacity < yysize_new)
-    {
-      YYSIZE_T yyalloc = 2 * yysize_new;
-      yytype_int16 *yybottom_new;
-      /* Use YYMAXDEPTH for maximum stack size given that the stack
-         should never need to grow larger than the main state stack
-         needs to grow without LAC.  */
-      if (YYMAXDEPTH < yysize_new)
-        {
-          YYDPRINTF ((stderr, "%smax size exceeded%s", yydebug_prefix,
-                      yydebug_suffix));
-          return 1;
-        }
-      if (YYMAXDEPTH < yyalloc)
-        yyalloc = YYMAXDEPTH;
-      yybottom_new =
-        (yytype_int16*) YYSTACK_ALLOC (yyalloc * sizeof *yybottom_new);
-      if (!yybottom_new)
-        {
-          YYDPRINTF ((stderr, "%srealloc failed%s", yydebug_prefix,
-                      yydebug_suffix));
-          return 1;
-        }
-      if (*yytop != yytop_empty)
-        {
-          YYCOPY (yybottom_new, *yybottom, yysize_old);
-          *yytop = yybottom_new + (yysize_old - 1);
-        }
-      if (*yybottom != yybottom_no_free)
-        YYSTACK_FREE (*yybottom);
-      *yybottom = yybottom_new;
-      *yycapacity = yyalloc;]m4_if(b4_percent_define_get([[parse.lac.memory-trace]]),
-                                   [full], [[
-      YYDPRINTF ((stderr, "%srealloc to %lu%s", yydebug_prefix,
-                  (unsigned long) yyalloc, yydebug_suffix));]])[
-    }
-  return 0;
-}
-
-/* Establish the initial context for the current lookahead if no initial
-   context is currently established.
-
-   We define a context as a snapshot of the parser stacks.  We define
-   the initial context for a lookahead as the context in which the
-   parser initially examines that lookahead in order to select a
-   syntactic action.  Thus, if the lookahead eventually proves
-   syntactically unacceptable (possibly in a later context reached via a
-   series of reductions), the initial context can be used to determine
-   the exact set of tokens that would be syntactically acceptable in the
-   lookahead's place.  Moreover, it is the context after which any
-   further semantic actions would be erroneous because they would be
-   determined by a syntactically unacceptable token.
-
-   YY_LAC_ESTABLISH should be invoked when a reduction is about to be
-   performed in an inconsistent state (which, for the purposes of LAC,
-   includes consistent states that don't know they're consistent because
-   their default reductions have been disabled).  Iff there is a
-   lookahead token, it should also be invoked before reporting a syntax
-   error.  This latter case is for the sake of the debugging output.
-
-   For parse.lac=full, the implementation of YY_LAC_ESTABLISH is as
-   follows.  If no initial context is currently established for the
-   current lookahead, then check if that lookahead can eventually be
-   shifted if syntactic actions continue from the current context.
-   Report a syntax error if it cannot.  */
-#define YY_LAC_ESTABLISH                                         \
-do {                                                             \
-  if (!yy_lac_established)                                       \
-    {                                                            \
-      YYDPRINTF ((stderr,                                        \
-                  "LAC: initial context established for %s\n",   \
-                  yytname[yytoken]));                            \
-      yy_lac_established = 1;                                    \
-      {                                                          \
-        int yy_lac_status =                                      \
-          yy_lac (yyesa, &yyes, &yyes_capacity, yyssp, yytoken); \
-        if (yy_lac_status == 2)                                  \
-          goto yyexhaustedlab;                                   \
-        if (yy_lac_status == 1)                                  \
-          goto yyerrlab;                                         \
-      }                                                          \
-    }                                                            \
-} while (0)
-
-/* Discard any previous initial lookahead context because of Event,
-   which may be a lookahead change or an invalidation of the currently
-   established initial context for the current lookahead.
-
-   The most common example of a lookahead change is a shift.  An example
-   of both cases is syntax error recovery.  That is, a syntax error
-   occurs when the lookahead is syntactically erroneous for the
-   currently established initial context, so error recovery manipulates
-   the parser stacks to try to find a new initial context in which the
-   current lookahead is syntactically acceptable.  If it fails to find
-   such a context, it discards the lookahead.  */
-#if ]b4_api_PREFIX[DEBUG
-# define YY_LAC_DISCARD(Event)                                           \
-do {                                                                     \
-  if (yy_lac_established)                                                \
-    {                                                                    \
-      if (yydebug)                                                       \
-        YYFPRINTF (stderr, "LAC: initial context discarded due to "      \
-                   Event "\n");                                          \
-      yy_lac_established = 0;                                            \
-    }                                                                    \
-} while (0)
-#else
-# define YY_LAC_DISCARD(Event) yy_lac_established = 0
-#endif
-
-/* Given the stack whose top is *YYSSP, return 0 iff YYTOKEN can
-   eventually (after perhaps some reductions) be shifted, return 1 if
-   not, or return 2 if memory is exhausted.  As preconditions and
-   postconditions: *YYES_CAPACITY is the allocated size of the array to
-   which *YYES points, and either *YYES = YYESA or *YYES points to an
-   array allocated with YYSTACK_ALLOC.  yy_lac may overwrite the
-   contents of either array, alter *YYES and *YYES_CAPACITY, and free
-   any old *YYES other than YYESA.  */
-static int
-yy_lac (yytype_int16 *yyesa, yytype_int16 **yyes,
-        YYSIZE_T *yyes_capacity, yytype_int16 *yyssp, int yytoken)
-{
-  yytype_int16 *yyes_prev = yyssp;
-  yytype_int16 *yyesp = yyes_prev;
-  YYDPRINTF ((stderr, "LAC: checking lookahead %s:", yytname[yytoken]));
-  if (yytoken == YYUNDEFTOK)
-    {
-      YYDPRINTF ((stderr, " Always Err\n"));
-      return 1;
-    }
-  while (1)
-    {
-      int yyrule = yypact[*yyesp];
-      if (yypact_value_is_default (yyrule)
-          || (yyrule += yytoken) < 0 || YYLAST < yyrule
-          || yycheck[yyrule] != yytoken)
-        {
-          yyrule = yydefact[*yyesp];
-          if (yyrule == 0)
-            {
-              YYDPRINTF ((stderr, " Err\n"));
-              return 1;
-            }
-        }
-      else
-        {
-          yyrule = yytable[yyrule];
-          if (yytable_value_is_error (yyrule))
-            {
-              YYDPRINTF ((stderr, " Err\n"));
-              return 1;
-            }
-          if (0 < yyrule)
-            {
-              YYDPRINTF ((stderr, " S%d\n", yyrule));
-              return 0;
-            }
-          yyrule = -yyrule;
-        }
-      {
-        YYSIZE_T yylen = yyr2[yyrule];
-        YYDPRINTF ((stderr, " R%d", yyrule - 1));
-        if (yyesp != yyes_prev)
-          {
-            YYSIZE_T yysize = (YYSIZE_T) (yyesp - *yyes + 1);
-            if (yylen < yysize)
-              {
-                yyesp -= yylen;
-                yylen = 0;
-              }
-            else
-              {
-                yylen -= yysize;
-                yyesp = yyes_prev;
-              }
-          }
-        if (yylen)
-          yyesp = yyes_prev -= yylen;
-      }
-      {
-        yytype_int16 yystate;
-        {
-          const int yylhs = yyr1[yyrule] - YYNTOKENS;
-          const int yyi = yypgoto[yylhs] + *yyesp;
-          yystate = ((yytype_int16)
-                     (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyesp
-                      ? yytable[yyi]
-                      : yydefgoto[yylhs]));
-        }
-        if (yyesp == yyes_prev)
-          {
-            yyesp = *yyes;
-            *yyesp = yystate;
-          }
-        else
-          {
-            if (yy_lac_stack_realloc (yyes_capacity, 1,
-#if ]b4_api_PREFIX[DEBUG
-                                      " (", ")",
-#endif
-                                      yyes, yyesa, &yyesp, yyes_prev))
-              {
-                YYDPRINTF ((stderr, "\n"));
-                return 2;
-              }
-            *++yyesp = yystate;
-          }
-        YYDPRINTF ((stderr, " G%d", (int) yystate));
-      }
-    }
-}]])[
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined __GLIBC__ && defined _STRING_H
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-]b4_function_define([yystrlen], [static YYSIZE_T],
-   [[const char *yystr], [yystr]])[
-{
-  YYSIZE_T yylen;
-  for (yylen = 0; yystr[yylen]; yylen++)
-    continue;
-  return yylen;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-]b4_function_define([yystpcpy], [static char *],
-   [[char *yydest], [yydest]], [[const char *yysrc], [yysrc]])[
-{
-  char *yyd = yydest;
-  const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-# ifndef yytnamerr
-/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
-   quotes and backslashes, so that it's suitable for yyerror.  The
-   heuristic is that double-quoting is unnecessary unless the string
-   contains an apostrophe, a comma, or backslash (other than
-   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
-   null, do not copy; instead, return the length of what the result
-   would have been.  */
-static YYSIZE_T
-yytnamerr (char *yyres, const char *yystr)
-{
-  if (*yystr == '"')
-    {
-      YYSIZE_T yyn = 0;
-      char const *yyp = yystr;
-
-      for (;;)
-        switch (*++yyp)
-          {
-          case '\'':
-          case ',':
-            goto do_not_strip_quotes;
-
-          case '\\':
-            if (*++yyp != '\\')
-              goto do_not_strip_quotes;
-            else
-              goto append;
-
-          append:
-          default:
-            if (yyres)
-              yyres[yyn] = *yyp;
-            yyn++;
-            break;
-
-          case '"':
-            if (yyres)
-              yyres[yyn] = '\0';
-            return yyn;
-          }
-    do_not_strip_quotes: ;
-    }
-
-  if (! yyres)
-    return yystrlen (yystr);
-
-  return (YYSIZE_T) (yystpcpy (yyres, yystr) - yyres);
-}
-# endif
-
-/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
-   about the unexpected token YYTOKEN for the state stack whose top is
-   YYSSP.]b4_lac_if([[  In order to see if a particular token T is a
-   valid looakhead, invoke yy_lac (YYESA, YYES, YYES_CAPACITY, YYSSP, T).]])[
-
-   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
-   not large enough to hold the message.  In that case, also set
-   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
-   required number of bytes is too large to store]b4_lac_if([[ or if
-   yy_lac returned 2]])[.  */
-static int
-yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
-                ]b4_lac_if([[yytype_int16 *yyesa, yytype_int16 **yyes,
-                YYSIZE_T *yyes_capacity, ]])[yytype_int16 *yyssp, int yytoken)
-{
-  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
-  YYSIZE_T yysize = yysize0;
-  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-  /* Internationalized format string. */
-  const char *yyformat = YY_NULLPTR;
-  /* Arguments of yyformat. */
-  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-  /* Number of reported tokens (one for the "unexpected", one per
-     "expected"). */
-  int yycount = 0;
-
-  /* There are many possibilities here to consider:
-     - If this state is a consistent state with a default action, then
-       the only way this function was invoked is if the default action
-       is an error action.  In that case, don't check for expected
-       tokens because there are none.
-     - The only way there can be no lookahead present (in yychar) is if
-       this state is a consistent state with a default action.  Thus,
-       detecting the absence of a lookahead is sufficient to determine
-       that there is no unexpected or expected token to report.  In that
-       case, just report a simple "syntax error".
-     - Don't assume there isn't a lookahead just because this state is a
-       consistent state with a default action.  There might have been a
-       previous inconsistent state, consistent state with a non-default
-       action, or user semantic action that manipulated yychar.]b4_lac_if([[
-       In the first two cases, it might appear that the current syntax
-       error should have been detected in the previous state when yy_lac
-       was invoked.  However, at that time, there might have been a
-       different syntax error that discarded a different initial context
-       during error recovery, leaving behind the current lookahead.]], [[
-     - Of course, the expected token list depends on states to have
-       correct lookahead information, and it depends on the parser not
-       to perform extra reductions after fetching a lookahead from the
-       scanner and before detecting a syntax error.  Thus, state merging
-       (from LALR or IELR) and default reductions corrupt the expected
-       token list.  However, the list is correct for canonical LR with
-       one exception: it will still contain any token that will not be
-       accepted due to an error action in a later state.]])[
-  */
-  if (yytoken != YYEMPTY)
-    {
-      int yyn = yypact[*yyssp];]b4_lac_if([[
-      YYDPRINTF ((stderr, "Constructing syntax error message\n"));]])[
-      yyarg[yycount++] = yytname[yytoken];
-      if (!yypact_value_is_default (yyn))
-        {]b4_lac_if([], [[
-          /* Start YYX at -YYN if negative to avoid negative indexes in
-             YYCHECK.  In other words, skip the first -YYN actions for
-             this state because they are default actions.  */
-          int yyxbegin = yyn < 0 ? -yyn : 0;
-          /* Stay within bounds of both yycheck and yytname.  */
-          int yychecklim = YYLAST - yyn + 1;
-          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;]])[
-          int yyx;]b4_lac_if([[
-
-          for (yyx = 0; yyx < YYNTOKENS; ++yyx)
-            if (yyx != YYTERROR && yyx != YYUNDEFTOK)
-              {
-                {
-                  int yy_lac_status = yy_lac (yyesa, yyes, yyes_capacity,
-                                              yyssp, yyx);
-                  if (yy_lac_status == 2)
-                    return 2;
-                  if (yy_lac_status == 1)
-                    continue;
-                }]], [[
-
-          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
-                && !yytable_value_is_error (yytable[yyx + yyn]))
-              {]])[
-                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-                  {
-                    yycount = 1;
-                    yysize = yysize0;
-                    break;
-                  }
-                yyarg[yycount++] = yytname[yyx];
-                {
-                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
-                  if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
-                    yysize = yysize1;
-                  else
-                    return 2;
-                }
-              }
-        }]b4_lac_if([[
-# if ]b4_api_PREFIX[DEBUG
-      else if (yydebug)
-        YYFPRINTF (stderr, "No expected tokens.\n");
-# endif]])[
-    }
-
-  switch (yycount)
-    {
-# define YYCASE_(N, S)                      \
-      case N:                               \
-        yyformat = S;                       \
-      break
-    default: /* Avoid compiler warnings. */
-      YYCASE_(0, YY_("syntax error"));
-      YYCASE_(1, YY_("syntax error, unexpected %s"));
-      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
-      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
-      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
-      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
-# undef YYCASE_
-    }
-
-  {
-    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
-    if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
-      yysize = yysize1;
-    else
-      return 2;
-  }
-
-  if (*yymsg_alloc < yysize)
-    {
-      *yymsg_alloc = 2 * yysize;
-      if (! (yysize <= *yymsg_alloc
-             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
-        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
-      return 1;
-    }
-
-  /* Avoid sprintf, as that infringes on the user's name space.
-     Don't have undefined behavior even if the translation
-     produced a string with the wrong number of "%s"s.  */
-  {
-    char *yyp = *yymsg;
-    int yyi = 0;
-    while ((*yyp = *yyformat) != '\0')
-      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
-        {
-          yyp += yytnamerr (yyp, yyarg[yyi++]);
-          yyformat += 2;
-        }
-      else
-        {
-          yyp++;
-          yyformat++;
-        }
-  }
-  return 0;
-}
-#endif /* YYERROR_VERBOSE */
-
-]b4_yydestruct_define[
-
-]b4_pure_if([], [
-
-b4_declare_scanner_communication_variables])[]b4_push_if([[
-
-struct yypstate
-  {]b4_declare_parser_state_variables[
-    /* Used to determine if this is the first time this instance has
-       been used.  */
-    int yynew;
-  };]b4_pure_if([], [[
-
-static char yypstate_allocated = 0;]])b4_pull_if([
-
-b4_function_define([[yyparse]], [[int]], b4_parse_param)[
-{
-  return yypull_parse (YY_NULLPTR]m4_ifset([b4_parse_param],
-                                  [[, ]b4_args(b4_parse_param)])[);
-}
-
-]b4_function_define([[yypull_parse]], [[int]],
-  [[[yypstate *yyps]], [[yyps]]]m4_ifset([b4_parse_param], [,
-  b4_parse_param]))[
-{]b4_pure_if([b4_locations_if([[
-  static YYLTYPE yyloc_default][]b4_yyloc_default[;
-  YYLTYPE yylloc = yyloc_default;]])])[
-  yypstate *yyps_local;
-  if (yyps)
-    yyps_local = yyps;
-  else
-    {
-      yyps_local = yypstate_new ();
-      if (!yyps_local)
-        {]b4_pure_if([[
-          yyerror (]b4_yyerror_args[YY_("memory exhausted"));]], [[
-          if (!yypstate_allocated)
-            yyerror (]b4_yyerror_args[YY_("memory exhausted"));]])[
-          return 2;
-        }
-    }
-  int yystatus;
-  do {]b4_pure_if([[
-    YYSTYPE yylval;
-    int ]])[yychar = ]b4_lex[;
-    yystatus =
-      yypush_parse (yyps_local]b4_pure_if([[, yychar, &yylval]b4_locations_if([[, &yylloc]])])m4_ifset([b4_parse_param], [, b4_args(b4_parse_param)])[);
-  } while (yystatus == YYPUSH_MORE);
-  if (!yyps)
-    yypstate_delete (yyps_local);
-  return yystatus;
-}]])[
-
-/* Initialize the parser data structure.  */
-]b4_function_define([[yypstate_new]], [[yypstate *]])[
-{
-  yypstate *yyps;]b4_pure_if([], [[
-  if (yypstate_allocated)
-    return YY_NULLPTR;]])[
-  yyps = (yypstate *) malloc (sizeof *yyps);
-  if (!yyps)
-    return YY_NULLPTR;
-  yyps->yynew = 1;]b4_pure_if([], [[
-  yypstate_allocated = 1;]])[
-  return yyps;
-}
-
-]b4_function_define([[yypstate_delete]], [[void]],
-                   [[[yypstate *yyps]], [[yyps]]])[
-{
-  if (yyps)
-    {
-#ifndef yyoverflow
-      /* If the stack was reallocated but the parse did not complete, then the
-         stack still needs to be freed.  */
-      if (!yyps->yynew && yyps->yyss != yyps->yyssa)
-        YYSTACK_FREE (yyps->yyss);
-#endif]b4_lac_if([[
-      if (!yyps->yynew && yyps->yyes != yyps->yyesa)
-        YYSTACK_FREE (yyps->yyes);]])[
-      free (yyps);]b4_pure_if([], [[
-      yypstate_allocated = 0;]])[
-    }
-}
-]b4_pure_if([[
-#define ]b4_prefix[nerrs yyps->]b4_prefix[nerrs]])[
-#define yystate yyps->yystate
-#define yyerrstatus yyps->yyerrstatus
-#define yyssa yyps->yyssa
-#define yyss yyps->yyss
-#define yyssp yyps->yyssp
-#define yyvsa yyps->yyvsa
-#define yyvs yyps->yyvs
-#define yyvsp yyps->yyvsp]b4_locations_if([[
-#define yylsa yyps->yylsa
-#define yyls yyps->yyls
-#define yylsp yyps->yylsp
-#define yyerror_range yyps->yyerror_range]])[
-#define yystacksize yyps->yystacksize]b4_lac_if([[
-#define yyesa yyps->yyesa
-#define yyes yyps->yyes
-#define yyes_capacity yyps->yyes_capacity]])[
-
-
-/*---------------.
-| yypush_parse.  |
-`---------------*/
-
-]b4_function_define([[yypush_parse]], [[int]],
-  [[[yypstate *yyps]], [[yyps]]]b4_pure_if([,
-  [[[int yypushed_char]], [[yypushed_char]]],
-  [[[YYSTYPE const *yypushed_val]], [[yypushed_val]]]b4_locations_if([,
-  [[[YYLTYPE *yypushed_loc]], [[yypushed_loc]]]])])m4_ifset([b4_parse_param], [,
-  b4_parse_param]))], [[
-
-
-/*----------.
-| yyparse.  |
-`----------*/
-
-]b4_function_define([yyparse], [int], b4_parse_param)])[
-{]b4_pure_if([b4_declare_scanner_communication_variables
-])b4_push_if([b4_pure_if([], [[
-  int yypushed_char = yychar;
-  YYSTYPE yypushed_val = yylval;]b4_locations_if([[
-  YYLTYPE yypushed_loc = yylloc;]])
-])],
-  [b4_declare_parser_state_variables
-])b4_lac_if([[
-  int yy_lac_established = 0;]])[
-  int yyn;
-  int yyresult;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;]b4_locations_if([[
-  YYLTYPE yyloc;]])[
-
-#if YYERROR_VERBOSE
-  /* Buffer for error messages, and its allocated size.  */
-  char yymsgbuf[128];
-  char *yymsg = yymsgbuf;
-  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
-#endif
-
-#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N)]b4_locations_if([, yylsp -= (N)])[)
-
-  /* The number of symbols on the RHS of the reduced rule.
-     Keep to zero when no symbol should be popped.  */
-  int yylen = 0;]b4_push_if([[
-
-  if (!yyps->yynew)
-    {
-      yyn = yypact[yystate];
-      goto yyread_pushed_token;
-    }]])[
-
-  yyssp = yyss = yyssa;
-  yyvsp = yyvs = yyvsa;]b4_locations_if([[
-  yylsp = yyls = yylsa;]])[
-  yystacksize = YYINITDEPTH;]b4_lac_if([[
-
-  yyes = yyesa;
-  yyes_capacity = sizeof yyesa / sizeof *yyes;
-  if (YYMAXDEPTH < yyes_capacity)
-    yyes_capacity = YYMAXDEPTH;]])[
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY; /* Cause a token to be read.  */
-]m4_ifdef([b4_initial_action], [
-b4_dollar_pushdef([m4_define([b4_dollar_dollar_used])yylval], [], [],
-                  [b4_push_if([b4_pure_if([*])yypushed_loc], [yylloc])])dnl
-b4_user_initial_action
-b4_dollar_popdef[]dnl
-m4_ifdef([b4_dollar_dollar_used],[[  yyvsp[0] = yylval;
-]])])dnl
-b4_locations_if([[  yylsp[0] = ]b4_push_if([b4_pure_if([*])yypushed_loc], [yylloc])[;
-]])dnl
-[  goto yysetstate;
-
-
-/*------------------------------------------------------------.
-| yynewstate -- push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
-yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed.  So pushing a state here evens the stacks.  */
-  yyssp++;
-
-
-/*--------------------------------------------------------------------.
-| yynewstate -- set current state (the top of the stack) to yystate.  |
-`--------------------------------------------------------------------*/
-yysetstate:
-  *yyssp = (yytype_int16) yystate;
-
-  if (yyss + yystacksize - 1 <= yyssp)
-#if !defined yyoverflow && !defined YYSTACK_RELOCATE
-    goto yyexhaustedlab;
-#else
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = (YYSIZE_T) (yyssp - yyss + 1);
-
-# if defined yyoverflow
-      {
-        /* Give user a chance to reallocate the stack.  Use copies of
-           these so that the &'s don't force the real ones into
-           memory.  */
-        YYSTYPE *yyvs1 = yyvs;
-        yytype_int16 *yyss1 = yyss;]b4_locations_if([
-        YYLTYPE *yyls1 = yyls;])[
-
-        /* Each stack pointer address is followed by the size of the
-           data in use in that stack, in bytes.  This used to be a
-           conditional around just the two extra args, but that might
-           be undefined if yyoverflow is a macro.  */
-        yyoverflow (YY_("memory exhausted"),
-                    &yyss1, yysize * sizeof (*yyssp),
-                    &yyvs1, yysize * sizeof (*yyvsp),]b4_locations_if([
-                    &yyls1, yysize * sizeof (*yylsp),])[
-                    &yystacksize);
-        yyss = yyss1;
-        yyvs = yyvs1;]b4_locations_if([
-        yyls = yyls1;])[
-      }
-# else /* defined YYSTACK_RELOCATE */
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-        goto yyexhaustedlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-        yystacksize = YYMAXDEPTH;
-
-      {
-        yytype_int16 *yyss1 = yyss;
-        union yyalloc *yyptr =
-          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-        if (! yyptr)
-          goto yyexhaustedlab;
-        YYSTACK_RELOCATE (yyss_alloc, yyss);
-        YYSTACK_RELOCATE (yyvs_alloc, yyvs);]b4_locations_if([
-        YYSTACK_RELOCATE (yyls_alloc, yyls);])[
-# undef YYSTACK_RELOCATE
-        if (yyss1 != yyssa)
-          YYSTACK_FREE (yyss1);
-      }
-# endif
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;]b4_locations_if([
-      yylsp = yyls + yysize - 1;])[
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-                  (unsigned long) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-        YYABORT;
-    }
-#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  if (yystate == YYFINAL)
-    YYACCEPT;
-
-  goto yybackup;
-
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-  /* Do appropriate processing given the current state.  Read a
-     lookahead token if we need one and don't already have one.  */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-  yyn = yypact[yystate];
-  if (yypact_value_is_default (yyn))
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
-  if (yychar == YYEMPTY)
-    {]b4_push_if([[
-      if (!yyps->yynew)
-        {]b4_use_push_for_pull_if([], [[
-          YYDPRINTF ((stderr, "Return for a new token:\n"));]])[
-          yyresult = YYPUSH_MORE;
-          goto yypushreturn;
-        }
-      yyps->yynew = 0;]b4_pure_if([], [[
-      /* Restoring the pushed token is only necessary for the first
-         yypush_parse invocation since subsequent invocations don't overwrite
-         it before jumping to yyread_pushed_token.  */
-      yychar = yypushed_char;
-      yylval = yypushed_val;]b4_locations_if([[
-      yylloc = yypushed_loc;]])])[
-yyread_pushed_token:]])[
-      YYDPRINTF ((stderr, "Reading a token: "));]b4_push_if([b4_pure_if([[
-      yychar = yypushed_char;
-      if (yypushed_val)
-        yylval = *yypushed_val;]b4_locations_if([[
-      if (yypushed_loc)
-        yylloc = *yypushed_loc;]])])], [[
-      yychar = ]b4_lex[;]])[
-    }
-
-  if (yychar <= YYEOF)
-    {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yytoken = YYTRANSLATE (yychar);
-      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
-    }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)]b4_lac_if([[
-    {
-      YY_LAC_ESTABLISH;
-      goto yydefault;
-    }]], [[
-    goto yydefault;]])[
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yytable_value_is_error (yyn))
-        goto yyerrlab;]b4_lac_if([[
-      YY_LAC_ESTABLISH;]])[
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  /* Shift the lookahead token.  */
-  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
-
-  /* Discard the shifted token.  */
-  yychar = YYEMPTY;]b4_lac_if([[
-  YY_LAC_DISCARD ("shift");]])[
-
-  yystate = yyn;
-  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  *++yyvsp = yylval;
-  YY_IGNORE_MAYBE_UNINITIALIZED_END
-]b4_locations_if([  *++yylsp = yylloc;])[
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     '$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-]b4_locations_if(
-[[  /* Default location. */
-  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
-  yyerror_range[1] = yyloc;]])[
-  YY_REDUCE_PRINT (yyn);]b4_lac_if([[
-  {
-    int yychar_backup = yychar;
-    switch (yyn)
-      {
-]b4_user_actions[
-        default: break;
-      }
-    if (yychar_backup != yychar)
-      YY_LAC_DISCARD ("yychar change");
-  }]], [[
-  switch (yyn)
-    {
-      ]b4_user_actions[
-      default: break;
-    }]])[
-  /* User semantic actions sometimes alter yychar, and that requires
-     that yytoken be updated with the new translation.  We take the
-     approach of translating immediately before every use of yytoken.
-     One alternative is translating here after every semantic action,
-     but that translation would be missed if the semantic action invokes
-     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
-     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
-     incorrect destructor might then be invoked immediately.  In the
-     case of YYERROR or YYBACKUP, subsequent parser actions might lead
-     to an incorrect destructor call or verbose syntax error message
-     before the lookahead is translated.  */
-  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
-
-  YYPOPSTACK (yylen);
-  yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;]b4_locations_if([
-  *++yylsp = yyloc;])[
-
-  /* Now 'shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-  {
-    const int yylhs = yyr1[yyn] - YYNTOKENS;
-    const int yyi = yypgoto[yylhs] + *yyssp;
-    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
-               ? yytable[yyi]
-               : yydefgoto[yylhs]);
-  }
-
-  goto yynewstate;
-
-
-/*--------------------------------------.
-| yyerrlab -- here on detecting error.  |
-`--------------------------------------*/
-yyerrlab:
-  /* Make sure we have latest lookahead translation.  See comments at
-     user semantic actions for why this is necessary.  */
-  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
-
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if ! YYERROR_VERBOSE
-      yyerror (]b4_yyerror_args[YY_("syntax error"));
-#else
-# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \]b4_lac_if([[
-                                        yyesa, &yyes, &yyes_capacity, \]])[
-                                        yyssp, yytoken)
-      {
-        char const *yymsgp = YY_("syntax error");
-        int yysyntax_error_status;]b4_lac_if([[
-        if (yychar != YYEMPTY)
-          YY_LAC_ESTABLISH;]])[
-        yysyntax_error_status = YYSYNTAX_ERROR;
-        if (yysyntax_error_status == 0)
-          yymsgp = yymsg;
-        else if (yysyntax_error_status == 1)
-          {
-            if (yymsg != yymsgbuf)
-              YYSTACK_FREE (yymsg);
-            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
-            if (!yymsg)
-              {
-                yymsg = yymsgbuf;
-                yymsg_alloc = sizeof yymsgbuf;
-                yysyntax_error_status = 2;
-              }
-            else
-              {
-                yysyntax_error_status = YYSYNTAX_ERROR;
-                yymsgp = yymsg;
-              }
-          }
-        yyerror (]b4_yyerror_args[yymsgp);
-        if (yysyntax_error_status == 2)
-          goto yyexhaustedlab;
-      }
-# undef YYSYNTAX_ERROR
-#endif
-    }
-
-]b4_locations_if([[  yyerror_range[1] = yylloc;]])[
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse lookahead token after an
-         error, discard it.  */
-
-      if (yychar <= YYEOF)
-        {
-          /* Return failure if at end of input.  */
-          if (yychar == YYEOF)
-            YYABORT;
-        }
-      else
-        {
-          yydestruct ("Error: discarding",
-                      yytoken, &yylval]b4_locations_if([, &yylloc])[]b4_user_args[);
-          yychar = YYEMPTY;
-        }
-    }
-
-  /* Else will try to reuse lookahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-  /* Pacify compilers when the user code never invokes YYERROR and the
-     label yyerrorlab therefore never appears in user code.  */
-  if (0)
-    YYERROR;
-
-  /* Do not reclaim the symbols of the rule whose action triggered
-     this YYERROR.  */
-  YYPOPSTACK (yylen);
-  yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
-
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (!yypact_value_is_default (yyn))
-        {
-          yyn += YYTERROR;
-          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-            {
-              yyn = yytable[yyn];
-              if (0 < yyn)
-                break;
-            }
-        }
-
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
-        YYABORT;
-
-]b4_locations_if([[      yyerror_range[1] = *yylsp;]])[
-      yydestruct ("Error: popping",
-                  yystos[yystate], yyvsp]b4_locations_if([, yylsp])[]b4_user_args[);
-      YYPOPSTACK (1);
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }]b4_lac_if([[
-
-  /* If the stack popping above didn't lose the initial context for the
-     current lookahead token, the shift below will for sure.  */
-  YY_LAC_DISCARD ("error recovery");]])[
-
-  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  *++yyvsp = yylval;
-  YY_IGNORE_MAYBE_UNINITIALIZED_END
-]b4_locations_if([[
-  yyerror_range[2] = yylloc;
-  /* Using YYLLOC is tempting, but would change the location of
-     the lookahead.  YYLOC is available though.  */
-  YYLLOC_DEFAULT (yyloc, yyerror_range, 2);
-  *++yylsp = yyloc;]])[
-
-  /* Shift the error token.  */
-  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-
-#if ]b4_lac_if([[1]], [[!defined yyoverflow || YYERROR_VERBOSE]])[
-/*-------------------------------------------------.
-| yyexhaustedlab -- memory exhaustion comes here.  |
-`-------------------------------------------------*/
-yyexhaustedlab:
-  yyerror (]b4_yyerror_args[YY_("memory exhausted"));
-  yyresult = 2;
-  /* Fall through.  */
-#endif
-
-
-/*-----------------------------------------------------.
-| yyreturn -- parsing is finished, return the result.  |
-`-----------------------------------------------------*/
-yyreturn:
-  if (yychar != YYEMPTY)
-    {
-      /* Make sure we have latest lookahead translation.  See comments at
-         user semantic actions for why this is necessary.  */
-      yytoken = YYTRANSLATE (yychar);
-      yydestruct ("Cleanup: discarding lookahead",
-                  yytoken, &yylval]b4_locations_if([, &yylloc])[]b4_user_args[);
-    }
-  /* Do not reclaim the symbols of the rule whose action triggered
-     this YYABORT or YYACCEPT.  */
-  YYPOPSTACK (yylen);
-  YY_STACK_PRINT (yyss, yyssp);
-  while (yyssp != yyss)
-    {
-      yydestruct ("Cleanup: popping",
-                  yystos[*yyssp], yyvsp]b4_locations_if([, yylsp])[]b4_user_args[);
-      YYPOPSTACK (1);
-    }
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif]b4_lac_if([[
-  if (yyes != yyesa)
-    YYSTACK_FREE (yyes);]])b4_push_if([[
-  yyps->yynew = 1;
-
-
-/*-----------------------------------------.
-| yypushreturn -- ask for the next token.  |
-`-----------------------------------------*/
-yypushreturn:]])[
-#if YYERROR_VERBOSE
-  if (yymsg != yymsgbuf)
-    YYSTACK_FREE (yymsg);
-#endif
-  return yyresult;
-}
-]b4_epilogue[]dnl
-b4_output_end
-
-b4_defines_if([[
-]b4_output_begin([b4_spec_defines_file])[
-]b4_copyright([Bison interface for Yacc-like parsers in C])[
-]b4_disclaimer[
-]b4_shared_declarations[
-]b4_output_end[
-]])# b4_defines_if
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/update_flex_bison_binaries.py b/Source/ThirdParty/ANGLE/tools/flex-bison/update_flex_bison_binaries.py
deleted file mode 100755
index 99c002b04e7..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/update_flex_bison_binaries.py
+++ /dev/null
@@ -1,69 +0,0 @@
-#!/usr/bin/python2
-#
-# Copyright 2019 The ANGLE Project Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-#
-# update_flex_bison_binaries.py:
-#   Helper script to update the version of flex and bison in cloud storage.
-#   These binaries are used to generate the ANGLE translator's lexer and parser.
-#   This script relies on flex and bison binaries to be externally built which
-#   is expected to be a rare operation. It currently only works on Windows and
-#   Linux. It also will update the hashes stored in the tree. For more info see
-#   README.md in this folder.
-
-import os
-import platform
-import shutil
-import sys
-
-sys.path.append('tools/')
-import angle_tools
-
-
-def main():
-    if angle_tools.is_linux:
-        subdir = 'linux'
-        files = ['flex', 'bison']
-    elif angle_tools.is_windows:
-        subdir = 'windows'
-        files = [
-            'flex.exe', 'bison.exe', 'm4.exe', 'msys-2.0.dll', 'msys-iconv-2.dll',
-            'msys-intl-8.dll'
-        ]
-    else:
-        print('Script must be run on Linux or Windows.')
-        return 1
-
-    files = [os.path.join(sys.path[0], subdir, f) for f in files]
-
-    # Step 1: Upload to cloud storage
-    if not angle_tools.upload_to_google_storage('angle-flex-bison', files):
-        print('Error upload to cloud storage')
-        return 1
-
-    # Step 2: Stage new SHA to git
-    if not angle_tools.stage_google_storage_sha1(files):
-        print('Error running git add')
-        return 2
-
-    print('')
-    print('The updated SHA has been staged for commit. Please commit and upload.')
-    print('Suggested commit message (please indicate flex/bison versions):')
-    print('----------------------------')
-    print('')
-    print('Update flex and bison binaries for %s.' % platform.system())
-    print('')
-    print('These binaries were updated using %s.' % os.path.basename(__file__))
-    print('Please see instructions in tools/flex-bison/README.md.')
-    print('')
-    print('flex is at version TODO.')
-    print('bison is at version TODO.')
-    print('')
-    print('Bug: None')
-
-    return 0
-
-
-if __name__ == '__main__':
-    sys.exit(main())
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/windows/bison.exe.sha1 b/Source/ThirdParty/ANGLE/tools/flex-bison/windows/bison.exe.sha1
deleted file mode 100644
index 8cb5f4fb5bb..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/windows/bison.exe.sha1
+++ /dev/null
@@ -1 +0,0 @@
-4a6e1dced61dab2fcd828edbfbfa7eb0215cf2a4
\ No newline at end of file
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/windows/flex.exe.sha1 b/Source/ThirdParty/ANGLE/tools/flex-bison/windows/flex.exe.sha1
deleted file mode 100644
index faa78edcafe..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/windows/flex.exe.sha1
+++ /dev/null
@@ -1 +0,0 @@
-bc50b3b6e84a30940aa1223f692c9f1fc9bedbf9
\ No newline at end of file
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/windows/m4.exe.sha1 b/Source/ThirdParty/ANGLE/tools/flex-bison/windows/m4.exe.sha1
deleted file mode 100644
index 5643dfb3b05..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/windows/m4.exe.sha1
+++ /dev/null
@@ -1 +0,0 @@
-06836e45b05d597d56b74febe3bcfd76e80ef8f8
\ No newline at end of file
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/windows/msys-2.0.dll.sha1 b/Source/ThirdParty/ANGLE/tools/flex-bison/windows/msys-2.0.dll.sha1
deleted file mode 100644
index 98352c74635..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/windows/msys-2.0.dll.sha1
+++ /dev/null
@@ -1 +0,0 @@
-d0beab7ec77b25ac71bd2d3bf54f4efd39e3947f
\ No newline at end of file
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/windows/msys-iconv-2.dll.sha1 b/Source/ThirdParty/ANGLE/tools/flex-bison/windows/msys-iconv-2.dll.sha1
deleted file mode 100644
index f52bc4b42b9..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/windows/msys-iconv-2.dll.sha1
+++ /dev/null
@@ -1 +0,0 @@
-0579f1563e220d6121b65a5f4729919cd0cb6af9
\ No newline at end of file
diff --git a/Source/ThirdParty/ANGLE/tools/flex-bison/windows/msys-intl-8.dll.sha1 b/Source/ThirdParty/ANGLE/tools/flex-bison/windows/msys-intl-8.dll.sha1
deleted file mode 100644
index a73592113f1..00000000000
--- a/Source/ThirdParty/ANGLE/tools/flex-bison/windows/msys-intl-8.dll.sha1
+++ /dev/null
@@ -1 +0,0 @@
-212a9ef90e21a98ff57ca301a60c84cbeca7be28
\ No newline at end of file
diff --git a/include/platform/Platform.h b/include/platform/Platform.h
index b603ff9bad2..f4ec4f8837c 100644
--- a/include/platform/Platform.h
+++ b/include/platform/Platform.h
@@ -9,6 +9,7 @@
 #ifndef ANGLE_PLATFORM_H
 #define ANGLE_PLATFORM_H
 
+#include <stdlib.h>
 #include <stdint.h>
 #include <array>
 
diff --git a/src/common/PackedEnums.h b/src/common/PackedEnums.h
index bd5fc340dcc..63368e25dfe 100644
--- a/src/common/PackedEnums.h
+++ b/src/common/PackedEnums.h
@@ -83,10 +83,7 @@ class PackedEnumMap
         // We use a for loop instead of range-for to work around a limitation in MSVC.
         for (const InitPair *it = init.begin(); it != init.end(); ++it)
         {
-            // This horrible const_cast pattern is necessary to work around a constexpr limitation.
-            // See https://stackoverflow.com/q/34199774/ . Note that it should be fixed with C++17.
-            const_cast<T &>(const_cast<const Storage &>(
-                mPrivateData)[static_cast<UnderlyingType>(it->first)]) = it->second;
+            mPrivateData[static_cast<UnderlyingType>(it->first)] = it->second;
         }
     }
 
