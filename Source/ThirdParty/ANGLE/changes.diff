diff --git a/include/GLSLANG/ShaderLang.h b/include/GLSLANG/ShaderLang.h
index 1468bb146..2875c02ab 100644
--- a/include/GLSLANG/ShaderLang.h
+++ b/include/GLSLANG/ShaderLang.h
@@ -8,7 +8,7 @@
 
 #include <stddef.h>
 
-#include "KHR/khrplatform.h"
+#include "khrplatform.h"
 
 #include <array>
 #include <map>
diff --git a/include/GLSLANG/ShaderVars.h b/include/GLSLANG/ShaderVars.h
index 709428aeb..acd9c358f 100644
--- a/include/GLSLANG/ShaderVars.h
+++ b/include/GLSLANG/ShaderVars.h
@@ -281,10 +281,17 @@ struct WorkGroupSize
 {
     // Must have a trivial default constructor since it is used in YYSTYPE.
     WorkGroupSize() = default;
+#if defined(__clang__)
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wmissing-braces"
+#endif
     explicit constexpr WorkGroupSize(int initialSize)
         : localSizeQualifiers{initialSize, initialSize, initialSize}
     {
     }
+#if defined(__clang__)
+#pragma clang diagnostic pop
+#endif
 
     void fill(int fillValue);
     void setLocalSize(int localSizeX, int localSizeY, int localSizeZ);
diff --git a/include/KHR/khrplatform.h b/include/KHR/khrplatform.h
old mode 100755
new mode 100644
index 68fca4827..07b61b9bd
--- a/include/KHR/khrplatform.h
+++ b/include/KHR/khrplatform.h
@@ -282,4 +282,4 @@ typedef enum {
     KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = KHRONOS_MAX_ENUM
 } khronos_boolean_enum_t;
 
-#endif /* __khrplatform_h_ */
\ No newline at end of file
+#endif /* __khrplatform_h_ */
diff --git a/src/common/third_party/smhasher/src/PMurHash.cpp b/src/common/third_party/smhasher/src/PMurHash.cpp
index 071bc3153..2d608e97d 100644
--- a/src/common/third_party/smhasher/src/PMurHash.cpp
+++ b/src/common/third_party/smhasher/src/PMurHash.cpp
@@ -74,6 +74,12 @@ on big endian machines, or a byte-by-byte read if the endianess is unknown.
  * ROTL32(x,r)      Rotate x left by r bits
  */
 
+#if !defined(__BYTE_ORDER) && defined(__GNUC__)
+  #define __BIG_ENDIAN __ORDER_BIG_ENDIAN__
+  #define __LITTLE_ENDIAN __ORDER_LITTLE_ENDIAN__
+  #define __BYTE_ORDER __BYTE_ORDER__
+#endif
+
 /* Convention is to define __BYTE_ORDER == to one of these values */
 #if !defined(__BIG_ENDIAN)
   #define __BIG_ENDIAN 4321
@@ -84,7 +90,9 @@ on big endian machines, or a byte-by-byte read if the endianess is unknown.
 
 /* I386 */
 #if defined(_M_IX86) || defined(__i386__) || defined(__i386) || defined(i386)
-  #define __BYTE_ORDER __LITTLE_ENDIAN
+  #if !defined(__BYTE_ORDER)
+    #define __BYTE_ORDER __LITTLE_ENDIAN
+  #endif
   #define UNALIGNED_SAFE
 #endif
 
@@ -111,7 +119,14 @@ on big endian machines, or a byte-by-byte read if the endianess is unknown.
 /* Now find best way we can to READ_UINT32 */
 #if __BYTE_ORDER==__LITTLE_ENDIAN
   /* CPU endian matches murmurhash algorithm, so read 32-bit word directly */
+#if defined(__clang__)
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wcast-align"
+#endif
   #define READ_UINT32(ptr)   (*((uint32_t*)(ptr)))
+#if defined(__clang__)
+#pragma clang diagnostic pop
+#endif
 #elif __BYTE_ORDER==__BIG_ENDIAN
   /* TODO: Add additional cases below where a compiler provided bswap32 is available */
   #if defined(__GNUC__) && (__GNUC__>4 || (__GNUC__==4 && __GNUC_MINOR__>=3))
@@ -218,14 +233,28 @@ void PMurHash32_Process(uint32_t *ph1, uint32_t *pcarry, const void *key, int le
   switch(n) { /* how many bytes in c */
   case 0: /* c=[----]  w=[3210]  b=[3210]=w            c'=[----] */
     for( ; ptr < end ; ptr+=4) {
+#if defined(__clang__)
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wcast-align"
+#endif
       uint32_t k1 = READ_UINT32(ptr);
+#if defined(__clang__)
+#pragma clang diagnostic pop
+#endif
       DOBLOCK(h1, k1);
     }
     break;
   case 1: /* c=[0---]  w=[4321]  b=[3210]=c>>24|w<<8   c'=[4---] */
     for( ; ptr < end ; ptr+=4) {
       uint32_t k1 = c>>24;
+#if defined(__clang__)
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wcast-align"
+#endif
       c = READ_UINT32(ptr);
+#if defined(__clang__)
+#pragma clang diagnostic pop
+#endif
       k1 |= c<<8;
       DOBLOCK(h1, k1);
     }
@@ -233,7 +262,14 @@ void PMurHash32_Process(uint32_t *ph1, uint32_t *pcarry, const void *key, int le
   case 2: /* c=[10--]  w=[5432]  b=[3210]=c>>16|w<<16  c'=[54--] */
     for( ; ptr < end ; ptr+=4) {
       uint32_t k1 = c>>16;
+#if defined(__clang__)
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wcast-align"
+#endif
       c = READ_UINT32(ptr);
+#if defined(__clang__)
+#pragma clang diagnostic pop
+#endif
       k1 |= c<<16;
       DOBLOCK(h1, k1);
     }
@@ -241,7 +277,14 @@ void PMurHash32_Process(uint32_t *ph1, uint32_t *pcarry, const void *key, int le
   case 3: /* c=[210-]  w=[6543]  b=[3210]=c>>8|w<<24   c'=[654-] */
     for( ; ptr < end ; ptr+=4) {
       uint32_t k1 = c>>8;
+#if defined(__clang__)
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wcast-align"
+#endif
       c = READ_UINT32(ptr);
+#if defined(__clang__)
+#pragma clang diagnostic pop
+#endif
       k1 |= c<<24;
       DOBLOCK(h1, k1);
     }
diff --git a/src/compiler/preprocessor/ExpressionParser.cpp b/src/compiler/preprocessor/ExpressionParser.cpp
index ede334619..c0f8b9c97 100644
--- a/src/compiler/preprocessor/ExpressionParser.cpp
+++ b/src/compiler/preprocessor/ExpressionParser.cpp
@@ -1,5 +1,7 @@
 /* A Bison parser, made by GNU Bison 3.0.4.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
diff --git a/src/compiler/preprocessor/Tokenizer.cpp b/src/compiler/preprocessor/Tokenizer.cpp
index d8a9b9a12..d7fad68f1 100644
--- a/src/compiler/preprocessor/Tokenizer.cpp
+++ b/src/compiler/preprocessor/Tokenizer.cpp
@@ -1148,7 +1148,7 @@ static void yy_flex_strncpy ( char *, const char *, int , yyscan_t yyscanner);
 static int yy_flex_strlen ( const char * , yyscan_t yyscanner);
 #endif
 
-#ifndef YY_NO_INPUT
+#if 0 // #ifndef YY_NO_INPUT
 #ifdef __cplusplus
 static int yyinput ( yyscan_t yyscanner );
 #else
@@ -2049,7 +2049,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 
 #endif
 
-#ifndef YY_NO_INPUT
+#if 0 // #ifndef YY_NO_INPUT
 #ifdef __cplusplus
     static int yyinput (yyscan_t yyscanner)
 #else
diff --git a/src/compiler/translator/ParseContext.cpp b/src/compiler/translator/ParseContext.cpp
index c97f91d78..d0a4f6aeb 100644
--- a/src/compiler/translator/ParseContext.cpp
+++ b/src/compiler/translator/ParseContext.cpp
@@ -3240,8 +3240,11 @@ TIntermFunctionPrototype *TParseContext::addFunctionPrototypeDeclaration(
     }
     function->setHasPrototypeDeclaration();
 
+    // WebKit note: We currently pass true instead of false for the last parameter
+    // here because some compilers have an issue with nameless parameters in function
+    // declarations.
     TIntermFunctionPrototype *prototype =
-        createPrototypeNodeFromFunction(*function, location, false);
+        createPrototypeNodeFromFunction(*function, location, true);
 
     symbolTable.pop();
 
diff --git a/src/compiler/translator/TranslatorHLSL.h b/src/compiler/translator/TranslatorHLSL.h
index d7005a603..e8436e98e 100644
--- a/src/compiler/translator/TranslatorHLSL.h
+++ b/src/compiler/translator/TranslatorHLSL.h
@@ -16,7 +16,7 @@ class TranslatorHLSL : public TCompiler
 {
   public:
     TranslatorHLSL(sh::GLenum type, ShShaderSpec spec, ShShaderOutput output);
-    TranslatorHLSL *getAsTranslatorHLSL() override { return this; }
+    TranslatorHLSL *getAsTranslatorHLSL() { return this; }
 
     bool hasUniformBlock(const std::string &interfaceBlockName) const;
     unsigned int getUniformBlockRegister(const std::string &interfaceBlockName) const;
diff --git a/src/compiler/translator/glslang_tab.cpp b/src/compiler/translator/glslang_tab.cpp
index ce4aacf40..14cd5360c 100644
--- a/src/compiler/translator/glslang_tab.cpp
+++ b/src/compiler/translator/glslang_tab.cpp
@@ -1,5 +1,7 @@
 /* A Bison parser, made by GNU Bison 3.0.4.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
diff --git a/src/compiler/translator/glslang_tab.h b/src/compiler/translator/glslang_tab.h
index 1f5308551..cb43a46df 100644
--- a/src/compiler/translator/glslang_tab.h
+++ b/src/compiler/translator/glslang_tab.h
@@ -1,5 +1,7 @@
 /* A Bison parser, made by GNU Bison 3.0.4.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of the BSD license. */
+
 /* Bison interface for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
diff --git a/src/libANGLE/MemoryProgramCache.cpp b/src/libANGLE/MemoryProgramCache.cpp
index 9eec12e3e..2a9c6836a 100644
--- a/src/libANGLE/MemoryProgramCache.cpp
+++ b/src/libANGLE/MemoryProgramCache.cpp
@@ -234,7 +234,10 @@ LinkResult MemoryProgramCache::Deserialize(const Context *context,
 
     static_assert(MAX_VERTEX_ATTRIBS <= sizeof(unsigned long) * 8,
                   "Too many vertex attribs for mask");
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wconversion"
     state->mActiveAttribLocationsMask = stream.readInt<unsigned long>();
+#pragma clang diagnostic pop
 
     unsigned int attribCount = stream.readInt<unsigned int>();
     ASSERT(state->mAttributes.empty());
@@ -408,7 +411,10 @@ LinkResult MemoryProgramCache::Deserialize(const Context *context,
     state->mAtomicCounterUniformRange   = RangeUI(atomicCounterRangeLow, atomicCounterRangeHigh);
 
     static_assert(SHADER_TYPE_MAX <= sizeof(unsigned long) * 8, "Too many shader types");
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wconversion"
     state->mLinkedShaderStages = stream.readInt<unsigned long>();
+#pragma clang diagnostic pop
 
     return program->getImplementation()->load(context, infoLog, &stream);
 }
diff --git a/src/libANGLE/Platform.cpp b/src/libANGLE/Platform.cpp
index 702091624..c51289423 100644
--- a/src/libANGLE/Platform.cpp
+++ b/src/libANGLE/Platform.cpp
@@ -15,7 +15,14 @@
 namespace
 {
 // TODO(jmadill): Make methods owned by egl::Display.
-angle::PlatformMethods g_platformMethods;
+#if defined(__clang__)
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wglobal-constructors"
+#endif
+    angle::PlatformMethods g_platformMethods;
+#if defined(__clang__)
+#pragma clang diagnostic pop
+#endif
 }  // anonymous namespace
 
 angle::PlatformMethods::PlatformMethods()
diff --git a/src/tests/compiler_tests/QualificationOrder_test.cpp b/src/tests/compiler_tests/QualificationOrder_test.cpp
index c0249dbb9..c82acffd7 100644
--- a/src/tests/compiler_tests/QualificationOrder_test.cpp
+++ b/src/tests/compiler_tests/QualificationOrder_test.cpp
@@ -429,7 +429,7 @@ TEST_F(QualificationOrderFragmentShaderTest, InvalidFunctionParametersInvariant)
         "}\n"
         "void main()\n"
         "{\n"
-        "	gl_FragColor = vec4(foo0(value));\n"
+        "   gl_FragColor = vec4(foo0(value));\n"
         "}\n";
 
     if (compile(shaderString))
@@ -449,7 +449,7 @@ TEST_F(QualificationOrderFragmentShaderTest, InvalidFunctionParametersAttribute)
         "}\n"
         "void main()\n"
         "{\n"
-        "	gl_FragColor = vec4(foo0(value));\n"
+        "   gl_FragColor = vec4(foo0(value));\n"
         "}\n";
 
     if (compile(shaderString))
@@ -469,7 +469,7 @@ TEST_F(QualificationOrderFragmentShaderTest, InvalidFunctionParametersVarying)
         "}\n"
         "void main()\n"
         "{\n"
-        "	gl_FragColor = vec4(foo0(value));\n"
+        "   gl_FragColor = vec4(foo0(value));\n"
         "}\n";
 
     if (compile(shaderString))
@@ -491,7 +491,7 @@ TEST_F(QualificationOrderFragmentShaderTest, InvalidFunctionParametersLayout)
         "out vec4 colorOUT;\n"
         "void main()\n"
         "{\n"
-        "	colorOUT = vec4(foo0(value));\n"
+        "   colorOUT = vec4(foo0(value));\n"
         "}\n";
 
     if (compile(shaderString))
@@ -513,7 +513,7 @@ TEST_F(QualificationOrderFragmentShaderTest, InvalidFunctionParametersCentroidIn
         "out vec4 colorOUT;\n"
         "void main()\n"
         "{\n"
-        "	colorOUT = vec4(foo0(value));\n"
+        "   colorOUT = vec4(foo0(value));\n"
         "}\n";
 
     if (compile(shaderString))
@@ -535,7 +535,7 @@ TEST_F(QualificationOrderFragmentShaderTest, InvalidFunctionParametersFlatIn)
         "out vec4 colorOUT;\n"
         "void main()\n"
         "{\n"
-        "	colorOUT = vec4(foo0(value));\n"
+        "   colorOUT = vec4(foo0(value));\n"
         "}\n";
 
     if (compile(shaderString))
diff --git a/src/tests/deqp_support/es2fShaderMatrixTests.cpp b/src/tests/deqp_support/es2fShaderMatrixTests.cpp
index 9feb4dcfa..54d8474fd 100644
--- a/src/tests/deqp_support/es2fShaderMatrixTests.cpp
+++ b/src/tests/deqp_support/es2fShaderMatrixTests.cpp
@@ -69,77 +69,77 @@ using tcu::Mat4;
 // Uniform / constant values for tests.
 // \note Input1 should not contain 0 components as it is used as divisor in div cases.
 // \todo [2012-02-14 pyry] Make these dynamic.
-static const float	s_constInFloat[2]	= { 0.5f, -0.2f };
-static const Vec2	s_constInVec2[2]	= { Vec2(1.2f, 0.5f), Vec2(0.5f, 1.0f) };
-static const Vec3	s_constInVec3[2]	= { Vec3(1.1f, 0.1f, 0.5f), Vec3(-0.2f, 0.5f, 0.8f) };
-static const Vec4	s_constInVec4[2]	= { Vec4(1.4f, 0.2f, -0.5f, 0.7f), Vec4(0.2f, -1.0f, 0.5f, 0.8f) };
+static const float  s_constInFloat[2]   = { 0.5f, -0.2f };
+static const Vec2   s_constInVec2[2]    = { Vec2(1.2f, 0.5f), Vec2(0.5f, 1.0f) };
+static const Vec3   s_constInVec3[2]    = { Vec3(1.1f, 0.1f, 0.5f), Vec3(-0.2f, 0.5f, 0.8f) };
+static const Vec4   s_constInVec4[2]    = { Vec4(1.4f, 0.2f, -0.5f, 0.7f), Vec4(0.2f, -1.0f, 0.5f, 0.8f) };
 
 static const float s_constInMat20[] = { 0.6f, -1.0f, 0.7f, 0.4f };
 static const float s_constInMat21[] = { -0.5f, -0.4f, 0.7f, -0.8f };
 
 static const float s_constInMat31[] =
 {
-	1.2f,  0.1f, -0.1f,
-	0.1f,  0.9f,  0.2f,
-	0.2f, -0.1f,  0.7f
+    1.2f,  0.1f, -0.1f,
+    0.1f,  0.9f,  0.2f,
+    0.2f, -0.1f,  0.7f
 };
 static const float s_constInMat41[] =
 {
-	 1.2f, -0.2f,  0.4f,  0.1f,
-	 0.1f,  0.8f, -0.1f, -0.2f,
-	-0.2f,  0.1f, -1.1f,  0.3f,
-	 0.1f,  0.2f,  0.3f,  0.9f
+     1.2f, -0.2f,  0.4f,  0.1f,
+     0.1f,  0.8f, -0.1f, -0.2f,
+    -0.2f,  0.1f, -1.1f,  0.3f,
+     0.1f,  0.2f,  0.3f,  0.9f
 };
 
-static const Mat2	s_constInMat2[2]	= { tcu::Mat2(s_constInMat20), tcu::Mat2(s_constInMat21) };
-static const Mat3	s_constInMat3[2]	= { tcu::translationMatrix(tcu::Vec2(0.2f, -0.3f)), tcu::Mat3(s_constInMat31) };
-static const Mat4	s_constInMat4[2]	= { tcu::translationMatrix(tcu::Vec3(0.2f, -0.3f, 0.15f)), tcu::Mat4(s_constInMat41) };
+static const Mat2   s_constInMat2[2]    = { tcu::Mat2(s_constInMat20), tcu::Mat2(s_constInMat21) };
+static const Mat3   s_constInMat3[2]    = { tcu::translationMatrix(tcu::Vec2(0.2f, -0.3f)), tcu::Mat3(s_constInMat31) };
+static const Mat4   s_constInMat4[2]    = { tcu::translationMatrix(tcu::Vec3(0.2f, -0.3f, 0.15f)), tcu::Mat4(s_constInMat41) };
 
 namespace MatrixCaseUtils
 {
 
 enum InputType
 {
-	INPUTTYPE_CONST = 0,
-	INPUTTYPE_UNIFORM,
-	INPUTTYPE_DYNAMIC,
+    INPUTTYPE_CONST = 0,
+    INPUTTYPE_UNIFORM,
+    INPUTTYPE_DYNAMIC,
 
-	INPUTTYPE_LAST
+    INPUTTYPE_LAST
 };
 
 struct ShaderInput
 {
-	ShaderInput (InputType inputType_, DataType dataType_, Precision precision_)
-		: inputType	(inputType_)
-		, dataType	(dataType_)
-		, precision	(precision_)
-	{
-	}
-
-	InputType		inputType;
-	DataType		dataType;
-	Precision		precision;
+    ShaderInput (InputType inputType_, DataType dataType_, Precision precision_)
+        : inputType (inputType_)
+        , dataType  (dataType_)
+        , precision (precision_)
+    {
+    }
+
+    InputType       inputType;
+    DataType        dataType;
+    Precision       precision;
 };
 
 enum MatrixOp
 {
-	OP_ADD = 0,
-	OP_SUB,
-	OP_MUL,
-	OP_DIV,
-	OP_COMP_MUL,
-	OP_UNARY_PLUS,
-	OP_NEGATION,
-	OP_PRE_INCREMENT,
-	OP_PRE_DECREMENT,
-	OP_POST_INCREMENT,
-	OP_POST_DECREMENT,
-	OP_ADD_INTO,
-	OP_SUBTRACT_FROM,
-	OP_MULTIPLY_INTO,
-	OP_DIVIDE_INTO,
-
-	OP_LAST
+    OP_ADD = 0,
+    OP_SUB,
+    OP_MUL,
+    OP_DIV,
+    OP_COMP_MUL,
+    OP_UNARY_PLUS,
+    OP_NEGATION,
+    OP_PRE_INCREMENT,
+    OP_PRE_DECREMENT,
+    OP_POST_INCREMENT,
+    OP_POST_DECREMENT,
+    OP_ADD_INTO,
+    OP_SUBTRACT_FROM,
+    OP_MULTIPLY_INTO,
+    OP_DIVIDE_INTO,
+
+    OP_LAST
 };
 
 // Type traits.
@@ -147,16 +147,16 @@ enum MatrixOp
 template <int DataT>
 struct TypeTraits;
 
-#define DECLARE_TYPE_TRAIT(DATATYPE, TYPE)	\
-template<>									\
-struct TypeTraits<DATATYPE> {				\
-	typedef TYPE Type;						\
+#define DECLARE_TYPE_TRAIT(DATATYPE, TYPE)  \
+template<>                                  \
+struct TypeTraits<DATATYPE> {               \
+    typedef TYPE Type;                      \
 }
 
-DECLARE_TYPE_TRAIT(TYPE_FLOAT,		float);
-DECLARE_TYPE_TRAIT(TYPE_FLOAT_VEC2,	tcu::Vec2);
-DECLARE_TYPE_TRAIT(TYPE_FLOAT_VEC3,	tcu::Vec3);
-DECLARE_TYPE_TRAIT(TYPE_FLOAT_VEC4,	tcu::Vec4);
+DECLARE_TYPE_TRAIT(TYPE_FLOAT,      float);
+DECLARE_TYPE_TRAIT(TYPE_FLOAT_VEC2, tcu::Vec2);
+DECLARE_TYPE_TRAIT(TYPE_FLOAT_VEC3, tcu::Vec3);
+DECLARE_TYPE_TRAIT(TYPE_FLOAT_VEC4, tcu::Vec4);
 DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT2, tcu::Mat2);
 DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT3, tcu::Mat3);
 DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT4, tcu::Mat4);
@@ -165,169 +165,169 @@ DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT4, tcu::Mat4);
 
 enum OperationType
 {
-	OPERATIONTYPE_BINARY_OPERATOR = 0,
-	OPERATIONTYPE_BINARY_FUNCTION,
-	OPERATIONTYPE_UNARY_PREFIX_OPERATOR,
-	OPERATIONTYPE_UNARY_POSTFIX_OPERATOR,
-	OPERATIONTYPE_ASSIGNMENT,
+    OPERATIONTYPE_BINARY_OPERATOR = 0,
+    OPERATIONTYPE_BINARY_FUNCTION,
+    OPERATIONTYPE_UNARY_PREFIX_OPERATOR,
+    OPERATIONTYPE_UNARY_POSTFIX_OPERATOR,
+    OPERATIONTYPE_ASSIGNMENT,
 
-	OPERATIONTYPE_LAST
+    OPERATIONTYPE_LAST
 };
 
 static const char* getOperationName (MatrixOp op)
 {
-	switch (op)
-	{
-		case OP_ADD:			return "+";
-		case OP_SUB:			return "-";
-		case OP_MUL:			return "*";
-		case OP_DIV:			return "/";
-		case OP_COMP_MUL:		return "matrixCompMult";
-		case OP_UNARY_PLUS:		return "+";
-		case OP_NEGATION:		return "-";
-		case OP_PRE_INCREMENT:	return "++";
-		case OP_PRE_DECREMENT:	return "--";
-		case OP_POST_INCREMENT:	return "++";
-		case OP_POST_DECREMENT:	return "--";
-		case OP_ADD_INTO:		return "+=";
-		case OP_SUBTRACT_FROM:	return "-=";
-		case OP_MULTIPLY_INTO:	return "*=";
-		case OP_DIVIDE_INTO:	return "/=";
-		default:
-			DE_ASSERT(DE_FALSE);
-			return "";
-	}
+    switch (op)
+    {
+        case OP_ADD:            return "+";
+        case OP_SUB:            return "-";
+        case OP_MUL:            return "*";
+        case OP_DIV:            return "/";
+        case OP_COMP_MUL:       return "matrixCompMult";
+        case OP_UNARY_PLUS:     return "+";
+        case OP_NEGATION:       return "-";
+        case OP_PRE_INCREMENT:  return "++";
+        case OP_PRE_DECREMENT:  return "--";
+        case OP_POST_INCREMENT: return "++";
+        case OP_POST_DECREMENT: return "--";
+        case OP_ADD_INTO:       return "+=";
+        case OP_SUBTRACT_FROM:  return "-=";
+        case OP_MULTIPLY_INTO:  return "*=";
+        case OP_DIVIDE_INTO:    return "/=";
+        default:
+            DE_ASSERT(DE_FALSE);
+            return "";
+    }
 }
 
 static OperationType getOperationType (MatrixOp op)
 {
-	switch (op)
-	{
-		case OP_ADD:			return OPERATIONTYPE_BINARY_OPERATOR;
-		case OP_SUB:			return OPERATIONTYPE_BINARY_OPERATOR;
-		case OP_MUL:			return OPERATIONTYPE_BINARY_OPERATOR;
-		case OP_DIV:			return OPERATIONTYPE_BINARY_OPERATOR;
-		case OP_COMP_MUL:		return OPERATIONTYPE_BINARY_FUNCTION;
-		case OP_UNARY_PLUS:		return OPERATIONTYPE_UNARY_PREFIX_OPERATOR;
-		case OP_NEGATION:		return OPERATIONTYPE_UNARY_PREFIX_OPERATOR;
-		case OP_PRE_INCREMENT:	return OPERATIONTYPE_UNARY_PREFIX_OPERATOR;
-		case OP_PRE_DECREMENT:	return OPERATIONTYPE_UNARY_PREFIX_OPERATOR;
-		case OP_POST_INCREMENT:	return OPERATIONTYPE_UNARY_POSTFIX_OPERATOR;
-		case OP_POST_DECREMENT:	return OPERATIONTYPE_UNARY_POSTFIX_OPERATOR;
-		case OP_ADD_INTO:		return OPERATIONTYPE_ASSIGNMENT;
-		case OP_SUBTRACT_FROM:	return OPERATIONTYPE_ASSIGNMENT;
-		case OP_MULTIPLY_INTO:	return OPERATIONTYPE_ASSIGNMENT;
-		case OP_DIVIDE_INTO:	return OPERATIONTYPE_ASSIGNMENT;
-		default:
-			DE_ASSERT(DE_FALSE);
-			return OPERATIONTYPE_LAST;
-	}
+    switch (op)
+    {
+        case OP_ADD:            return OPERATIONTYPE_BINARY_OPERATOR;
+        case OP_SUB:            return OPERATIONTYPE_BINARY_OPERATOR;
+        case OP_MUL:            return OPERATIONTYPE_BINARY_OPERATOR;
+        case OP_DIV:            return OPERATIONTYPE_BINARY_OPERATOR;
+        case OP_COMP_MUL:       return OPERATIONTYPE_BINARY_FUNCTION;
+        case OP_UNARY_PLUS:     return OPERATIONTYPE_UNARY_PREFIX_OPERATOR;
+        case OP_NEGATION:       return OPERATIONTYPE_UNARY_PREFIX_OPERATOR;
+        case OP_PRE_INCREMENT:  return OPERATIONTYPE_UNARY_PREFIX_OPERATOR;
+        case OP_PRE_DECREMENT:  return OPERATIONTYPE_UNARY_PREFIX_OPERATOR;
+        case OP_POST_INCREMENT: return OPERATIONTYPE_UNARY_POSTFIX_OPERATOR;
+        case OP_POST_DECREMENT: return OPERATIONTYPE_UNARY_POSTFIX_OPERATOR;
+        case OP_ADD_INTO:       return OPERATIONTYPE_ASSIGNMENT;
+        case OP_SUBTRACT_FROM:  return OPERATIONTYPE_ASSIGNMENT;
+        case OP_MULTIPLY_INTO:  return OPERATIONTYPE_ASSIGNMENT;
+        case OP_DIVIDE_INTO:    return OPERATIONTYPE_ASSIGNMENT;
+        default:
+            DE_ASSERT(DE_FALSE);
+            return OPERATIONTYPE_LAST;
+    }
 }
 
 enum TestMatrixType
 {
-	TESTMATRIXTYPE_DEFAULT = 0,
-	TESTMATRIXTYPE_NEGATED,
-	TESTMATRIXTYPE_INCREMENTED,
-	TESTMATRIXTYPE_DECREMENTED,
+    TESTMATRIXTYPE_DEFAULT = 0,
+    TESTMATRIXTYPE_NEGATED,
+    TESTMATRIXTYPE_INCREMENTED,
+    TESTMATRIXTYPE_DECREMENTED,
 
-	TESTMATRIXTYPE_LAST
+    TESTMATRIXTYPE_LAST
 };
 
 static TestMatrixType getOperationTestMatrixType (MatrixOp op)
 {
-	switch(op)
-	{
-		case OP_ADD:			return TESTMATRIXTYPE_DEFAULT;
-		case OP_SUB:			return TESTMATRIXTYPE_DEFAULT;
-		case OP_MUL:			return TESTMATRIXTYPE_DEFAULT;
-		case OP_DIV:			return TESTMATRIXTYPE_DEFAULT;
-		case OP_COMP_MUL:		return TESTMATRIXTYPE_DEFAULT;
-		case OP_UNARY_PLUS:		return TESTMATRIXTYPE_DEFAULT;
-		case OP_NEGATION:		return TESTMATRIXTYPE_NEGATED;
-		case OP_PRE_INCREMENT:	return TESTMATRIXTYPE_NEGATED;
-		case OP_PRE_DECREMENT:	return TESTMATRIXTYPE_INCREMENTED;
-		case OP_POST_INCREMENT:	return TESTMATRIXTYPE_NEGATED;
-		case OP_POST_DECREMENT:	return TESTMATRIXTYPE_DEFAULT;
-		case OP_ADD_INTO:		return TESTMATRIXTYPE_DECREMENTED;
-		case OP_SUBTRACT_FROM:	return TESTMATRIXTYPE_DEFAULT;
-		case OP_MULTIPLY_INTO:	return TESTMATRIXTYPE_DEFAULT;
-		case OP_DIVIDE_INTO:	return TESTMATRIXTYPE_DEFAULT;
-
-		default:
-			DE_ASSERT(DE_FALSE);
-			return TESTMATRIXTYPE_LAST;
-	}
+    switch(op)
+    {
+        case OP_ADD:            return TESTMATRIXTYPE_DEFAULT;
+        case OP_SUB:            return TESTMATRIXTYPE_DEFAULT;
+        case OP_MUL:            return TESTMATRIXTYPE_DEFAULT;
+        case OP_DIV:            return TESTMATRIXTYPE_DEFAULT;
+        case OP_COMP_MUL:       return TESTMATRIXTYPE_DEFAULT;
+        case OP_UNARY_PLUS:     return TESTMATRIXTYPE_DEFAULT;
+        case OP_NEGATION:       return TESTMATRIXTYPE_NEGATED;
+        case OP_PRE_INCREMENT:  return TESTMATRIXTYPE_NEGATED;
+        case OP_PRE_DECREMENT:  return TESTMATRIXTYPE_INCREMENTED;
+        case OP_POST_INCREMENT: return TESTMATRIXTYPE_NEGATED;
+        case OP_POST_DECREMENT: return TESTMATRIXTYPE_DEFAULT;
+        case OP_ADD_INTO:       return TESTMATRIXTYPE_DECREMENTED;
+        case OP_SUBTRACT_FROM:  return TESTMATRIXTYPE_DEFAULT;
+        case OP_MULTIPLY_INTO:  return TESTMATRIXTYPE_DEFAULT;
+        case OP_DIVIDE_INTO:    return TESTMATRIXTYPE_DEFAULT;
+
+        default:
+            DE_ASSERT(DE_FALSE);
+            return TESTMATRIXTYPE_LAST;
+    }
 }
 
 static bool isOperationBinary (MatrixOp op)
 {
-	return getOperationType(op) == OPERATIONTYPE_BINARY_OPERATOR ||
-	       getOperationType(op) == OPERATIONTYPE_BINARY_FUNCTION ||
-	       getOperationType(op) == OPERATIONTYPE_ASSIGNMENT;
+    return getOperationType(op) == OPERATIONTYPE_BINARY_OPERATOR ||
+           getOperationType(op) == OPERATIONTYPE_BINARY_FUNCTION ||
+           getOperationType(op) == OPERATIONTYPE_ASSIGNMENT;
 }
 
 static bool isOperationMatrixScalar (MatrixOp op)
 {
-	return op == OP_ADD || op == OP_SUB || op == OP_MUL || op == OP_DIV;
+    return op == OP_ADD || op == OP_SUB || op == OP_MUL || op == OP_DIV;
 }
 
 static bool isOperationMatrixVector (MatrixOp op)
 {
-	return op == OP_MUL;
+    return op == OP_MUL;
 }
 
 static bool isOperationMatrixMatrix (MatrixOp op)
 {
-	return op == OP_ADD || op == OP_SUB || op == OP_MUL || op == OP_DIV || op == OP_COMP_MUL;
+    return op == OP_ADD || op == OP_SUB || op == OP_MUL || op == OP_DIV || op == OP_COMP_MUL;
 }
 
 static bool isOperationUnary (MatrixOp op)
 {
-	return  op == OP_UNARY_PLUS			||
-			op == OP_NEGATION			||
-			op == OP_PRE_INCREMENT		||
-			op == OP_PRE_DECREMENT		||
-			op == OP_POST_INCREMENT		||
-			op == OP_POST_DECREMENT;
+    return  op == OP_UNARY_PLUS         ||
+            op == OP_NEGATION           ||
+            op == OP_PRE_INCREMENT      ||
+            op == OP_PRE_DECREMENT      ||
+            op == OP_POST_INCREMENT     ||
+            op == OP_POST_DECREMENT;
 }
 
 static bool isOperationValueModifying (MatrixOp op)
 {
-	return  op == OP_PRE_INCREMENT		||
-			op == OP_PRE_DECREMENT		||
-			op == OP_POST_INCREMENT		||
-			op == OP_POST_DECREMENT;
+    return  op == OP_PRE_INCREMENT      ||
+            op == OP_PRE_DECREMENT      ||
+            op == OP_POST_INCREMENT     ||
+            op == OP_POST_DECREMENT;
 }
 
 static bool isOperationAssignment (MatrixOp op)
 {
-	return  op == OP_ADD_INTO		 ||
-			op == OP_SUBTRACT_FROM	 ||
-			op == OP_MULTIPLY_INTO	 ||
-			op == OP_DIVIDE_INTO;
+    return  op == OP_ADD_INTO        ||
+            op == OP_SUBTRACT_FROM   ||
+            op == OP_MULTIPLY_INTO   ||
+            op == OP_DIVIDE_INTO;
 }
 
 // Operation nature
 
 enum OperationNature
 {
-	OPERATIONNATURE_PURE = 0,
-	OPERATIONNATURE_MUTATING,
-	OPERATIONNATURE_ASSIGNMENT,
+    OPERATIONNATURE_PURE = 0,
+    OPERATIONNATURE_MUTATING,
+    OPERATIONNATURE_ASSIGNMENT,
 
-	OPERATIONNATURE_LAST
+    OPERATIONNATURE_LAST
 };
 
 static OperationNature getOperationNature (MatrixOp op)
 {
-	if (isOperationAssignment(op))
-		return OPERATIONNATURE_ASSIGNMENT;
+    if (isOperationAssignment(op))
+        return OPERATIONNATURE_ASSIGNMENT;
 
-	if (isOperationValueModifying(op))
-		return OPERATIONNATURE_MUTATING;
+    if (isOperationValueModifying(op))
+        return OPERATIONNATURE_MUTATING;
 
-	return OPERATIONNATURE_PURE;
+    return OPERATIONNATURE_PURE;
 }
 
 // Input value loader.
@@ -335,47 +335,47 @@ static OperationNature getOperationNature (MatrixOp op)
 template <int InputT, int DataT>
 typename TypeTraits<DataT>::Type getInputValue (const ShaderEvalContext& evalCtx, int inputNdx);
 
-template <> inline float		getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT>			(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInFloat[inputNdx];	}
-template <> inline tcu::Vec2	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_VEC2>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInVec2[inputNdx];	}
-template <> inline tcu::Vec3	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_VEC3>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInVec3[inputNdx];	}
-template <> inline tcu::Vec4	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_VEC4>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInVec4[inputNdx];	}
-template <> inline tcu::Mat2	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_MAT2>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInMat2[inputNdx];	}
-template <> inline tcu::Mat3	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_MAT3>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInMat3[inputNdx];	}
-template <> inline tcu::Mat4	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_MAT4>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInMat4[inputNdx];	}
+template <> inline float        getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT>         (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInFloat[inputNdx];  }
+template <> inline tcu::Vec2    getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_VEC2>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInVec2[inputNdx];   }
+template <> inline tcu::Vec3    getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_VEC3>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInVec3[inputNdx];   }
+template <> inline tcu::Vec4    getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_VEC4>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInVec4[inputNdx];   }
+template <> inline tcu::Mat2    getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_MAT2>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInMat2[inputNdx];   }
+template <> inline tcu::Mat3    getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_MAT3>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInMat3[inputNdx];   }
+template <> inline tcu::Mat4    getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_MAT4>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInMat4[inputNdx];   }
 
-template <> inline float		getInputValue<INPUTTYPE_DYNAMIC,	TYPE_FLOAT>			(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(inputNdx); return evalCtx.coords.x();					}
-template <> inline tcu::Vec2	getInputValue<INPUTTYPE_DYNAMIC,	TYPE_FLOAT_VEC2>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(inputNdx); return evalCtx.coords.swizzle(0, 1);			}
-template <> inline tcu::Vec3	getInputValue<INPUTTYPE_DYNAMIC,	TYPE_FLOAT_VEC3>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(inputNdx); return evalCtx.coords.swizzle(0, 1, 2);		}
-template <> inline tcu::Vec4	getInputValue<INPUTTYPE_DYNAMIC,	TYPE_FLOAT_VEC4>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(inputNdx); return evalCtx.coords.swizzle(0, 1, 2, 3);	}
+template <> inline float        getInputValue<INPUTTYPE_DYNAMIC,    TYPE_FLOAT>         (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(inputNdx); return evalCtx.coords.x();                   }
+template <> inline tcu::Vec2    getInputValue<INPUTTYPE_DYNAMIC,    TYPE_FLOAT_VEC2>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(inputNdx); return evalCtx.coords.swizzle(0, 1);         }
+template <> inline tcu::Vec3    getInputValue<INPUTTYPE_DYNAMIC,    TYPE_FLOAT_VEC3>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(inputNdx); return evalCtx.coords.swizzle(0, 1, 2);      }
+template <> inline tcu::Vec4    getInputValue<INPUTTYPE_DYNAMIC,    TYPE_FLOAT_VEC4>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(inputNdx); return evalCtx.coords.swizzle(0, 1, 2, 3);   }
 
 template <> inline tcu::Mat2 getInputValue<INPUTTYPE_DYNAMIC, TYPE_FLOAT_MAT2> (const ShaderEvalContext& evalCtx, int inputNdx)
 {
-	DE_UNREF(inputNdx); // Not used.
-	tcu::Mat2 m;
-	m.setColumn(0, evalCtx.in[0].swizzle(0,1));
-	m.setColumn(1, evalCtx.in[1].swizzle(0,1));
-	return m;
+    DE_UNREF(inputNdx); // Not used.
+    tcu::Mat2 m;
+    m.setColumn(0, evalCtx.in[0].swizzle(0,1));
+    m.setColumn(1, evalCtx.in[1].swizzle(0,1));
+    return m;
 }
 
 template <> inline tcu::Mat3 getInputValue<INPUTTYPE_DYNAMIC, TYPE_FLOAT_MAT3> (const ShaderEvalContext& evalCtx, int inputNdx)
 {
-	DE_UNREF(inputNdx); // Not used.
-	tcu::Mat3 m;
-	m.setColumn(0, evalCtx.in[0].swizzle(0,1,2));
-	m.setColumn(1, evalCtx.in[1].swizzle(0,1,2));
-	m.setColumn(2, evalCtx.in[2].swizzle(0,1,2));
-	return m;
+    DE_UNREF(inputNdx); // Not used.
+    tcu::Mat3 m;
+    m.setColumn(0, evalCtx.in[0].swizzle(0,1,2));
+    m.setColumn(1, evalCtx.in[1].swizzle(0,1,2));
+    m.setColumn(2, evalCtx.in[2].swizzle(0,1,2));
+    return m;
 }
 
 template <> inline tcu::Mat4 getInputValue<INPUTTYPE_DYNAMIC, TYPE_FLOAT_MAT4> (const ShaderEvalContext& evalCtx, int inputNdx)
 {
-	DE_UNREF(inputNdx); // Not used.
-	tcu::Mat4 m;
-	m.setColumn(0, evalCtx.in[0]);
-	m.setColumn(1, evalCtx.in[1]);
-	m.setColumn(2, evalCtx.in[2]);
-	m.setColumn(3, evalCtx.in[3]);
-	return m;
+    DE_UNREF(inputNdx); // Not used.
+    tcu::Mat4 m;
+    m.setColumn(0, evalCtx.in[0]);
+    m.setColumn(1, evalCtx.in[1]);
+    m.setColumn(2, evalCtx.in[2]);
+    m.setColumn(3, evalCtx.in[3]);
+    return m;
 }
 
 // Reduction from expression result to vec3.
@@ -392,13 +392,13 @@ inline tcu::Vec3 reduceToVec3 (const tcu::Mat4& value) { return value.getColumn(
 template <typename T, int Rows, int Cols>
 tcu::Matrix<T, Rows, Cols> matrixCompMult (const tcu::Matrix<T, Rows, Cols>& a, const tcu::Matrix<T, Rows, Cols>& b)
 {
-	tcu::Matrix<T, Rows, Cols> retVal;
+    tcu::Matrix<T, Rows, Cols> retVal;
 
-	for (int r = 0; r < Rows; ++r)
-		for (int c = 0; c < Cols; ++c)
-			retVal(r,c) = a(r,c) * b(r, c);
+    for (int r = 0; r < Rows; ++r)
+        for (int c = 0; c < Cols; ++c)
+            retVal(r,c) = a(r,c) * b(r, c);
 
-	return retVal;
+    return retVal;
 }
 
 // negate
@@ -406,13 +406,13 @@ tcu::Matrix<T, Rows, Cols> matrixCompMult (const tcu::Matrix<T, Rows, Cols>& a,
 template <typename T, int Rows, int Cols>
 tcu::Matrix<T, Rows, Cols> negate (const tcu::Matrix<T, Rows, Cols>& mat)
 {
-	tcu::Matrix<T, Rows, Cols> retVal;
+    tcu::Matrix<T, Rows, Cols> retVal;
 
-	for (int r = 0; r < Rows; ++r)
-		for (int c = 0; c < Cols; ++c)
-			retVal(r,c) = -mat(r, c);
+    for (int r = 0; r < Rows; ++r)
+        for (int c = 0; c < Cols; ++c)
+            retVal(r,c) = -mat(r, c);
 
-	return retVal;
+    return retVal;
 }
 
 // increment/decrement
@@ -420,25 +420,25 @@ tcu::Matrix<T, Rows, Cols> negate (const tcu::Matrix<T, Rows, Cols>& mat)
 template <typename T, int Rows, int Cols>
 tcu::Matrix<T, Rows, Cols> increment (const tcu::Matrix<T, Rows, Cols>& mat)
 {
-	tcu::Matrix<T, Rows, Cols> retVal;
+    tcu::Matrix<T, Rows, Cols> retVal;
 
-	for (int r = 0; r < Rows; ++r)
-		for (int c = 0; c < Cols; ++c)
-			retVal(r,c) = mat(r, c) + 1.0f;
+    for (int r = 0; r < Rows; ++r)
+        for (int c = 0; c < Cols; ++c)
+            retVal(r,c) = mat(r, c) + 1.0f;
 
-	return retVal;
+    return retVal;
 }
 
 template <typename T, int Rows, int Cols>
 tcu::Matrix<T, Rows, Cols> decrement (const tcu::Matrix<T, Rows, Cols>& mat)
 {
-	tcu::Matrix<T, Rows, Cols> retVal;
+    tcu::Matrix<T, Rows, Cols> retVal;
 
-	for (int r = 0; r < Rows; ++r)
-		for (int c = 0; c < Cols; ++c)
-			retVal(r,c) = mat(r, c) - 1.0f;
+    for (int r = 0; r < Rows; ++r)
+        for (int c = 0; c < Cols; ++c)
+            retVal(r,c) = mat(r, c) - 1.0f;
 
-	return retVal;
+    return retVal;
 }
 
 // Evaluator template.
@@ -449,244 +449,244 @@ struct Evaluator;
 template <int In0Type, int In0DataType, int In1Type, int In1DataType>
 struct Evaluator<OP_ADD, In0Type, In0DataType, In1Type, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx)
-	{
-		evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0) + getInputValue<In1Type, In1DataType>(evalCtx, 1));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx)
+    {
+        evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0) + getInputValue<In1Type, In1DataType>(evalCtx, 1));
+    }
 };
 
 template <int In0Type, int In0DataType, int In1Type, int In1DataType>
 struct Evaluator<OP_SUB, In0Type, In0DataType, In1Type, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx)
-	{
-		evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0) - getInputValue<In1Type, In1DataType>(evalCtx, 1));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx)
+    {
+        evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0) - getInputValue<In1Type, In1DataType>(evalCtx, 1));
+    }
 };
 
 template <int In0Type, int In0DataType, int In1Type, int In1DataType>
 struct Evaluator<OP_MUL, In0Type, In0DataType, In1Type, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx)
-	{
-		evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0) * getInputValue<In1Type, In1DataType>(evalCtx, 1));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx)
+    {
+        evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0) * getInputValue<In1Type, In1DataType>(evalCtx, 1));
+    }
 };
 
 template <int In0Type, int In0DataType, int In1Type, int In1DataType>
 struct Evaluator<OP_DIV, In0Type, In0DataType, In1Type, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx)
-	{
-		evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0) / getInputValue<In1Type, In1DataType>(evalCtx, 1));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx)
+    {
+        evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0) / getInputValue<In1Type, In1DataType>(evalCtx, 1));
+    }
 };
 
 template <int In0Type, int In0DataType, int In1Type, int In1DataType>
 struct Evaluator<OP_COMP_MUL, In0Type, In0DataType, In1Type, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx)
-	{
-		evalCtx.color.xyz() = reduceToVec3(matrixCompMult(getInputValue<In0Type, In0DataType>(evalCtx, 0), getInputValue<In1Type, In1DataType>(evalCtx, 1)));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx)
+    {
+        evalCtx.color.xyz() = reduceToVec3(matrixCompMult(getInputValue<In0Type, In0DataType>(evalCtx, 0), getInputValue<In1Type, In1DataType>(evalCtx, 1)));
+    }
 };
 
 template <int In0Type, int In0DataType, int In1Type, int In1DataType>
 struct Evaluator<OP_UNARY_PLUS, In0Type, In0DataType, In1Type, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx)
-	{
-		evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx)
+    {
+        evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0));
+    }
 };
 
 template <int In0Type, int In0DataType, int In1Type, int In1DataType>
 struct Evaluator<OP_NEGATION, In0Type, In0DataType, In1Type, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx)
-	{
-		evalCtx.color.xyz() = reduceToVec3(negate(getInputValue<In0Type, In0DataType>(evalCtx, 0)));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx)
+    {
+        evalCtx.color.xyz() = reduceToVec3(negate(getInputValue<In0Type, In0DataType>(evalCtx, 0)));
+    }
 };
 
 template <int In0Type, int In0DataType, int In1Type, int In1DataType>
 struct Evaluator<OP_PRE_INCREMENT, In0Type, In0DataType, In1Type, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx)
-	{
-		// modifying reduction: sum modified value too
-		evalCtx.color.xyz() = reduceToVec3(increment(getInputValue<In0Type, In0DataType>(evalCtx, 0))) + reduceToVec3(increment(getInputValue<In0Type, In0DataType>(evalCtx, 0)));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx)
+    {
+        // modifying reduction: sum modified value too
+        evalCtx.color.xyz() = reduceToVec3(increment(getInputValue<In0Type, In0DataType>(evalCtx, 0))) + reduceToVec3(increment(getInputValue<In0Type, In0DataType>(evalCtx, 0)));
+    }
 };
 
 template <int In0Type, int In0DataType, int In1Type, int In1DataType>
 struct Evaluator<OP_PRE_DECREMENT, In0Type, In0DataType, In1Type, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx)
-	{
-		// modifying reduction: sum modified value too
-		evalCtx.color.xyz() = reduceToVec3(decrement(getInputValue<In0Type, In0DataType>(evalCtx, 0))) + reduceToVec3(decrement(getInputValue<In0Type, In0DataType>(evalCtx, 0)));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx)
+    {
+        // modifying reduction: sum modified value too
+        evalCtx.color.xyz() = reduceToVec3(decrement(getInputValue<In0Type, In0DataType>(evalCtx, 0))) + reduceToVec3(decrement(getInputValue<In0Type, In0DataType>(evalCtx, 0)));
+    }
 };
 
 template <int In0Type, int In0DataType, int In1Type, int In1DataType>
 struct Evaluator<OP_POST_INCREMENT, In0Type, In0DataType, In1Type, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx)
-	{
-		// modifying reduction: sum modified value too
-		evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0)) + reduceToVec3(increment(getInputValue<In0Type, In0DataType>(evalCtx, 0)));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx)
+    {
+        // modifying reduction: sum modified value too
+        evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0)) + reduceToVec3(increment(getInputValue<In0Type, In0DataType>(evalCtx, 0)));
+    }
 };
 
 template <int In0Type, int In0DataType, int In1Type, int In1DataType>
 struct Evaluator<OP_POST_DECREMENT, In0Type, In0DataType, In1Type, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx)
-	{
-		// modifying reduction: sum modified value too
-		evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0)) + reduceToVec3(decrement(getInputValue<In0Type, In0DataType>(evalCtx, 0)));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx)
+    {
+        // modifying reduction: sum modified value too
+        evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0)) + reduceToVec3(decrement(getInputValue<In0Type, In0DataType>(evalCtx, 0)));
+    }
 };
 
 template <int In0Type, int In0DataType, int In1Type, int In1DataType>
 struct Evaluator<OP_ADD_INTO, In0Type, In0DataType, In1Type, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx)
-	{
-		evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0) + getInputValue<In1Type, In1DataType>(evalCtx, 1));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx)
+    {
+        evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0) + getInputValue<In1Type, In1DataType>(evalCtx, 1));
+    }
 };
 
 template <int In0Type, int In0DataType, int In1Type, int In1DataType>
 struct Evaluator<OP_SUBTRACT_FROM, In0Type, In0DataType, In1Type, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx)
-	{
-		evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0) - getInputValue<In1Type, In1DataType>(evalCtx, 1));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx)
+    {
+        evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0) - getInputValue<In1Type, In1DataType>(evalCtx, 1));
+    }
 };
 
 template <int In0Type, int In0DataType, int In1Type, int In1DataType>
 struct Evaluator<OP_MULTIPLY_INTO, In0Type, In0DataType, In1Type, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx)
-	{
-		evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0) * getInputValue<In1Type, In1DataType>(evalCtx, 1));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx)
+    {
+        evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0) * getInputValue<In1Type, In1DataType>(evalCtx, 1));
+    }
 };
 
 template <int In0Type, int In0DataType, int In1Type, int In1DataType>
 struct Evaluator<OP_DIVIDE_INTO, In0Type, In0DataType, In1Type, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx)
-	{
-		evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0) / getInputValue<In1Type, In1DataType>(evalCtx, 1));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx)
+    {
+        evalCtx.color.xyz() = reduceToVec3(getInputValue<In0Type, In0DataType>(evalCtx, 0) / getInputValue<In1Type, In1DataType>(evalCtx, 1));
+    }
 };
 
 ShaderEvalFunc getEvalFunc (const ShaderInput& in0, const ShaderInput& in1, MatrixOp op)
 {
-	DE_STATIC_ASSERT(TYPE_LAST		<= (1<<7));
-	DE_STATIC_ASSERT(OP_LAST		<= (1<<4));
-	DE_STATIC_ASSERT(INPUTTYPE_LAST	<= (1<<2));
-
-#define PACK_EVAL_CASE(OP, IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE)	(((OP) << 18) | ((IN0TYPE) << 16) | ((IN0DATATYPE) << 9) | ((IN1TYPE) << 7) | (IN1DATATYPE))
-
-#define MAKE_EVAL_CASE(OP, IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE)		\
-	case PACK_EVAL_CASE(OP, IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE):	\
-		return Evaluator<OP, IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE>::evaluate
-
-#define SCALAR_OPS(IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE)	\
-	MAKE_EVAL_CASE(OP_ADD,		IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);	\
-	MAKE_EVAL_CASE(OP_SUB,		IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);	\
-	MAKE_EVAL_CASE(OP_MUL,		IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);	\
-	MAKE_EVAL_CASE(OP_DIV,		IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE)
-
-#define ALL_OPS(IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE)	\
-	MAKE_EVAL_CASE(OP_ADD,			IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);	\
-	MAKE_EVAL_CASE(OP_SUB,			IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);	\
-	MAKE_EVAL_CASE(OP_MUL,			IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);	\
-	MAKE_EVAL_CASE(OP_DIV,			IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);	\
-	MAKE_EVAL_CASE(OP_COMP_MUL,		IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);
-
-#define MUL_OP(IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE)	\
-	MAKE_EVAL_CASE(OP_MUL, IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE)
-
-#define MAKE_MAT_SCALAR_VEC_CASES(OP, TYPE0, TYPE1)				\
-	OP(INPUTTYPE_CONST,		TYPE0, INPUTTYPE_CONST,		TYPE1);	\
-	OP(INPUTTYPE_DYNAMIC,	TYPE0, INPUTTYPE_CONST,		TYPE1);	\
-	OP(INPUTTYPE_CONST,		TYPE0, INPUTTYPE_DYNAMIC,	TYPE1);	\
-	OP(INPUTTYPE_DYNAMIC,	TYPE0, INPUTTYPE_DYNAMIC,	TYPE1)
-
-#define MAKE_MAT_MAT_CASES(OP, MATTYPE)								\
-	OP(INPUTTYPE_CONST,		MATTYPE, INPUTTYPE_CONST,	MATTYPE);	\
-	OP(INPUTTYPE_DYNAMIC,	MATTYPE, INPUTTYPE_CONST,	MATTYPE)
-
-#define UNARY_OP(IN0TYPE, IN0DATATYPE)														\
-	MAKE_EVAL_CASE(OP_UNARY_PLUS,		IN0TYPE, IN0DATATYPE, INPUTTYPE_CONST, TYPE_LAST);	\
-	MAKE_EVAL_CASE(OP_NEGATION,			IN0TYPE, IN0DATATYPE, INPUTTYPE_CONST, TYPE_LAST);	\
-	MAKE_EVAL_CASE(OP_PRE_INCREMENT,	IN0TYPE, IN0DATATYPE, INPUTTYPE_CONST, TYPE_LAST);	\
-	MAKE_EVAL_CASE(OP_PRE_DECREMENT,	IN0TYPE, IN0DATATYPE, INPUTTYPE_CONST, TYPE_LAST);	\
-	MAKE_EVAL_CASE(OP_POST_INCREMENT,	IN0TYPE, IN0DATATYPE, INPUTTYPE_CONST, TYPE_LAST);	\
-	MAKE_EVAL_CASE(OP_POST_DECREMENT,	IN0TYPE, IN0DATATYPE, INPUTTYPE_CONST, TYPE_LAST)
-
-#define MAKE_UNARY_CASES(OP, MATTYPE)	\
-	OP(INPUTTYPE_CONST,		MATTYPE);	\
-	OP(INPUTTYPE_DYNAMIC,	MATTYPE)
-
-#define ASSIGN_OP(IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE)							\
-	MAKE_EVAL_CASE(OP_ADD_INTO,			IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);	\
-	MAKE_EVAL_CASE(OP_SUBTRACT_FROM,	IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);	\
-	MAKE_EVAL_CASE(OP_MULTIPLY_INTO,	IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);	\
-	MAKE_EVAL_CASE(OP_DIVIDE_INTO,		IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE)
-
-#define MAKE_ASSIGNMENT_CASES(OP, MATTYPE)						\
-	OP(INPUTTYPE_CONST,		MATTYPE, INPUTTYPE_CONST,	MATTYPE);	\
-	OP(INPUTTYPE_DYNAMIC,	MATTYPE, INPUTTYPE_CONST,	MATTYPE);	\
-	OP(INPUTTYPE_CONST,		MATTYPE, INPUTTYPE_DYNAMIC,	MATTYPE);	\
-	OP(INPUTTYPE_DYNAMIC,	MATTYPE, INPUTTYPE_DYNAMIC,	MATTYPE)
-
-	// \note At the moment there is no difference between uniform and const inputs. This saves binary size.
-	InputType in0Type = in0.inputType == INPUTTYPE_DYNAMIC ? INPUTTYPE_DYNAMIC : INPUTTYPE_CONST;
-	InputType in1Type = in1.inputType == INPUTTYPE_DYNAMIC ? INPUTTYPE_DYNAMIC : INPUTTYPE_CONST;
-
-	switch (PACK_EVAL_CASE(op, in0Type, in0.dataType, in1Type, in1.dataType))
-	{
-		// Matrix-scalar.
-		MAKE_MAT_SCALAR_VEC_CASES(SCALAR_OPS,	TYPE_FLOAT_MAT2, TYPE_FLOAT);
-		MAKE_MAT_SCALAR_VEC_CASES(SCALAR_OPS,	TYPE_FLOAT_MAT3, TYPE_FLOAT);
-		MAKE_MAT_SCALAR_VEC_CASES(SCALAR_OPS,	TYPE_FLOAT_MAT4, TYPE_FLOAT);
-
-		// Matrix-vector.
-		MAKE_MAT_SCALAR_VEC_CASES(MUL_OP,		TYPE_FLOAT_MAT2, TYPE_FLOAT_VEC2);
-		MAKE_MAT_SCALAR_VEC_CASES(MUL_OP,		TYPE_FLOAT_MAT3, TYPE_FLOAT_VEC3);
-		MAKE_MAT_SCALAR_VEC_CASES(MUL_OP,		TYPE_FLOAT_MAT4, TYPE_FLOAT_VEC4);
-
-		// Vector-matrix.
-		MAKE_MAT_SCALAR_VEC_CASES(MUL_OP,		TYPE_FLOAT_VEC2, TYPE_FLOAT_MAT2);
-		MAKE_MAT_SCALAR_VEC_CASES(MUL_OP,		TYPE_FLOAT_VEC3, TYPE_FLOAT_MAT3);
-		MAKE_MAT_SCALAR_VEC_CASES(MUL_OP,		TYPE_FLOAT_VEC4, TYPE_FLOAT_MAT4);
-
-		// Matrix-matrix.
-		MAKE_MAT_MAT_CASES(ALL_OPS,	TYPE_FLOAT_MAT2);
-		MAKE_MAT_MAT_CASES(ALL_OPS,	TYPE_FLOAT_MAT3);
-		MAKE_MAT_MAT_CASES(ALL_OPS,	TYPE_FLOAT_MAT4);
-
-		// Unary matrix
-		MAKE_UNARY_CASES(UNARY_OP, TYPE_FLOAT_MAT2);
-		MAKE_UNARY_CASES(UNARY_OP, TYPE_FLOAT_MAT3);
-		MAKE_UNARY_CASES(UNARY_OP, TYPE_FLOAT_MAT4);
-
-		// Assignment matrix
-		MAKE_ASSIGNMENT_CASES(ASSIGN_OP, TYPE_FLOAT_MAT2);
-		MAKE_ASSIGNMENT_CASES(ASSIGN_OP, TYPE_FLOAT_MAT3);
-		MAKE_ASSIGNMENT_CASES(ASSIGN_OP, TYPE_FLOAT_MAT4);
-
-		default:
-			DE_ASSERT(DE_FALSE);
-			return DE_NULL;
-	}
+    DE_STATIC_ASSERT(TYPE_LAST      <= (1<<7));
+    DE_STATIC_ASSERT(OP_LAST        <= (1<<4));
+    DE_STATIC_ASSERT(INPUTTYPE_LAST <= (1<<2));
+
+#define PACK_EVAL_CASE(OP, IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE)  (((OP) << 18) | ((IN0TYPE) << 16) | ((IN0DATATYPE) << 9) | ((IN1TYPE) << 7) | (IN1DATATYPE))
+
+#define MAKE_EVAL_CASE(OP, IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE)      \
+    case PACK_EVAL_CASE(OP, IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE):    \
+        return Evaluator<OP, IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE>::evaluate
+
+#define SCALAR_OPS(IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE)  \
+    MAKE_EVAL_CASE(OP_ADD,      IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);    \
+    MAKE_EVAL_CASE(OP_SUB,      IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);    \
+    MAKE_EVAL_CASE(OP_MUL,      IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);    \
+    MAKE_EVAL_CASE(OP_DIV,      IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE)
+
+#define ALL_OPS(IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE) \
+    MAKE_EVAL_CASE(OP_ADD,          IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);    \
+    MAKE_EVAL_CASE(OP_SUB,          IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);    \
+    MAKE_EVAL_CASE(OP_MUL,          IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);    \
+    MAKE_EVAL_CASE(OP_DIV,          IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);    \
+    MAKE_EVAL_CASE(OP_COMP_MUL,     IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);
+
+#define MUL_OP(IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE)  \
+    MAKE_EVAL_CASE(OP_MUL, IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE)
+
+#define MAKE_MAT_SCALAR_VEC_CASES(OP, TYPE0, TYPE1)             \
+    OP(INPUTTYPE_CONST,     TYPE0, INPUTTYPE_CONST,     TYPE1); \
+    OP(INPUTTYPE_DYNAMIC,   TYPE0, INPUTTYPE_CONST,     TYPE1); \
+    OP(INPUTTYPE_CONST,     TYPE0, INPUTTYPE_DYNAMIC,   TYPE1); \
+    OP(INPUTTYPE_DYNAMIC,   TYPE0, INPUTTYPE_DYNAMIC,   TYPE1)
+
+#define MAKE_MAT_MAT_CASES(OP, MATTYPE)                             \
+    OP(INPUTTYPE_CONST,     MATTYPE, INPUTTYPE_CONST,   MATTYPE);   \
+    OP(INPUTTYPE_DYNAMIC,   MATTYPE, INPUTTYPE_CONST,   MATTYPE)
+
+#define UNARY_OP(IN0TYPE, IN0DATATYPE)                                                      \
+    MAKE_EVAL_CASE(OP_UNARY_PLUS,       IN0TYPE, IN0DATATYPE, INPUTTYPE_CONST, TYPE_LAST);  \
+    MAKE_EVAL_CASE(OP_NEGATION,         IN0TYPE, IN0DATATYPE, INPUTTYPE_CONST, TYPE_LAST);  \
+    MAKE_EVAL_CASE(OP_PRE_INCREMENT,    IN0TYPE, IN0DATATYPE, INPUTTYPE_CONST, TYPE_LAST);  \
+    MAKE_EVAL_CASE(OP_PRE_DECREMENT,    IN0TYPE, IN0DATATYPE, INPUTTYPE_CONST, TYPE_LAST);  \
+    MAKE_EVAL_CASE(OP_POST_INCREMENT,   IN0TYPE, IN0DATATYPE, INPUTTYPE_CONST, TYPE_LAST);  \
+    MAKE_EVAL_CASE(OP_POST_DECREMENT,   IN0TYPE, IN0DATATYPE, INPUTTYPE_CONST, TYPE_LAST)
+
+#define MAKE_UNARY_CASES(OP, MATTYPE)   \
+    OP(INPUTTYPE_CONST,     MATTYPE);   \
+    OP(INPUTTYPE_DYNAMIC,   MATTYPE)
+
+#define ASSIGN_OP(IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE)                           \
+    MAKE_EVAL_CASE(OP_ADD_INTO,         IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);    \
+    MAKE_EVAL_CASE(OP_SUBTRACT_FROM,    IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);    \
+    MAKE_EVAL_CASE(OP_MULTIPLY_INTO,    IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE);    \
+    MAKE_EVAL_CASE(OP_DIVIDE_INTO,      IN0TYPE, IN0DATATYPE, IN1TYPE, IN1DATATYPE)
+
+#define MAKE_ASSIGNMENT_CASES(OP, MATTYPE)                      \
+    OP(INPUTTYPE_CONST,     MATTYPE, INPUTTYPE_CONST,   MATTYPE);   \
+    OP(INPUTTYPE_DYNAMIC,   MATTYPE, INPUTTYPE_CONST,   MATTYPE);   \
+    OP(INPUTTYPE_CONST,     MATTYPE, INPUTTYPE_DYNAMIC, MATTYPE);   \
+    OP(INPUTTYPE_DYNAMIC,   MATTYPE, INPUTTYPE_DYNAMIC, MATTYPE)
+
+    // \note At the moment there is no difference between uniform and const inputs. This saves binary size.
+    InputType in0Type = in0.inputType == INPUTTYPE_DYNAMIC ? INPUTTYPE_DYNAMIC : INPUTTYPE_CONST;
+    InputType in1Type = in1.inputType == INPUTTYPE_DYNAMIC ? INPUTTYPE_DYNAMIC : INPUTTYPE_CONST;
+
+    switch (PACK_EVAL_CASE(op, in0Type, in0.dataType, in1Type, in1.dataType))
+    {
+        // Matrix-scalar.
+        MAKE_MAT_SCALAR_VEC_CASES(SCALAR_OPS,   TYPE_FLOAT_MAT2, TYPE_FLOAT);
+        MAKE_MAT_SCALAR_VEC_CASES(SCALAR_OPS,   TYPE_FLOAT_MAT3, TYPE_FLOAT);
+        MAKE_MAT_SCALAR_VEC_CASES(SCALAR_OPS,   TYPE_FLOAT_MAT4, TYPE_FLOAT);
+
+        // Matrix-vector.
+        MAKE_MAT_SCALAR_VEC_CASES(MUL_OP,       TYPE_FLOAT_MAT2, TYPE_FLOAT_VEC2);
+        MAKE_MAT_SCALAR_VEC_CASES(MUL_OP,       TYPE_FLOAT_MAT3, TYPE_FLOAT_VEC3);
+        MAKE_MAT_SCALAR_VEC_CASES(MUL_OP,       TYPE_FLOAT_MAT4, TYPE_FLOAT_VEC4);
+
+        // Vector-matrix.
+        MAKE_MAT_SCALAR_VEC_CASES(MUL_OP,       TYPE_FLOAT_VEC2, TYPE_FLOAT_MAT2);
+        MAKE_MAT_SCALAR_VEC_CASES(MUL_OP,       TYPE_FLOAT_VEC3, TYPE_FLOAT_MAT3);
+        MAKE_MAT_SCALAR_VEC_CASES(MUL_OP,       TYPE_FLOAT_VEC4, TYPE_FLOAT_MAT4);
+
+        // Matrix-matrix.
+        MAKE_MAT_MAT_CASES(ALL_OPS, TYPE_FLOAT_MAT2);
+        MAKE_MAT_MAT_CASES(ALL_OPS, TYPE_FLOAT_MAT3);
+        MAKE_MAT_MAT_CASES(ALL_OPS, TYPE_FLOAT_MAT4);
+
+        // Unary matrix
+        MAKE_UNARY_CASES(UNARY_OP, TYPE_FLOAT_MAT2);
+        MAKE_UNARY_CASES(UNARY_OP, TYPE_FLOAT_MAT3);
+        MAKE_UNARY_CASES(UNARY_OP, TYPE_FLOAT_MAT4);
+
+        // Assignment matrix
+        MAKE_ASSIGNMENT_CASES(ASSIGN_OP, TYPE_FLOAT_MAT2);
+        MAKE_ASSIGNMENT_CASES(ASSIGN_OP, TYPE_FLOAT_MAT3);
+        MAKE_ASSIGNMENT_CASES(ASSIGN_OP, TYPE_FLOAT_MAT4);
+
+        default:
+            DE_ASSERT(DE_FALSE);
+            return DE_NULL;
+    }
 
 #undef PACK_EVAL_CASE
 #undef MAKE_EVAL_CASE
@@ -701,35 +701,35 @@ ShaderEvalFunc getEvalFunc (const ShaderInput& in0, const ShaderInput& in1, Matr
 template <int Size>
 void writeVectorConstructor (std::ostream& str, const tcu::Vector<float, Size>& v)
 {
-	str << "vec" << Size << "(";
-	for (int ndx = 0; ndx < Size; ndx++)
-	{
-		if (ndx != 0)
-			str << ", ";
-		str << de::floatToString(v[ndx], 1);
-	}
-	str << ")";
+    str << "vec" << Size << "(";
+    for (int ndx = 0; ndx < Size; ndx++)
+    {
+        if (ndx != 0)
+            str << ", ";
+        str << de::floatToString(v[ndx], 1);
+    }
+    str << ")";
 }
 
 template <int Cols, int Rows>
 void writeMatrixConstructor (std::ostream& str, const tcu::Matrix<float, Rows, Cols>& m)
 {
-	if (Rows == Cols)
-		str << "mat" << Cols;
-	else
-		str << "mat" << Cols << "x" << Rows;
-
-	str << "(";
-	for (int colNdx = 0; colNdx < Cols; colNdx++)
-	{
-		for (int rowNdx = 0; rowNdx < Rows; rowNdx++)
-		{
-			if (rowNdx > 0 || colNdx > 0)
-				str << ", ";
-			str << de::floatToString(m(rowNdx, colNdx), 1);
-		}
-	}
-	str << ")";
+    if (Rows == Cols)
+        str << "mat" << Cols;
+    else
+        str << "mat" << Cols << "x" << Rows;
+
+    str << "(";
+    for (int colNdx = 0; colNdx < Cols; colNdx++)
+    {
+        for (int rowNdx = 0; rowNdx < Rows; rowNdx++)
+        {
+            if (rowNdx > 0 || colNdx > 0)
+                str << ", ";
+            str << de::floatToString(m(rowNdx, colNdx), 1);
+        }
+    }
+    str << ")";
 }
 
 } // MatrixCaseUtils
@@ -739,26 +739,26 @@ using namespace MatrixCaseUtils;
 class ShaderMatrixCase : public ShaderRenderCase
 {
 public:
-					ShaderMatrixCase			(Context& context, const char* name, const char* desc, const ShaderInput& in0, const ShaderInput& in1, MatrixOp op, bool isVertexCase);
-					~ShaderMatrixCase			(void);
+                    ShaderMatrixCase            (Context& context, const char* name, const char* desc, const ShaderInput& in0, const ShaderInput& in1, MatrixOp op, bool isVertexCase);
+                    ~ShaderMatrixCase           (void);
 
-	void			init						(void);
+    void            init                        (void);
 
 protected:
-	std::string		genGLSLMatToVec3Reduction	(const glu::DataType& matType, const char* varName);
-	void			setupUniforms				(int programID, const tcu::Vec4& constCoords);
+    std::string     genGLSLMatToVec3Reduction   (const glu::DataType& matType, const char* varName);
+    void            setupUniforms               (int programID, const tcu::Vec4& constCoords);
 
 private:
-	ShaderInput		m_in0;
-	ShaderInput		m_in1;
-	MatrixOp		m_op;
+    ShaderInput     m_in0;
+    ShaderInput     m_in1;
+    MatrixOp        m_op;
 };
 
 ShaderMatrixCase::ShaderMatrixCase (Context& context, const char* name, const char* desc, const ShaderInput& in0, const ShaderInput& in1, MatrixOp op, bool isVertexCase)
-	: ShaderRenderCase	(context.getTestContext(), context.getRenderContext(), context.getContextInfo(), name, desc, isVertexCase, getEvalFunc(in0, in1, op))
-	, m_in0				(in0)
-	, m_in1				(in1)
-	, m_op				(op)
+    : ShaderRenderCase  (context.getTestContext(), context.getRenderContext(), context.getContextInfo(), name, desc, isVertexCase, getEvalFunc(in0, in1, op))
+    , m_in0             (in0)
+    , m_in1             (in1)
+    , m_op              (op)
 {
 }
 
@@ -768,315 +768,315 @@ ShaderMatrixCase::~ShaderMatrixCase (void)
 
 void ShaderMatrixCase::init (void)
 {
-	std::ostringstream	vtx;
-	std::ostringstream	frag;
-	std::ostringstream&	op				= m_isVertexCase ? vtx : frag;
-
-	bool				isInDynMat0		= isDataTypeMatrix(m_in0.dataType) && m_in0.inputType == INPUTTYPE_DYNAMIC;
-	bool				isInDynMat1		= isDataTypeMatrix(m_in1.dataType) && m_in1.inputType == INPUTTYPE_DYNAMIC;
-	string				inValue0;
-	string				inValue1;
-	DataType			resultType		= TYPE_LAST;
-	Precision			resultPrec		= m_in0.precision;
-	vector<string>		passVars;
-	int					numInputs		= (isOperationBinary(m_op)) ? (2) : (1);
-
-	std::string			operationValue0;
-	std::string			operationValue1;
-
-	DE_ASSERT(!isInDynMat0 || !isInDynMat1); // Only single dynamic matrix input is allowed.
-	DE_UNREF(isInDynMat0 && isInDynMat1);
-
-	// Compute result type.
-	if (isDataTypeMatrix(m_in0.dataType) && isDataTypeMatrix(m_in1.dataType))
-	{
-		DE_ASSERT(m_in0.dataType == m_in1.dataType);
-		resultType = m_in0.dataType;
-	}
-	else if (getOperationType(m_op) == OPERATIONTYPE_UNARY_PREFIX_OPERATOR ||
-			 getOperationType(m_op) == OPERATIONTYPE_UNARY_POSTFIX_OPERATOR)
-	{
-		resultType = m_in0.dataType;
-	}
-	else
-	{
-		int			matNdx		= isDataTypeMatrix(m_in0.dataType) ? 0 : 1;
-		DataType	matrixType	= matNdx == 0 ? m_in0.dataType : m_in1.dataType;
-		DataType	otherType	= matNdx == 0 ? m_in1.dataType : m_in0.dataType;
-
-		if (otherType == TYPE_FLOAT)
-			resultType = matrixType;
-		else
-		{
-			DE_ASSERT(isDataTypeVector(otherType));
-			resultType = otherType;
-		}
-	}
-
-	vtx << "attribute highp vec4 a_position;\n";
-	if (m_isVertexCase)
-	{
-		vtx << "varying mediump vec4 v_color;\n";
-		frag << "varying mediump vec4 v_color;\n";
-	}
-
-	// Input declarations.
-	for (int inNdx = 0; inNdx < numInputs; inNdx++)
-	{
-		const ShaderInput&	in			= inNdx > 0 ? m_in1 : m_in0;
-		const char*			precName	= getPrecisionName(in.precision);
-		const char*			typeName	= getDataTypeName(in.dataType);
-		string&				inValue		= inNdx > 0 ? inValue1 : inValue0;
-
-		if (in.inputType == INPUTTYPE_DYNAMIC)
-		{
-			vtx << "attribute " << precName << " " << typeName << " a_";
-
-			if (isDataTypeMatrix(in.dataType))
-			{
-				// a_matN, v_matN
-				vtx << typeName << ";\n";
-				if (!m_isVertexCase)
-				{
-					vtx << "varying " << precName << " " << typeName << " v_" << typeName << ";\n";
-					frag << "varying " << precName << " " << typeName << " v_" << typeName << ";\n";
-					passVars.push_back(typeName);
-				}
-
-				inValue = string(m_isVertexCase ? "a_" : "v_") + getDataTypeName(in.dataType);
-			}
-			else
-			{
-				// a_coords, v_coords
-				vtx << "coords;\n";
-				if (!m_isVertexCase)
-				{
-					vtx << "varying " << precName << " " << typeName << " v_coords;\n";
-					frag << "varying " << precName << " " << typeName << " v_coords;\n";
-					passVars.push_back("coords");
-				}
-
-				inValue = m_isVertexCase ? "a_coords" : "v_coords";
-			}
-		}
-		else if (in.inputType == INPUTTYPE_UNIFORM)
-		{
-			op << "uniform " << precName << " " << typeName << " u_in" << inNdx << ";\n";
-			inValue = string("u_in") + de::toString(inNdx);
-		}
-		else if (in.inputType == INPUTTYPE_CONST)
-		{
-			op << "const " << precName << " " << typeName << " in" << inNdx << " = ";
-
-			// Generate declaration.
-			switch (in.dataType)
-			{
-				case TYPE_FLOAT:		op << de::floatToString(s_constInFloat[inNdx], 1);					break;
-				case TYPE_FLOAT_VEC2:	writeVectorConstructor<2>(op, s_constInVec2[inNdx]);				break;
-				case TYPE_FLOAT_VEC3:	writeVectorConstructor<3>(op, s_constInVec3[inNdx]);				break;
-				case TYPE_FLOAT_VEC4:	writeVectorConstructor<4>(op, s_constInVec4[inNdx]);				break;
-				case TYPE_FLOAT_MAT2:	writeMatrixConstructor<2, 2>(op, Mat2(s_constInMat2[inNdx]));		break;
-				case TYPE_FLOAT_MAT3:	writeMatrixConstructor<3, 3>(op, Mat3(s_constInMat3[inNdx]));		break;
-				case TYPE_FLOAT_MAT4:	writeMatrixConstructor<4, 4>(op, Mat4(s_constInMat4[inNdx]));		break;
-
-				default:
-					DE_ASSERT(DE_FALSE);
-			}
-
-			op << ";\n";
-
-			inValue = string("in") + de::toString(inNdx);
-		}
-	}
-
-	vtx << "\n"
-		<< "void main (void)\n"
-		<< "{\n"
-		<< "	gl_Position = a_position;\n";
-	frag << "\n"
-		 << "void main (void)\n"
-		 << "{\n";
-
-	if (m_isVertexCase)
-	{
-		frag << "	gl_FragColor = v_color;\n";
-	}
-	else
-	{
-		for (vector<string>::const_iterator copyIter = passVars.begin(); copyIter != passVars.end(); copyIter++)
-			vtx << "	v_" << *copyIter << " = " << "a_" << *copyIter << ";\n";
-	}
-
-	// Operation.
-
-	switch (getOperationNature(m_op))
-	{
-		case OPERATIONNATURE_PURE:
-			DE_ASSERT(getOperationType(m_op) != OPERATIONTYPE_ASSIGNMENT);
-
-			operationValue0 = inValue0;
-			operationValue1 = inValue1;
-			break;
-
-		case OPERATIONNATURE_MUTATING:
-			DE_ASSERT(getOperationType(m_op) != OPERATIONTYPE_ASSIGNMENT);
-
-			op << "	" << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " tmpValue = " << inValue0 << ";\n";
-
-			operationValue0 = "tmpValue";
-			operationValue1 = inValue1;
-			break;
-
-		case OPERATIONNATURE_ASSIGNMENT:
-			DE_ASSERT(getOperationType(m_op) == OPERATIONTYPE_ASSIGNMENT);
-
-			operationValue0 = inValue0;
-			operationValue1 = inValue1;
-			break;
-
-		default:
-			DE_ASSERT(DE_FALSE);
-	}
-
-	switch (getOperationType(m_op))
-	{
-		case OPERATIONTYPE_BINARY_OPERATOR:
-			op << "	" << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << operationValue0 << " " << getOperationName(m_op) << " " << operationValue1 << ";\n";
-			break;
-
-		case OPERATIONTYPE_UNARY_PREFIX_OPERATOR:
-			op << "	" << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << getOperationName(m_op) << operationValue0 << ";\n";
-			break;
-
-		case OPERATIONTYPE_UNARY_POSTFIX_OPERATOR:
-			op << "	" << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << operationValue0 << getOperationName(m_op) << ";\n";
-			break;
-
-		case OPERATIONTYPE_BINARY_FUNCTION:
-			op << "	" << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << getOperationName(m_op) << "(" << operationValue0 << ", " << operationValue1 << ");\n";
-			break;
-
-		case OPERATIONTYPE_ASSIGNMENT:
-			op << "	" << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << operationValue0 << ";\n";
-			op << "	res " << getOperationName(m_op) << " " << operationValue1 << ";\n";
-			break;
-
-		default:
-			DE_ASSERT(DE_FALSE);
-	}
-
-	// Reduction to vec3 (rgb). Check the used value too if it was modified.
-	op << "	" << (m_isVertexCase ? "v_color" : "gl_FragColor") << " = ";
-
-	if (isOperationValueModifying(m_op))
-		op << "vec4(" << genGLSLMatToVec3Reduction(resultType, "res") << ", 1.0) + vec4(" << genGLSLMatToVec3Reduction(resultType, "tmpValue") << ", 0.0);\n";
-	else
-		op << "vec4(" << genGLSLMatToVec3Reduction(resultType, "res") << ", 1.0);\n";
-
-	vtx << "}\n";
-	frag << "}\n";
-
-	m_vertShaderSource	= vtx.str();
-	m_fragShaderSource	= frag.str();
-
-	// \todo [2012-02-14 pyry] Compute better values for matrix tests.
-	m_userAttribTransforms.resize(4);
-	for (int attribNdx = 0; attribNdx < 4; attribNdx++)
-	{
-		m_userAttribTransforms[attribNdx] = Mat4(0.0f);
-		m_userAttribTransforms[attribNdx]((0 + attribNdx) % 4, 0) = 1.0f;
-		m_userAttribTransforms[attribNdx]((1 + attribNdx) % 4, 1) = 1.0f;
-		m_userAttribTransforms[attribNdx]((2 + attribNdx) % 4, 2) = 1.0f;
-		m_userAttribTransforms[attribNdx]((3 + attribNdx) % 4, 3) = 1.0f;
-	}
-
-	// prevent bad reference cases such as black result images by fine-tuning used matrices
-	if (getOperationTestMatrixType(m_op) != TESTMATRIXTYPE_DEFAULT)
-	{
-		for (int attribNdx = 0; attribNdx < 4; attribNdx++)
-		{
-			for (int row = 0; row < 4; row++)
-			for (int col = 0; col < 4; col++)
-			{
-				switch (getOperationTestMatrixType(m_op))
-				{
-					case TESTMATRIXTYPE_NEGATED:
-						m_userAttribTransforms[attribNdx](row, col) = -m_userAttribTransforms[attribNdx](row, col);
-						break;
-					case TESTMATRIXTYPE_INCREMENTED:
-						m_userAttribTransforms[attribNdx](row, col) += 0.3f;
-						break;
-					case TESTMATRIXTYPE_DECREMENTED:
-						m_userAttribTransforms[attribNdx](row, col) -= 0.1f;
-						break;
-
-					default:
-						DE_ASSERT(DE_FALSE);
-						break;
-				}
-			}
-		}
-	}
-
-	ShaderRenderCase::init();
+    std::ostringstream  vtx;
+    std::ostringstream  frag;
+    std::ostringstream& op              = m_isVertexCase ? vtx : frag;
+
+    bool                isInDynMat0     = isDataTypeMatrix(m_in0.dataType) && m_in0.inputType == INPUTTYPE_DYNAMIC;
+    bool                isInDynMat1     = isDataTypeMatrix(m_in1.dataType) && m_in1.inputType == INPUTTYPE_DYNAMIC;
+    string              inValue0;
+    string              inValue1;
+    DataType            resultType      = TYPE_LAST;
+    Precision           resultPrec      = m_in0.precision;
+    vector<string>      passVars;
+    int                 numInputs       = (isOperationBinary(m_op)) ? (2) : (1);
+
+    std::string         operationValue0;
+    std::string         operationValue1;
+
+    DE_ASSERT(!isInDynMat0 || !isInDynMat1); // Only single dynamic matrix input is allowed.
+    DE_UNREF(isInDynMat0 && isInDynMat1);
+
+    // Compute result type.
+    if (isDataTypeMatrix(m_in0.dataType) && isDataTypeMatrix(m_in1.dataType))
+    {
+        DE_ASSERT(m_in0.dataType == m_in1.dataType);
+        resultType = m_in0.dataType;
+    }
+    else if (getOperationType(m_op) == OPERATIONTYPE_UNARY_PREFIX_OPERATOR ||
+             getOperationType(m_op) == OPERATIONTYPE_UNARY_POSTFIX_OPERATOR)
+    {
+        resultType = m_in0.dataType;
+    }
+    else
+    {
+        int         matNdx      = isDataTypeMatrix(m_in0.dataType) ? 0 : 1;
+        DataType    matrixType  = matNdx == 0 ? m_in0.dataType : m_in1.dataType;
+        DataType    otherType   = matNdx == 0 ? m_in1.dataType : m_in0.dataType;
+
+        if (otherType == TYPE_FLOAT)
+            resultType = matrixType;
+        else
+        {
+            DE_ASSERT(isDataTypeVector(otherType));
+            resultType = otherType;
+        }
+    }
+
+    vtx << "attribute highp vec4 a_position;\n";
+    if (m_isVertexCase)
+    {
+        vtx << "varying mediump vec4 v_color;\n";
+        frag << "varying mediump vec4 v_color;\n";
+    }
+
+    // Input declarations.
+    for (int inNdx = 0; inNdx < numInputs; inNdx++)
+    {
+        const ShaderInput&  in          = inNdx > 0 ? m_in1 : m_in0;
+        const char*         precName    = getPrecisionName(in.precision);
+        const char*         typeName    = getDataTypeName(in.dataType);
+        string&             inValue     = inNdx > 0 ? inValue1 : inValue0;
+
+        if (in.inputType == INPUTTYPE_DYNAMIC)
+        {
+            vtx << "attribute " << precName << " " << typeName << " a_";
+
+            if (isDataTypeMatrix(in.dataType))
+            {
+                // a_matN, v_matN
+                vtx << typeName << ";\n";
+                if (!m_isVertexCase)
+                {
+                    vtx << "varying " << precName << " " << typeName << " v_" << typeName << ";\n";
+                    frag << "varying " << precName << " " << typeName << " v_" << typeName << ";\n";
+                    passVars.push_back(typeName);
+                }
+
+                inValue = string(m_isVertexCase ? "a_" : "v_") + getDataTypeName(in.dataType);
+            }
+            else
+            {
+                // a_coords, v_coords
+                vtx << "coords;\n";
+                if (!m_isVertexCase)
+                {
+                    vtx << "varying " << precName << " " << typeName << " v_coords;\n";
+                    frag << "varying " << precName << " " << typeName << " v_coords;\n";
+                    passVars.push_back("coords");
+                }
+
+                inValue = m_isVertexCase ? "a_coords" : "v_coords";
+            }
+        }
+        else if (in.inputType == INPUTTYPE_UNIFORM)
+        {
+            op << "uniform " << precName << " " << typeName << " u_in" << inNdx << ";\n";
+            inValue = string("u_in") + de::toString(inNdx);
+        }
+        else if (in.inputType == INPUTTYPE_CONST)
+        {
+            op << "const " << precName << " " << typeName << " in" << inNdx << " = ";
+
+            // Generate declaration.
+            switch (in.dataType)
+            {
+                case TYPE_FLOAT:        op << de::floatToString(s_constInFloat[inNdx], 1);                  break;
+                case TYPE_FLOAT_VEC2:   writeVectorConstructor<2>(op, s_constInVec2[inNdx]);                break;
+                case TYPE_FLOAT_VEC3:   writeVectorConstructor<3>(op, s_constInVec3[inNdx]);                break;
+                case TYPE_FLOAT_VEC4:   writeVectorConstructor<4>(op, s_constInVec4[inNdx]);                break;
+                case TYPE_FLOAT_MAT2:   writeMatrixConstructor<2, 2>(op, Mat2(s_constInMat2[inNdx]));       break;
+                case TYPE_FLOAT_MAT3:   writeMatrixConstructor<3, 3>(op, Mat3(s_constInMat3[inNdx]));       break;
+                case TYPE_FLOAT_MAT4:   writeMatrixConstructor<4, 4>(op, Mat4(s_constInMat4[inNdx]));       break;
+
+                default:
+                    DE_ASSERT(DE_FALSE);
+            }
+
+            op << ";\n";
+
+            inValue = string("in") + de::toString(inNdx);
+        }
+    }
+
+    vtx << "\n"
+        << "void main (void)\n"
+        << "{\n"
+        << "    gl_Position = a_position;\n";
+    frag << "\n"
+         << "void main (void)\n"
+         << "{\n";
+
+    if (m_isVertexCase)
+    {
+        frag << "   gl_FragColor = v_color;\n";
+    }
+    else
+    {
+        for (vector<string>::const_iterator copyIter = passVars.begin(); copyIter != passVars.end(); copyIter++)
+            vtx << "    v_" << *copyIter << " = " << "a_" << *copyIter << ";\n";
+    }
+
+    // Operation.
+
+    switch (getOperationNature(m_op))
+    {
+        case OPERATIONNATURE_PURE:
+            DE_ASSERT(getOperationType(m_op) != OPERATIONTYPE_ASSIGNMENT);
+
+            operationValue0 = inValue0;
+            operationValue1 = inValue1;
+            break;
+
+        case OPERATIONNATURE_MUTATING:
+            DE_ASSERT(getOperationType(m_op) != OPERATIONTYPE_ASSIGNMENT);
+
+            op << " " << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " tmpValue = " << inValue0 << ";\n";
+
+            operationValue0 = "tmpValue";
+            operationValue1 = inValue1;
+            break;
+
+        case OPERATIONNATURE_ASSIGNMENT:
+            DE_ASSERT(getOperationType(m_op) == OPERATIONTYPE_ASSIGNMENT);
+
+            operationValue0 = inValue0;
+            operationValue1 = inValue1;
+            break;
+
+        default:
+            DE_ASSERT(DE_FALSE);
+    }
+
+    switch (getOperationType(m_op))
+    {
+        case OPERATIONTYPE_BINARY_OPERATOR:
+            op << " " << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << operationValue0 << " " << getOperationName(m_op) << " " << operationValue1 << ";\n";
+            break;
+
+        case OPERATIONTYPE_UNARY_PREFIX_OPERATOR:
+            op << " " << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << getOperationName(m_op) << operationValue0 << ";\n";
+            break;
+
+        case OPERATIONTYPE_UNARY_POSTFIX_OPERATOR:
+            op << " " << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << operationValue0 << getOperationName(m_op) << ";\n";
+            break;
+
+        case OPERATIONTYPE_BINARY_FUNCTION:
+            op << " " << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << getOperationName(m_op) << "(" << operationValue0 << ", " << operationValue1 << ");\n";
+            break;
+
+        case OPERATIONTYPE_ASSIGNMENT:
+            op << " " << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << operationValue0 << ";\n";
+            op << " res " << getOperationName(m_op) << " " << operationValue1 << ";\n";
+            break;
+
+        default:
+            DE_ASSERT(DE_FALSE);
+    }
+
+    // Reduction to vec3 (rgb). Check the used value too if it was modified.
+    op << " " << (m_isVertexCase ? "v_color" : "gl_FragColor") << " = ";
+
+    if (isOperationValueModifying(m_op))
+        op << "vec4(" << genGLSLMatToVec3Reduction(resultType, "res") << ", 1.0) + vec4(" << genGLSLMatToVec3Reduction(resultType, "tmpValue") << ", 0.0);\n";
+    else
+        op << "vec4(" << genGLSLMatToVec3Reduction(resultType, "res") << ", 1.0);\n";
+
+    vtx << "}\n";
+    frag << "}\n";
+
+    m_vertShaderSource  = vtx.str();
+    m_fragShaderSource  = frag.str();
+
+    // \todo [2012-02-14 pyry] Compute better values for matrix tests.
+    m_userAttribTransforms.resize(4);
+    for (int attribNdx = 0; attribNdx < 4; attribNdx++)
+    {
+        m_userAttribTransforms[attribNdx] = Mat4(0.0f);
+        m_userAttribTransforms[attribNdx]((0 + attribNdx) % 4, 0) = 1.0f;
+        m_userAttribTransforms[attribNdx]((1 + attribNdx) % 4, 1) = 1.0f;
+        m_userAttribTransforms[attribNdx]((2 + attribNdx) % 4, 2) = 1.0f;
+        m_userAttribTransforms[attribNdx]((3 + attribNdx) % 4, 3) = 1.0f;
+    }
+
+    // prevent bad reference cases such as black result images by fine-tuning used matrices
+    if (getOperationTestMatrixType(m_op) != TESTMATRIXTYPE_DEFAULT)
+    {
+        for (int attribNdx = 0; attribNdx < 4; attribNdx++)
+        {
+            for (int row = 0; row < 4; row++)
+            for (int col = 0; col < 4; col++)
+            {
+                switch (getOperationTestMatrixType(m_op))
+                {
+                    case TESTMATRIXTYPE_NEGATED:
+                        m_userAttribTransforms[attribNdx](row, col) = -m_userAttribTransforms[attribNdx](row, col);
+                        break;
+                    case TESTMATRIXTYPE_INCREMENTED:
+                        m_userAttribTransforms[attribNdx](row, col) += 0.3f;
+                        break;
+                    case TESTMATRIXTYPE_DECREMENTED:
+                        m_userAttribTransforms[attribNdx](row, col) -= 0.1f;
+                        break;
+
+                    default:
+                        DE_ASSERT(DE_FALSE);
+                        break;
+                }
+            }
+        }
+    }
+
+    ShaderRenderCase::init();
 }
 
 std::string ShaderMatrixCase::genGLSLMatToVec3Reduction (const glu::DataType& matType, const char* varName)
 {
-	std::ostringstream op;
-
-	switch (matType)
-	{
-		case TYPE_FLOAT:		op << varName << ", "		<< varName << ", "			<< varName << "";										break;
-		case TYPE_FLOAT_VEC2:	op << varName << ".x, "		<< varName << ".y, "		<< varName << ".x";										break;
-		case TYPE_FLOAT_VEC3:	op << varName << "";																							break;
-		case TYPE_FLOAT_VEC4:	op << varName << ".x, "		<< varName << ".y, "		<< varName << ".z+"			<< varName << ".w";			break;
-		case TYPE_FLOAT_MAT2:	op << varName << "[0][0], "	<< varName << "[1][0], "	<< varName << "[0][1]+"		<< varName << "[1][1]";		break;
-		case TYPE_FLOAT_MAT3:	op << varName << "[0]+"		<< varName << "[1]+"		<< varName << "[2]";									break;
-		case TYPE_FLOAT_MAT4:	op << varName << "[0].xyz+"	<< varName << "[1].yzw+"	<< varName << "[2].zwx+"	<< varName << "[3].wxy";	break;
-
-		default:
-			DE_ASSERT(DE_FALSE);
-	}
-
-	return op.str();
+    std::ostringstream op;
+
+    switch (matType)
+    {
+        case TYPE_FLOAT:        op << varName << ", "       << varName << ", "          << varName << "";                                       break;
+        case TYPE_FLOAT_VEC2:   op << varName << ".x, "     << varName << ".y, "        << varName << ".x";                                     break;
+        case TYPE_FLOAT_VEC3:   op << varName << "";                                                                                            break;
+        case TYPE_FLOAT_VEC4:   op << varName << ".x, "     << varName << ".y, "        << varName << ".z+"         << varName << ".w";         break;
+        case TYPE_FLOAT_MAT2:   op << varName << "[0][0], " << varName << "[1][0], "    << varName << "[0][1]+"     << varName << "[1][1]";     break;
+        case TYPE_FLOAT_MAT3:   op << varName << "[0]+"     << varName << "[1]+"        << varName << "[2]";                                    break;
+        case TYPE_FLOAT_MAT4:   op << varName << "[0].xyz+" << varName << "[1].yzw+"    << varName << "[2].zwx+"    << varName << "[3].wxy";    break;
+
+        default:
+            DE_ASSERT(DE_FALSE);
+    }
+
+    return op.str();
 }
 
 void ShaderMatrixCase::setupUniforms (int programID, const tcu::Vec4& constCoords)
 {
-	const glw::Functions& gl = m_renderCtx.getFunctions();
-
-	DE_UNREF(constCoords);
-
-	for (int inNdx = 0; inNdx < 2; inNdx++)
-	{
-		const ShaderInput& in = inNdx > 0 ? m_in1 : m_in0;
-
-		if (in.inputType == INPUTTYPE_UNIFORM)
-		{
-			int loc = gl.getUniformLocation(programID, (string("u_in") + de::toString(inNdx)).c_str());
-
-			if (loc < 0)
-				continue;
-
-			switch (in.dataType)
-			{
-				case TYPE_FLOAT:		gl.uniform1f(loc, s_constInFloat[inNdx]);													break;
-				case TYPE_FLOAT_VEC2:	gl.uniform2fv(loc, 1, s_constInVec2[inNdx].getPtr());										break;
-				case TYPE_FLOAT_VEC3:	gl.uniform3fv(loc, 1, s_constInVec3[inNdx].getPtr());										break;
-				case TYPE_FLOAT_VEC4:	gl.uniform4fv(loc, 1, s_constInVec4[inNdx].getPtr());										break;
-				case TYPE_FLOAT_MAT2:	gl.uniformMatrix2fv(loc, 1, GL_FALSE, s_constInMat2[inNdx].getColumnMajorData().getPtr());	break;
-				case TYPE_FLOAT_MAT3:	gl.uniformMatrix3fv(loc, 1, GL_FALSE, s_constInMat3[inNdx].getColumnMajorData().getPtr());	break;
-				case TYPE_FLOAT_MAT4:	gl.uniformMatrix4fv(loc, 1, GL_FALSE, s_constInMat4[inNdx].getColumnMajorData().getPtr());	break;
-				default:
-					DE_ASSERT(false);
-			}
-		}
-	}
+    const glw::Functions& gl = m_renderCtx.getFunctions();
+
+    DE_UNREF(constCoords);
+
+    for (int inNdx = 0; inNdx < 2; inNdx++)
+    {
+        const ShaderInput& in = inNdx > 0 ? m_in1 : m_in0;
+
+        if (in.inputType == INPUTTYPE_UNIFORM)
+        {
+            int loc = gl.getUniformLocation(programID, (string("u_in") + de::toString(inNdx)).c_str());
+
+            if (loc < 0)
+                continue;
+
+            switch (in.dataType)
+            {
+                case TYPE_FLOAT:        gl.uniform1f(loc, s_constInFloat[inNdx]);                                                   break;
+                case TYPE_FLOAT_VEC2:   gl.uniform2fv(loc, 1, s_constInVec2[inNdx].getPtr());                                       break;
+                case TYPE_FLOAT_VEC3:   gl.uniform3fv(loc, 1, s_constInVec3[inNdx].getPtr());                                       break;
+                case TYPE_FLOAT_VEC4:   gl.uniform4fv(loc, 1, s_constInVec4[inNdx].getPtr());                                       break;
+                case TYPE_FLOAT_MAT2:   gl.uniformMatrix2fv(loc, 1, GL_FALSE, s_constInMat2[inNdx].getColumnMajorData().getPtr());  break;
+                case TYPE_FLOAT_MAT3:   gl.uniformMatrix3fv(loc, 1, GL_FALSE, s_constInMat3[inNdx].getColumnMajorData().getPtr());  break;
+                case TYPE_FLOAT_MAT4:   gl.uniformMatrix4fv(loc, 1, GL_FALSE, s_constInMat4[inNdx].getColumnMajorData().getPtr());  break;
+                default:
+                    DE_ASSERT(false);
+            }
+        }
+    }
 }
 
 ShaderMatrixTests::ShaderMatrixTests (Context& context)
-	: TestCaseGroup(context, "matrix", "Matrix Tests")
+    : TestCaseGroup(context, "matrix", "Matrix Tests")
 {
 }
 
@@ -1086,136 +1086,136 @@ ShaderMatrixTests::~ShaderMatrixTests (void)
 
 void ShaderMatrixTests::init (void)
 {
-	static const struct
-	{
-		const char*		name;
-		const char*		desc;
-		MatrixOp		op;
-		bool			extendedInputTypeCases; // !< test with const and uniform types too
-	} ops[] =
-	{
-		{ "add",			"Matrix addition tests",						OP_ADD,				true	},
-		{ "sub",			"Matrix subtraction tests",						OP_SUB,				true	},
-		{ "mul",			"Matrix multiplication tests",					OP_MUL,				true	},
-		{ "div",			"Matrix division tests",						OP_DIV,				true	},
-		{ "matrixcompmult",	"Matrix component-wise multiplication tests",	OP_COMP_MUL,		false	},
-		{ "unary_addition",	"Matrix unary addition tests",					OP_UNARY_PLUS,		false	},
-		{ "negation",		"Matrix negation tests",						OP_NEGATION,		false	},
-		{ "pre_increment",	"Matrix prefix increment tests",				OP_PRE_INCREMENT,	false	},
-		{ "pre_decrement",	"Matrix prefix decrement tests",				OP_PRE_DECREMENT,	false	},
-		{ "post_increment",	"Matrix postfix increment tests",				OP_POST_INCREMENT,	false	},
-		{ "post_decrement",	"Matrix postfix decrement tests",				OP_POST_DECREMENT,	false	},
-		{ "add_assign",		"Matrix add into tests",						OP_ADD_INTO,		false	},
-		{ "sub_assign",		"Matrix subtract from tests",					OP_SUBTRACT_FROM,	false	},
-		{ "mul_assign",		"Matrix multiply into tests",					OP_MULTIPLY_INTO,	false	},
-		{ "div_assign",		"Matrix divide into tests",						OP_DIVIDE_INTO,		false	},
-	};
-
-	struct InputTypeSpec
-	{
-		const char*		name;
-		const char*		desc;
-		InputType		type;
-	};
-	static const InputTypeSpec extendedInputTypes[] =
-	{
-		{ "const",		"Constant matrix input",	INPUTTYPE_CONST		},
-		{ "uniform",	"Uniform matrix input",		INPUTTYPE_UNIFORM	},
-		{ "dynamic",	"Dynamic matrix input",		INPUTTYPE_DYNAMIC	}
-	};
-	static const InputTypeSpec reducedInputTypes[] =
-	{
-		{ "dynamic",	"Dynamic matrix input",		INPUTTYPE_DYNAMIC	}
-	};
-
-	static const DataType matrixTypes[] =
-	{
-		TYPE_FLOAT_MAT2,
-		TYPE_FLOAT_MAT3,
-		TYPE_FLOAT_MAT4
-	};
-
-	static const Precision precisions[] =
-	{
-		PRECISION_LOWP,
-		PRECISION_MEDIUMP,
-		PRECISION_HIGHP
-	};
-
-	for (int opNdx = 0; opNdx < DE_LENGTH_OF_ARRAY(ops); opNdx++)
-	{
-		const InputTypeSpec*	inTypeList		= (ops[opNdx].extendedInputTypeCases) ? (extendedInputTypes) : (reducedInputTypes);
-		const int				inTypeListSize	= (ops[opNdx].extendedInputTypeCases) ? (DE_LENGTH_OF_ARRAY(extendedInputTypes)) : (DE_LENGTH_OF_ARRAY(reducedInputTypes));
-		const MatrixOp			op				= ops[opNdx].op;
-		tcu::TestCaseGroup*		opGroup			= new tcu::TestCaseGroup(m_testCtx, ops[opNdx].name, ops[opNdx].desc);
-
-		addChild(opGroup);
-
-		for (int inTypeNdx = 0; inTypeNdx < inTypeListSize; inTypeNdx++)
-		{
-			const InputType		inputType	= inTypeList[inTypeNdx].type;
-
-			for (int matTypeNdx = 0; matTypeNdx < DE_LENGTH_OF_ARRAY(matrixTypes); matTypeNdx++)
-			{
-				DataType	matType		= matrixTypes[matTypeNdx];
-				const char*	matTypeName	= getDataTypeName(matType);
-
-				for (int precNdx = 0; precNdx < DE_LENGTH_OF_ARRAY(precisions); precNdx++)
-				{
-					Precision	precision	= precisions[precNdx];
-					const char*	precName	= getPrecisionName(precision);
-					string		baseName	= string(inTypeList[inTypeNdx].name) + "_" + precName + "_" + matTypeName + "_";
-					ShaderInput	matIn		(inputType, matType, precision);
-
-					if (isOperationMatrixScalar(op))
-					{
-						// Matrix-scalar \note For div cases we use uniform input.
-						ShaderInput scalarIn(op == OP_DIV ? INPUTTYPE_UNIFORM : INPUTTYPE_DYNAMIC, TYPE_FLOAT, precision);
-						opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_vertex").c_str(),		"Matrix-scalar case", matIn, scalarIn, op, true));
-						opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_fragment").c_str(),	"Matrix-scalar case", matIn, scalarIn, op, false));
-					}
-
-					if (isOperationMatrixVector(op))
-					{
-						// Matrix-vector.
-						DataType	vecType	= getDataTypeFloatVec(getDataTypeMatrixNumColumns(matType));
-						ShaderInput vecIn	(op == OP_DIV ? INPUTTYPE_UNIFORM : INPUTTYPE_DYNAMIC, vecType, precision);
-
-						opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + getDataTypeName(vecType) + "_vertex").c_str(),	"Matrix-vector case", matIn, vecIn, op, true));
-						opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + getDataTypeName(vecType) + "_fragment").c_str(),	"Matrix-vector case", matIn, vecIn, op, false));
-
-						// Vector-matrix.
-						string vecMatName = string(inTypeList[inTypeNdx].name) + "_" + precName + "_" + getDataTypeName(vecType) + "_" + matTypeName;
-						opGroup->addChild(new ShaderMatrixCase(m_context, (vecMatName + "_vertex").c_str(),		"Vector-matrix case", vecIn, matIn, op, true));
-						opGroup->addChild(new ShaderMatrixCase(m_context, (vecMatName + "_fragment").c_str(),	"Vector-matrix case", vecIn, matIn, op, false));
-					}
-
-					if (isOperationMatrixMatrix(op))
-					{
-						// Matrix-matrix.
-						ShaderInput otherMatIn(inputType == INPUTTYPE_DYNAMIC ? INPUTTYPE_UNIFORM : inputType, matType, precision);
-						opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + matTypeName + "_vertex").c_str(),		"Matrix-matrix case", matIn, otherMatIn, op, true));
-						opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + matTypeName + "_fragment").c_str(),	"Matrix-matrix case", matIn, otherMatIn, op, false));
-					}
-
-					if (isOperationUnary(op))
-					{
-						// op matrix
-						ShaderInput voidInput(INPUTTYPE_LAST, TYPE_LAST, PRECISION_LAST);
-						opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "vertex").c_str(),		"Matrix case", matIn, voidInput, op, true));
-						opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "fragment").c_str(),	"Matrix case", matIn, voidInput, op, false));
-					}
-
-					if (isOperationAssignment(op))
-					{
-						ShaderInput otherMatIn(inputType == INPUTTYPE_DYNAMIC ? INPUTTYPE_UNIFORM : inputType, matType, precision);
-						opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "vertex").c_str(),		"Matrix assignment case", matIn, otherMatIn, op, true));
-						opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "fragment").c_str(),	"Matrix assignment case", matIn, otherMatIn, op, false));
-					}
-				}
-			}
-		}
-	}
+    static const struct
+    {
+        const char*     name;
+        const char*     desc;
+        MatrixOp        op;
+        bool            extendedInputTypeCases; // !< test with const and uniform types too
+    } ops[] =
+    {
+        { "add",            "Matrix addition tests",                        OP_ADD,             true    },
+        { "sub",            "Matrix subtraction tests",                     OP_SUB,             true    },
+        { "mul",            "Matrix multiplication tests",                  OP_MUL,             true    },
+        { "div",            "Matrix division tests",                        OP_DIV,             true    },
+        { "matrixcompmult", "Matrix component-wise multiplication tests",   OP_COMP_MUL,        false   },
+        { "unary_addition", "Matrix unary addition tests",                  OP_UNARY_PLUS,      false   },
+        { "negation",       "Matrix negation tests",                        OP_NEGATION,        false   },
+        { "pre_increment",  "Matrix prefix increment tests",                OP_PRE_INCREMENT,   false   },
+        { "pre_decrement",  "Matrix prefix decrement tests",                OP_PRE_DECREMENT,   false   },
+        { "post_increment", "Matrix postfix increment tests",               OP_POST_INCREMENT,  false   },
+        { "post_decrement", "Matrix postfix decrement tests",               OP_POST_DECREMENT,  false   },
+        { "add_assign",     "Matrix add into tests",                        OP_ADD_INTO,        false   },
+        { "sub_assign",     "Matrix subtract from tests",                   OP_SUBTRACT_FROM,   false   },
+        { "mul_assign",     "Matrix multiply into tests",                   OP_MULTIPLY_INTO,   false   },
+        { "div_assign",     "Matrix divide into tests",                     OP_DIVIDE_INTO,     false   },
+    };
+
+    struct InputTypeSpec
+    {
+        const char*     name;
+        const char*     desc;
+        InputType       type;
+    };
+    static const InputTypeSpec extendedInputTypes[] =
+    {
+        { "const",      "Constant matrix input",    INPUTTYPE_CONST     },
+        { "uniform",    "Uniform matrix input",     INPUTTYPE_UNIFORM   },
+        { "dynamic",    "Dynamic matrix input",     INPUTTYPE_DYNAMIC   }
+    };
+    static const InputTypeSpec reducedInputTypes[] =
+    {
+        { "dynamic",    "Dynamic matrix input",     INPUTTYPE_DYNAMIC   }
+    };
+
+    static const DataType matrixTypes[] =
+    {
+        TYPE_FLOAT_MAT2,
+        TYPE_FLOAT_MAT3,
+        TYPE_FLOAT_MAT4
+    };
+
+    static const Precision precisions[] =
+    {
+        PRECISION_LOWP,
+        PRECISION_MEDIUMP,
+        PRECISION_HIGHP
+    };
+
+    for (int opNdx = 0; opNdx < DE_LENGTH_OF_ARRAY(ops); opNdx++)
+    {
+        const InputTypeSpec*    inTypeList      = (ops[opNdx].extendedInputTypeCases) ? (extendedInputTypes) : (reducedInputTypes);
+        const int               inTypeListSize  = (ops[opNdx].extendedInputTypeCases) ? (DE_LENGTH_OF_ARRAY(extendedInputTypes)) : (DE_LENGTH_OF_ARRAY(reducedInputTypes));
+        const MatrixOp          op              = ops[opNdx].op;
+        tcu::TestCaseGroup*     opGroup         = new tcu::TestCaseGroup(m_testCtx, ops[opNdx].name, ops[opNdx].desc);
+
+        addChild(opGroup);
+
+        for (int inTypeNdx = 0; inTypeNdx < inTypeListSize; inTypeNdx++)
+        {
+            const InputType     inputType   = inTypeList[inTypeNdx].type;
+
+            for (int matTypeNdx = 0; matTypeNdx < DE_LENGTH_OF_ARRAY(matrixTypes); matTypeNdx++)
+            {
+                DataType    matType     = matrixTypes[matTypeNdx];
+                const char* matTypeName = getDataTypeName(matType);
+
+                for (int precNdx = 0; precNdx < DE_LENGTH_OF_ARRAY(precisions); precNdx++)
+                {
+                    Precision   precision   = precisions[precNdx];
+                    const char* precName    = getPrecisionName(precision);
+                    string      baseName    = string(inTypeList[inTypeNdx].name) + "_" + precName + "_" + matTypeName + "_";
+                    ShaderInput matIn       (inputType, matType, precision);
+
+                    if (isOperationMatrixScalar(op))
+                    {
+                        // Matrix-scalar \note For div cases we use uniform input.
+                        ShaderInput scalarIn(op == OP_DIV ? INPUTTYPE_UNIFORM : INPUTTYPE_DYNAMIC, TYPE_FLOAT, precision);
+                        opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_vertex").c_str(),      "Matrix-scalar case", matIn, scalarIn, op, true));
+                        opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_fragment").c_str(),    "Matrix-scalar case", matIn, scalarIn, op, false));
+                    }
+
+                    if (isOperationMatrixVector(op))
+                    {
+                        // Matrix-vector.
+                        DataType    vecType = getDataTypeFloatVec(getDataTypeMatrixNumColumns(matType));
+                        ShaderInput vecIn   (op == OP_DIV ? INPUTTYPE_UNIFORM : INPUTTYPE_DYNAMIC, vecType, precision);
+
+                        opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + getDataTypeName(vecType) + "_vertex").c_str(),    "Matrix-vector case", matIn, vecIn, op, true));
+                        opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + getDataTypeName(vecType) + "_fragment").c_str(),  "Matrix-vector case", matIn, vecIn, op, false));
+
+                        // Vector-matrix.
+                        string vecMatName = string(inTypeList[inTypeNdx].name) + "_" + precName + "_" + getDataTypeName(vecType) + "_" + matTypeName;
+                        opGroup->addChild(new ShaderMatrixCase(m_context, (vecMatName + "_vertex").c_str(),     "Vector-matrix case", vecIn, matIn, op, true));
+                        opGroup->addChild(new ShaderMatrixCase(m_context, (vecMatName + "_fragment").c_str(),   "Vector-matrix case", vecIn, matIn, op, false));
+                    }
+
+                    if (isOperationMatrixMatrix(op))
+                    {
+                        // Matrix-matrix.
+                        ShaderInput otherMatIn(inputType == INPUTTYPE_DYNAMIC ? INPUTTYPE_UNIFORM : inputType, matType, precision);
+                        opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + matTypeName + "_vertex").c_str(),     "Matrix-matrix case", matIn, otherMatIn, op, true));
+                        opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + matTypeName + "_fragment").c_str(),   "Matrix-matrix case", matIn, otherMatIn, op, false));
+                    }
+
+                    if (isOperationUnary(op))
+                    {
+                        // op matrix
+                        ShaderInput voidInput(INPUTTYPE_LAST, TYPE_LAST, PRECISION_LAST);
+                        opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "vertex").c_str(),        "Matrix case", matIn, voidInput, op, true));
+                        opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "fragment").c_str(),  "Matrix case", matIn, voidInput, op, false));
+                    }
+
+                    if (isOperationAssignment(op))
+                    {
+                        ShaderInput otherMatIn(inputType == INPUTTYPE_DYNAMIC ? INPUTTYPE_UNIFORM : inputType, matType, precision);
+                        opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "vertex").c_str(),        "Matrix assignment case", matIn, otherMatIn, op, true));
+                        opGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "fragment").c_str(),  "Matrix assignment case", matIn, otherMatIn, op, false));
+                    }
+                }
+            }
+        }
+    }
 }
 
 } // Functional
diff --git a/src/tests/deqp_support/es3fShaderMatrixTests.cpp b/src/tests/deqp_support/es3fShaderMatrixTests.cpp
index b18f8ba14..25784982c 100644
--- a/src/tests/deqp_support/es3fShaderMatrixTests.cpp
+++ b/src/tests/deqp_support/es3fShaderMatrixTests.cpp
@@ -77,127 +77,127 @@ using tcu::Mat4;
 // Uniform / constant values for tests.
 // \note Input1 should not contain 0 components as it is used as divisor in div cases.
 // \todo [2012-02-14 pyry] Make these dynamic.
-static const float	s_constInFloat[2]	= { 0.5f, -0.2f };
-static const Vec2	s_constInVec2[2]	= { Vec2(1.2f, 0.5f), Vec2(0.5f, 1.0f) };
-static const Vec3	s_constInVec3[2]	= { Vec3(1.1f, 0.1f, 0.5f), Vec3(-0.2f, 0.5f, 0.8f) };
-static const Vec4	s_constInVec4[2]	= { Vec4(1.4f, 0.2f, -0.5f, 0.7f), Vec4(0.2f, -1.0f, 0.5f, 0.8f) };
+static const float  s_constInFloat[2]   = { 0.5f, -0.2f };
+static const Vec2   s_constInVec2[2]    = { Vec2(1.2f, 0.5f), Vec2(0.5f, 1.0f) };
+static const Vec3   s_constInVec3[2]    = { Vec3(1.1f, 0.1f, 0.5f), Vec3(-0.2f, 0.5f, 0.8f) };
+static const Vec4   s_constInVec4[2]    = { Vec4(1.4f, 0.2f, -0.5f, 0.7f), Vec4(0.2f, -1.0f, 0.5f, 0.8f) };
 
 static const float s_constInMat2x2[2][4] =
 {
-	{
-		-0.1f,  1.0f,
-		-0.2f,  0.0f,
-	},
-	{
-		 0.8f,  0.1f,
-		 0.5f, -0.9f,
-	},
+    {
+        -0.1f,  1.0f,
+        -0.2f,  0.0f,
+    },
+    {
+         0.8f,  0.1f,
+         0.5f, -0.9f,
+    },
 };
 static const float s_constInMat3x2[2][6] =
 {
-	{
-		 0.8f, -0.3f,  0.3f,
-		 1.0f,  1.2f, -1.2f,
-	},
-	{
-		 1.2f, -1.0f,  0.5f,
-		-0.8f,  1.1f,  0.3f,
-	},
+    {
+         0.8f, -0.3f,  0.3f,
+         1.0f,  1.2f, -1.2f,
+    },
+    {
+         1.2f, -1.0f,  0.5f,
+        -0.8f,  1.1f,  0.3f,
+    },
 };
 static const float s_constInMat4x2[2][8] =
 {
-	{
-		-0.2f,  0.5f, 0.0f, -1.0f,
-		 1.2f, -0.5f, 0.3f, -0.9f,
-	},
-	{
-		1.0f,  0.1f, -1.1f,  0.6f,
-		0.8f, -1.2f, -1.1f,  0.7f,
-	},
+    {
+        -0.2f,  0.5f, 0.0f, -1.0f,
+         1.2f, -0.5f, 0.3f, -0.9f,
+    },
+    {
+        1.0f,  0.1f, -1.1f,  0.6f,
+        0.8f, -1.2f, -1.1f,  0.7f,
+    },
 };
 static const float s_constInMat2x3[2][6] =
 {
-	{
-		-0.6f, -0.1f,
-		-0.7f, -1.2f,
-		-0.2f,  0.0f,
-	},
-	{
-		 1.1f,  0.6f,
-		 0.8f,  1.0f,
-		 0.7f,  0.1f,
-	},
+    {
+        -0.6f, -0.1f,
+        -0.7f, -1.2f,
+        -0.2f,  0.0f,
+    },
+    {
+         1.1f,  0.6f,
+         0.8f,  1.0f,
+         0.7f,  0.1f,
+    },
 };
 static const float s_constInMat3x3[2][9] =
 {
-	{
-		-0.2f,  1.1f, 1.2f,
-		-1.0f,  1.2f, 0.5f,
-		 0.7f, -0.2f, 1.0f,
-	},
-	{
-		-0.1f, -0.1f,  0.1f,
-		-0.1f, -0.2f,  1.0f,
-		-0.5f,  0.1f, -0.4f,
-	},
+    {
+        -0.2f,  1.1f, 1.2f,
+        -1.0f,  1.2f, 0.5f,
+         0.7f, -0.2f, 1.0f,
+    },
+    {
+        -0.1f, -0.1f,  0.1f,
+        -0.1f, -0.2f,  1.0f,
+        -0.5f,  0.1f, -0.4f,
+    },
 };
 static const float s_constInMat4x3[2][12] =
 {
-	{
-		-0.9f,  0.0f,  0.6f,  0.2f,
-		 0.9f, -0.1f, -0.3f, -0.7f,
-		-0.1f,  0.1f,  1.0f,  0.0f,
-	},
-	{
-		 0.5f,  0.7f,  0.7f,  1.2f,
-		 1.1f,  0.1f,  1.0f, -1.0f,
-		-0.2f, -0.2f, -0.3f, -0.5f,
-	},
+    {
+        -0.9f,  0.0f,  0.6f,  0.2f,
+         0.9f, -0.1f, -0.3f, -0.7f,
+        -0.1f,  0.1f,  1.0f,  0.0f,
+    },
+    {
+         0.5f,  0.7f,  0.7f,  1.2f,
+         1.1f,  0.1f,  1.0f, -1.0f,
+        -0.2f, -0.2f, -0.3f, -0.5f,
+    },
 };
 static const float s_constInMat2x4[2][8] =
 {
-	{
-		-0.6f, -1.1f,
-		-0.6f, -0.6f,
-		-0.2f, -0.6f,
-		-0.1f, -0.1f,
-	},
-	{
-		-1.2f, -1.0f,
-		 0.7f, -1.0f,
-		 0.7f,  0.7f,
-		-0.4f, -0.3f,
-	},
+    {
+        -0.6f, -1.1f,
+        -0.6f, -0.6f,
+        -0.2f, -0.6f,
+        -0.1f, -0.1f,
+    },
+    {
+        -1.2f, -1.0f,
+         0.7f, -1.0f,
+         0.7f,  0.7f,
+        -0.4f, -0.3f,
+    },
 };
 static const float s_constInMat3x4[2][12] =
 {
-	{
-		 0.6f, -0.4f,  1.2f,
-		 0.9f,  0.8f,  0.4f,
-		 1.1f,  0.3f,  0.5f,
-		-0.2f,  0.0f,  1.1f,
-	},
-	{
-		-0.8f,  1.2f, -0.2f,
-		-1.1f, -0.9f, -0.5f,
-		-1.2f,  1.0f,  1.2f,
-		 0.1f, -0.7f, -0.5f,
-	},
+    {
+         0.6f, -0.4f,  1.2f,
+         0.9f,  0.8f,  0.4f,
+         1.1f,  0.3f,  0.5f,
+        -0.2f,  0.0f,  1.1f,
+    },
+    {
+        -0.8f,  1.2f, -0.2f,
+        -1.1f, -0.9f, -0.5f,
+        -1.2f,  1.0f,  1.2f,
+         0.1f, -0.7f, -0.5f,
+    },
 };
 static const float s_constInMat4x4[2][16] =
 {
-	{
-		 0.3f,  0.9f, -0.2f,  1.0f,
-		-0.4f, -0.6f,  0.6f, -1.0f,
-		-0.9f, -0.1f,  0.3f, -0.2f,
-		-0.3f, -0.9f,  1.0f,  0.1f,
-	},
-	{
-		 0.4f, -0.7f, -0.8f,  0.7f,
-		-0.4f, -0.8f,  0.6f, -0.3f,
-		 0.7f, -1.0f,  0.1f, -0.3f,
-		 0.2f,  0.6f,  0.4f, -1.0f,
-	},
+    {
+         0.3f,  0.9f, -0.2f,  1.0f,
+        -0.4f, -0.6f,  0.6f, -1.0f,
+        -0.9f, -0.1f,  0.3f, -0.2f,
+        -0.3f, -0.9f,  1.0f,  0.1f,
+    },
+    {
+         0.4f, -0.7f, -0.8f,  0.7f,
+        -0.4f, -0.8f,  0.6f, -0.3f,
+         0.7f, -1.0f,  0.1f, -0.3f,
+         0.2f,  0.6f,  0.4f, -1.0f,
+    },
 };
 
 namespace MatrixCaseUtils
@@ -205,49 +205,49 @@ namespace MatrixCaseUtils
 
 enum InputType
 {
-	INPUTTYPE_CONST = 0,
-	INPUTTYPE_UNIFORM,
-	INPUTTYPE_DYNAMIC,
+    INPUTTYPE_CONST = 0,
+    INPUTTYPE_UNIFORM,
+    INPUTTYPE_DYNAMIC,
 
-	INPUTTYPE_LAST
+    INPUTTYPE_LAST
 };
 
 struct ShaderInput
 {
-	ShaderInput (InputType inputType_, DataType dataType_, Precision precision_)
-		: inputType	(inputType_)
-		, dataType	(dataType_)
-		, precision	(precision_)
-	{
-	}
+    ShaderInput (InputType inputType_, DataType dataType_, Precision precision_)
+        : inputType (inputType_)
+        , dataType  (dataType_)
+        , precision (precision_)
+    {
+    }
 
-	InputType		inputType;
-	DataType		dataType;
-	Precision		precision;
+    InputType       inputType;
+    DataType        dataType;
+    Precision       precision;
 };
 
 enum MatrixOp
 {
-	OP_ADD = 0,
-	OP_SUB,
-	OP_MUL,
-	OP_DIV,
-	OP_COMP_MUL,
-	OP_OUTER_PRODUCT,
-	OP_TRANSPOSE,
-	OP_INVERSE,
-	OP_DETERMINANT,
-	OP_UNARY_PLUS,
-	OP_NEGATION,
-	OP_PRE_INCREMENT,
-	OP_PRE_DECREMENT,
-	OP_POST_INCREMENT,
-	OP_POST_DECREMENT,
-	OP_ADD_INTO,
-	OP_SUBTRACT_FROM,
-	OP_MULTIPLY_INTO,
-	OP_DIVIDE_INTO,
-	OP_LAST
+    OP_ADD = 0,
+    OP_SUB,
+    OP_MUL,
+    OP_DIV,
+    OP_COMP_MUL,
+    OP_OUTER_PRODUCT,
+    OP_TRANSPOSE,
+    OP_INVERSE,
+    OP_DETERMINANT,
+    OP_UNARY_PLUS,
+    OP_NEGATION,
+    OP_PRE_INCREMENT,
+    OP_PRE_DECREMENT,
+    OP_POST_INCREMENT,
+    OP_POST_DECREMENT,
+    OP_ADD_INTO,
+    OP_SUBTRACT_FROM,
+    OP_MULTIPLY_INTO,
+    OP_DIVIDE_INTO,
+    OP_LAST
 };
 
 // Type traits.
@@ -255,237 +255,237 @@ enum MatrixOp
 template <int DataT>
 struct TypeTraits;
 
-#define DECLARE_TYPE_TRAIT(DATATYPE, TYPE)	\
-template<>									\
-struct TypeTraits<DATATYPE> {				\
-	typedef TYPE Type;						\
+#define DECLARE_TYPE_TRAIT(DATATYPE, TYPE)  \
+template<>                                  \
+struct TypeTraits<DATATYPE> {               \
+    typedef TYPE Type;                      \
 }
 
-DECLARE_TYPE_TRAIT(TYPE_FLOAT,			float);
-DECLARE_TYPE_TRAIT(TYPE_FLOAT_VEC2,		tcu::Vec2);
-DECLARE_TYPE_TRAIT(TYPE_FLOAT_VEC3,		tcu::Vec3);
-DECLARE_TYPE_TRAIT(TYPE_FLOAT_VEC4,		tcu::Vec4);
-DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT2,		tcu::Mat2);
-DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT2X3,	tcu::Mat2x3);
-DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT2X4,	tcu::Mat2x4);
-DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT3X2,	tcu::Mat3x2);
-DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT3,		tcu::Mat3);
-DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT3X4,	tcu::Mat3x4);
-DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT4X2,	tcu::Mat4x2);
-DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT4X3,	tcu::Mat4x3);
-DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT4,		tcu::Mat4);
+DECLARE_TYPE_TRAIT(TYPE_FLOAT,          float);
+DECLARE_TYPE_TRAIT(TYPE_FLOAT_VEC2,     tcu::Vec2);
+DECLARE_TYPE_TRAIT(TYPE_FLOAT_VEC3,     tcu::Vec3);
+DECLARE_TYPE_TRAIT(TYPE_FLOAT_VEC4,     tcu::Vec4);
+DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT2,     tcu::Mat2);
+DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT2X3,   tcu::Mat2x3);
+DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT2X4,   tcu::Mat2x4);
+DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT3X2,   tcu::Mat3x2);
+DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT3,     tcu::Mat3);
+DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT3X4,   tcu::Mat3x4);
+DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT4X2,   tcu::Mat4x2);
+DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT4X3,   tcu::Mat4x3);
+DECLARE_TYPE_TRAIT(TYPE_FLOAT_MAT4,     tcu::Mat4);
 
 // Operation info
 
 enum OperationType
 {
-	OPERATIONTYPE_BINARY_OPERATOR = 0,
-	OPERATIONTYPE_BINARY_FUNCTION,
-	OPERATIONTYPE_UNARY_PREFIX_OPERATOR,
-	OPERATIONTYPE_UNARY_POSTFIX_OPERATOR,
-	OPERATIONTYPE_UNARY_FUNCTION,
-	OPERATIONTYPE_ASSIGNMENT,
+    OPERATIONTYPE_BINARY_OPERATOR = 0,
+    OPERATIONTYPE_BINARY_FUNCTION,
+    OPERATIONTYPE_UNARY_PREFIX_OPERATOR,
+    OPERATIONTYPE_UNARY_POSTFIX_OPERATOR,
+    OPERATIONTYPE_UNARY_FUNCTION,
+    OPERATIONTYPE_ASSIGNMENT,
 
-	OPERATIONTYPE_LAST
+    OPERATIONTYPE_LAST
 };
 
 static const char* getOperationName (MatrixOp op)
 {
-	switch (op)
-	{
-		case OP_ADD:			return "+";
-		case OP_SUB:			return "-";
-		case OP_MUL:			return "*";
-		case OP_DIV:			return "/";
-		case OP_COMP_MUL:		return "matrixCompMult";
-		case OP_OUTER_PRODUCT:	return "outerProduct";
-		case OP_TRANSPOSE:		return "transpose";
-		case OP_INVERSE:		return "inverse";
-		case OP_DETERMINANT:	return "determinant";
-		case OP_UNARY_PLUS:		return "+";
-		case OP_NEGATION:		return "-";
-		case OP_PRE_INCREMENT:	return "++";
-		case OP_PRE_DECREMENT:	return "--";
-		case OP_POST_INCREMENT:	return "++";
-		case OP_POST_DECREMENT:	return "--";
-		case OP_ADD_INTO:		return "+=";
-		case OP_SUBTRACT_FROM:	return "-=";
-		case OP_MULTIPLY_INTO:	return "*=";
-		case OP_DIVIDE_INTO:	return "/=";
-
-		default:
-			DE_ASSERT(DE_FALSE);
-			return "";
-	}
+    switch (op)
+    {
+        case OP_ADD:            return "+";
+        case OP_SUB:            return "-";
+        case OP_MUL:            return "*";
+        case OP_DIV:            return "/";
+        case OP_COMP_MUL:       return "matrixCompMult";
+        case OP_OUTER_PRODUCT:  return "outerProduct";
+        case OP_TRANSPOSE:      return "transpose";
+        case OP_INVERSE:        return "inverse";
+        case OP_DETERMINANT:    return "determinant";
+        case OP_UNARY_PLUS:     return "+";
+        case OP_NEGATION:       return "-";
+        case OP_PRE_INCREMENT:  return "++";
+        case OP_PRE_DECREMENT:  return "--";
+        case OP_POST_INCREMENT: return "++";
+        case OP_POST_DECREMENT: return "--";
+        case OP_ADD_INTO:       return "+=";
+        case OP_SUBTRACT_FROM:  return "-=";
+        case OP_MULTIPLY_INTO:  return "*=";
+        case OP_DIVIDE_INTO:    return "/=";
+
+        default:
+            DE_ASSERT(DE_FALSE);
+            return "";
+    }
 }
 
 static OperationType getOperationType (MatrixOp op)
 {
-	switch (op)
-	{
-		case OP_ADD:			return OPERATIONTYPE_BINARY_OPERATOR;
-		case OP_SUB:			return OPERATIONTYPE_BINARY_OPERATOR;
-		case OP_MUL:			return OPERATIONTYPE_BINARY_OPERATOR;
-		case OP_DIV:			return OPERATIONTYPE_BINARY_OPERATOR;
-		case OP_COMP_MUL:		return OPERATIONTYPE_BINARY_FUNCTION;
-		case OP_OUTER_PRODUCT:	return OPERATIONTYPE_BINARY_FUNCTION;
-		case OP_TRANSPOSE:		return OPERATIONTYPE_UNARY_FUNCTION;
-		case OP_INVERSE:		return OPERATIONTYPE_UNARY_FUNCTION;
-		case OP_DETERMINANT:	return OPERATIONTYPE_UNARY_FUNCTION;
-		case OP_UNARY_PLUS:		return OPERATIONTYPE_UNARY_PREFIX_OPERATOR;
-		case OP_NEGATION:		return OPERATIONTYPE_UNARY_PREFIX_OPERATOR;
-		case OP_PRE_INCREMENT:	return OPERATIONTYPE_UNARY_PREFIX_OPERATOR;
-		case OP_PRE_DECREMENT:	return OPERATIONTYPE_UNARY_PREFIX_OPERATOR;
-		case OP_POST_INCREMENT:	return OPERATIONTYPE_UNARY_POSTFIX_OPERATOR;
-		case OP_POST_DECREMENT:	return OPERATIONTYPE_UNARY_POSTFIX_OPERATOR;
-		case OP_ADD_INTO:		return OPERATIONTYPE_ASSIGNMENT;
-		case OP_SUBTRACT_FROM:	return OPERATIONTYPE_ASSIGNMENT;
-		case OP_MULTIPLY_INTO:	return OPERATIONTYPE_ASSIGNMENT;
-		case OP_DIVIDE_INTO:	return OPERATIONTYPE_ASSIGNMENT;
-		default:
-			DE_ASSERT(DE_FALSE);
-			return OPERATIONTYPE_LAST;
-	}
+    switch (op)
+    {
+        case OP_ADD:            return OPERATIONTYPE_BINARY_OPERATOR;
+        case OP_SUB:            return OPERATIONTYPE_BINARY_OPERATOR;
+        case OP_MUL:            return OPERATIONTYPE_BINARY_OPERATOR;
+        case OP_DIV:            return OPERATIONTYPE_BINARY_OPERATOR;
+        case OP_COMP_MUL:       return OPERATIONTYPE_BINARY_FUNCTION;
+        case OP_OUTER_PRODUCT:  return OPERATIONTYPE_BINARY_FUNCTION;
+        case OP_TRANSPOSE:      return OPERATIONTYPE_UNARY_FUNCTION;
+        case OP_INVERSE:        return OPERATIONTYPE_UNARY_FUNCTION;
+        case OP_DETERMINANT:    return OPERATIONTYPE_UNARY_FUNCTION;
+        case OP_UNARY_PLUS:     return OPERATIONTYPE_UNARY_PREFIX_OPERATOR;
+        case OP_NEGATION:       return OPERATIONTYPE_UNARY_PREFIX_OPERATOR;
+        case OP_PRE_INCREMENT:  return OPERATIONTYPE_UNARY_PREFIX_OPERATOR;
+        case OP_PRE_DECREMENT:  return OPERATIONTYPE_UNARY_PREFIX_OPERATOR;
+        case OP_POST_INCREMENT: return OPERATIONTYPE_UNARY_POSTFIX_OPERATOR;
+        case OP_POST_DECREMENT: return OPERATIONTYPE_UNARY_POSTFIX_OPERATOR;
+        case OP_ADD_INTO:       return OPERATIONTYPE_ASSIGNMENT;
+        case OP_SUBTRACT_FROM:  return OPERATIONTYPE_ASSIGNMENT;
+        case OP_MULTIPLY_INTO:  return OPERATIONTYPE_ASSIGNMENT;
+        case OP_DIVIDE_INTO:    return OPERATIONTYPE_ASSIGNMENT;
+        default:
+            DE_ASSERT(DE_FALSE);
+            return OPERATIONTYPE_LAST;
+    }
 }
 
 enum TestMatrixType
 {
-	TESTMATRIXTYPE_DEFAULT = 0,
-	TESTMATRIXTYPE_NEGATED,
-	TESTMATRIXTYPE_INCREMENTED,
-	TESTMATRIXTYPE_DECREMENTED,
-	TESTMATRIXTYPE_NEGATED_INCREMENTED,
-	TESTMATRIXTYPE_INCREMENTED_LESS,
+    TESTMATRIXTYPE_DEFAULT = 0,
+    TESTMATRIXTYPE_NEGATED,
+    TESTMATRIXTYPE_INCREMENTED,
+    TESTMATRIXTYPE_DECREMENTED,
+    TESTMATRIXTYPE_NEGATED_INCREMENTED,
+    TESTMATRIXTYPE_INCREMENTED_LESS,
 
-	TESTMATRIXTYPE_LAST
+    TESTMATRIXTYPE_LAST
 };
 
 static TestMatrixType getOperationTestMatrixType (MatrixOp op)
 {
-	switch(op)
-	{
-		case OP_ADD:			return TESTMATRIXTYPE_DEFAULT;
-		case OP_SUB:			return TESTMATRIXTYPE_DEFAULT;
-		case OP_MUL:			return TESTMATRIXTYPE_DEFAULT;
-		case OP_DIV:			return TESTMATRIXTYPE_DEFAULT;
-		case OP_COMP_MUL:		return TESTMATRIXTYPE_DEFAULT;
-		case OP_OUTER_PRODUCT:	return TESTMATRIXTYPE_DEFAULT;
-		case OP_TRANSPOSE:		return TESTMATRIXTYPE_DEFAULT;
-		case OP_INVERSE:		return TESTMATRIXTYPE_DEFAULT;
-		case OP_DETERMINANT:	return TESTMATRIXTYPE_DEFAULT;
-		case OP_UNARY_PLUS:		return TESTMATRIXTYPE_DECREMENTED;
-		case OP_NEGATION:		return TESTMATRIXTYPE_NEGATED_INCREMENTED;
-		case OP_PRE_INCREMENT:	return TESTMATRIXTYPE_NEGATED;
-		case OP_PRE_DECREMENT:	return TESTMATRIXTYPE_INCREMENTED;
-		case OP_POST_INCREMENT:	return TESTMATRIXTYPE_NEGATED;
-		case OP_POST_DECREMENT:	return TESTMATRIXTYPE_DEFAULT;
-		case OP_ADD_INTO:		return TESTMATRIXTYPE_DEFAULT;
-		case OP_SUBTRACT_FROM:	return TESTMATRIXTYPE_INCREMENTED_LESS;
-		case OP_MULTIPLY_INTO:	return TESTMATRIXTYPE_NEGATED;
-		case OP_DIVIDE_INTO:	return TESTMATRIXTYPE_DECREMENTED;
-
-		default:
-			DE_ASSERT(DE_FALSE);
-			return TESTMATRIXTYPE_LAST;
-	}
+    switch(op)
+    {
+        case OP_ADD:            return TESTMATRIXTYPE_DEFAULT;
+        case OP_SUB:            return TESTMATRIXTYPE_DEFAULT;
+        case OP_MUL:            return TESTMATRIXTYPE_DEFAULT;
+        case OP_DIV:            return TESTMATRIXTYPE_DEFAULT;
+        case OP_COMP_MUL:       return TESTMATRIXTYPE_DEFAULT;
+        case OP_OUTER_PRODUCT:  return TESTMATRIXTYPE_DEFAULT;
+        case OP_TRANSPOSE:      return TESTMATRIXTYPE_DEFAULT;
+        case OP_INVERSE:        return TESTMATRIXTYPE_DEFAULT;
+        case OP_DETERMINANT:    return TESTMATRIXTYPE_DEFAULT;
+        case OP_UNARY_PLUS:     return TESTMATRIXTYPE_DECREMENTED;
+        case OP_NEGATION:       return TESTMATRIXTYPE_NEGATED_INCREMENTED;
+        case OP_PRE_INCREMENT:  return TESTMATRIXTYPE_NEGATED;
+        case OP_PRE_DECREMENT:  return TESTMATRIXTYPE_INCREMENTED;
+        case OP_POST_INCREMENT: return TESTMATRIXTYPE_NEGATED;
+        case OP_POST_DECREMENT: return TESTMATRIXTYPE_DEFAULT;
+        case OP_ADD_INTO:       return TESTMATRIXTYPE_DEFAULT;
+        case OP_SUBTRACT_FROM:  return TESTMATRIXTYPE_INCREMENTED_LESS;
+        case OP_MULTIPLY_INTO:  return TESTMATRIXTYPE_NEGATED;
+        case OP_DIVIDE_INTO:    return TESTMATRIXTYPE_DECREMENTED;
+
+        default:
+            DE_ASSERT(DE_FALSE);
+            return TESTMATRIXTYPE_LAST;
+    }
 }
 
 static bool isOperationBinary (MatrixOp op)
 {
-	return getOperationType(op) == OPERATIONTYPE_BINARY_OPERATOR ||
-	       getOperationType(op) == OPERATIONTYPE_BINARY_FUNCTION ||
-	       getOperationType(op) == OPERATIONTYPE_ASSIGNMENT;
+    return getOperationType(op) == OPERATIONTYPE_BINARY_OPERATOR ||
+           getOperationType(op) == OPERATIONTYPE_BINARY_FUNCTION ||
+           getOperationType(op) == OPERATIONTYPE_ASSIGNMENT;
 }
 
 static bool isOperationMatrixScalar (MatrixOp op)
 {
-	return op == OP_ADD || op == OP_SUB || op == OP_MUL || op == OP_DIV;
+    return op == OP_ADD || op == OP_SUB || op == OP_MUL || op == OP_DIV;
 }
 
 static bool isOperationMatrixVector (MatrixOp op)
 {
-	return op == OP_MUL;
+    return op == OP_MUL;
 }
 
 static bool isOperationArithmeticMatrixMatrix (MatrixOp op)
 {
-	return op == OP_MUL;
+    return op == OP_MUL;
 }
 
 static bool isOperationComponentwiseMatrixMatrix (MatrixOp op)
 {
-	return op == OP_ADD || op == OP_SUB || op == OP_MUL || op == OP_DIV || op == OP_COMP_MUL;
+    return op == OP_ADD || op == OP_SUB || op == OP_MUL || op == OP_DIV || op == OP_COMP_MUL;
 }
 
 static bool isOperationVectorVector (MatrixOp op)
 {
-	return op == OP_OUTER_PRODUCT;
+    return op == OP_OUTER_PRODUCT;
 }
 
 static bool isOperationUnaryAnyMatrix (MatrixOp op)
 {
-	return  op == OP_TRANSPOSE			 ||
-			op == OP_UNARY_PLUS			 ||
-			op == OP_NEGATION			 ||
-			op == OP_PRE_INCREMENT		 ||
-			op == OP_PRE_DECREMENT		 ||
-			op == OP_POST_INCREMENT		 ||
-			op == OP_POST_DECREMENT;
+    return  op == OP_TRANSPOSE           ||
+            op == OP_UNARY_PLUS          ||
+            op == OP_NEGATION            ||
+            op == OP_PRE_INCREMENT       ||
+            op == OP_PRE_DECREMENT       ||
+            op == OP_POST_INCREMENT      ||
+            op == OP_POST_DECREMENT;
 }
 
 static bool isOperationUnarySymmetricMatrix (MatrixOp op)
 {
-	return op == OP_INVERSE || op == OP_DETERMINANT;
+    return op == OP_INVERSE || op == OP_DETERMINANT;
 }
 
 static bool isOperationValueModifying (MatrixOp op)
 {
-	return  op == OP_PRE_INCREMENT		 ||
-			op == OP_PRE_DECREMENT		 ||
-			op == OP_POST_INCREMENT		 ||
-			op == OP_POST_DECREMENT;
+    return  op == OP_PRE_INCREMENT       ||
+            op == OP_PRE_DECREMENT       ||
+            op == OP_POST_INCREMENT      ||
+            op == OP_POST_DECREMENT;
 }
 
 static bool isOperationAssignment (MatrixOp op)
 {
-	return  op == OP_ADD_INTO		 ||
-			op == OP_SUBTRACT_FROM	 ||
-			op == OP_MULTIPLY_INTO	 ||
-			op == OP_DIVIDE_INTO;
+    return  op == OP_ADD_INTO        ||
+            op == OP_SUBTRACT_FROM   ||
+            op == OP_MULTIPLY_INTO   ||
+            op == OP_DIVIDE_INTO;
 }
 
 static bool isOperationAssignmentAnyMatrix (MatrixOp op)
 {
-	return  op == OP_ADD_INTO		 ||
-			op == OP_SUBTRACT_FROM	 ||
-			op == OP_DIVIDE_INTO;
+    return  op == OP_ADD_INTO        ||
+            op == OP_SUBTRACT_FROM   ||
+            op == OP_DIVIDE_INTO;
 }
 
 static bool isOperationAssignmentSymmetricMatrix (MatrixOp op)
 {
-	return op == OP_MULTIPLY_INTO;
+    return op == OP_MULTIPLY_INTO;
 }
 
 // Operation nature
 
 enum OperationNature
 {
-	OPERATIONNATURE_PURE = 0,
-	OPERATIONNATURE_MUTATING,
-	OPERATIONNATURE_ASSIGNMENT,
+    OPERATIONNATURE_PURE = 0,
+    OPERATIONNATURE_MUTATING,
+    OPERATIONNATURE_ASSIGNMENT,
 
-	OPERATIONNATURE_LAST
+    OPERATIONNATURE_LAST
 };
 
 static OperationNature getOperationNature (MatrixOp op)
 {
-	if (isOperationAssignment(op))
-		return OPERATIONNATURE_ASSIGNMENT;
+    if (isOperationAssignment(op))
+        return OPERATIONNATURE_ASSIGNMENT;
 
-	if (isOperationValueModifying(op))
-		return OPERATIONNATURE_MUTATING;
+    if (isOperationValueModifying(op))
+        return OPERATIONNATURE_MUTATING;
 
-	return OPERATIONNATURE_PURE;
+    return OPERATIONNATURE_PURE;
 }
 
 // Input value loader.
@@ -493,143 +493,143 @@ static OperationNature getOperationNature (MatrixOp op)
 template <int InputT, int DataT>
 typename TypeTraits<DataT>::Type getInputValue (const ShaderEvalContext& evalCtx, int inputNdx);
 
-template <> inline float		getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT>			(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInFloat[inputNdx];	}
-template <> inline tcu::Vec2	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_VEC2>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInVec2[inputNdx];	}
-template <> inline tcu::Vec3	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_VEC3>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInVec3[inputNdx];	}
-template <> inline tcu::Vec4	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_VEC4>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInVec4[inputNdx];	}
-
-template <> inline tcu::Mat2	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_MAT2>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat2(s_constInMat2x2[inputNdx]);		}
-template <> inline tcu::Mat2x3	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_MAT2X3>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat2x3(s_constInMat2x3[inputNdx]);	}
-template <> inline tcu::Mat2x4	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_MAT2X4>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat2x4(s_constInMat2x4[inputNdx]);	}
-template <> inline tcu::Mat3x2	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_MAT3X2>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat3x2(s_constInMat3x2[inputNdx]);	}
-template <> inline tcu::Mat3	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_MAT3>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat3(s_constInMat3x3[inputNdx]);		}
-template <> inline tcu::Mat3x4	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_MAT3X4>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat3x4(s_constInMat3x4[inputNdx]);	}
-template <> inline tcu::Mat4x2	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_MAT4X2>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat4x2(s_constInMat4x2[inputNdx]);	}
-template <> inline tcu::Mat4x3	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_MAT4X3>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat4x3(s_constInMat4x3[inputNdx]);	}
-template <> inline tcu::Mat4	getInputValue<INPUTTYPE_CONST,		TYPE_FLOAT_MAT4>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat4(s_constInMat4x4[inputNdx]);		}
-
-template <> inline float		getInputValue<INPUTTYPE_DYNAMIC,	TYPE_FLOAT>			(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(inputNdx); return evalCtx.coords.x();					}
-template <> inline tcu::Vec2	getInputValue<INPUTTYPE_DYNAMIC,	TYPE_FLOAT_VEC2>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(inputNdx); return evalCtx.coords.swizzle(0, 1);			}
-template <> inline tcu::Vec3	getInputValue<INPUTTYPE_DYNAMIC,	TYPE_FLOAT_VEC3>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(inputNdx); return evalCtx.coords.swizzle(0, 1, 2);		}
-template <> inline tcu::Vec4	getInputValue<INPUTTYPE_DYNAMIC,	TYPE_FLOAT_VEC4>	(const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(inputNdx); return evalCtx.coords.swizzle(0, 1, 2, 3);	}
+template <> inline float        getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT>         (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInFloat[inputNdx];  }
+template <> inline tcu::Vec2    getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_VEC2>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInVec2[inputNdx];   }
+template <> inline tcu::Vec3    getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_VEC3>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInVec3[inputNdx];   }
+template <> inline tcu::Vec4    getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_VEC4>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return s_constInVec4[inputNdx];   }
+
+template <> inline tcu::Mat2    getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_MAT2>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat2(s_constInMat2x2[inputNdx]);      }
+template <> inline tcu::Mat2x3  getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_MAT2X3>  (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat2x3(s_constInMat2x3[inputNdx]);    }
+template <> inline tcu::Mat2x4  getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_MAT2X4>  (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat2x4(s_constInMat2x4[inputNdx]);    }
+template <> inline tcu::Mat3x2  getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_MAT3X2>  (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat3x2(s_constInMat3x2[inputNdx]);    }
+template <> inline tcu::Mat3    getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_MAT3>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat3(s_constInMat3x3[inputNdx]);      }
+template <> inline tcu::Mat3x4  getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_MAT3X4>  (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat3x4(s_constInMat3x4[inputNdx]);    }
+template <> inline tcu::Mat4x2  getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_MAT4X2>  (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat4x2(s_constInMat4x2[inputNdx]);    }
+template <> inline tcu::Mat4x3  getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_MAT4X3>  (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat4x3(s_constInMat4x3[inputNdx]);    }
+template <> inline tcu::Mat4    getInputValue<INPUTTYPE_CONST,      TYPE_FLOAT_MAT4>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(evalCtx); return tcu::Mat4(s_constInMat4x4[inputNdx]);      }
+
+template <> inline float        getInputValue<INPUTTYPE_DYNAMIC,    TYPE_FLOAT>         (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(inputNdx); return evalCtx.coords.x();                   }
+template <> inline tcu::Vec2    getInputValue<INPUTTYPE_DYNAMIC,    TYPE_FLOAT_VEC2>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(inputNdx); return evalCtx.coords.swizzle(0, 1);         }
+template <> inline tcu::Vec3    getInputValue<INPUTTYPE_DYNAMIC,    TYPE_FLOAT_VEC3>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(inputNdx); return evalCtx.coords.swizzle(0, 1, 2);      }
+template <> inline tcu::Vec4    getInputValue<INPUTTYPE_DYNAMIC,    TYPE_FLOAT_VEC4>    (const ShaderEvalContext& evalCtx, int inputNdx) { DE_UNREF(inputNdx); return evalCtx.coords.swizzle(0, 1, 2, 3);   }
 
 template <> inline tcu::Mat2 getInputValue<INPUTTYPE_DYNAMIC, TYPE_FLOAT_MAT2> (const ShaderEvalContext& evalCtx, int inputNdx)
 {
-	DE_UNREF(inputNdx); // Not used.
-	tcu::Mat2 m;
-	m.setColumn(0, evalCtx.in[0].swizzle(0,1));
-	m.setColumn(1, evalCtx.in[1].swizzle(0,1));
-	return m;
+    DE_UNREF(inputNdx); // Not used.
+    tcu::Mat2 m;
+    m.setColumn(0, evalCtx.in[0].swizzle(0,1));
+    m.setColumn(1, evalCtx.in[1].swizzle(0,1));
+    return m;
 }
 
 template <> inline tcu::Mat2x3 getInputValue<INPUTTYPE_DYNAMIC, TYPE_FLOAT_MAT2X3> (const ShaderEvalContext& evalCtx, int inputNdx)
 {
-	DE_UNREF(inputNdx); // Not used.
-	tcu::Mat2x3 m;
-	m.setColumn(0, evalCtx.in[0].swizzle(0,1,2));
-	m.setColumn(1, evalCtx.in[1].swizzle(0,1,2));
-	return m;
+    DE_UNREF(inputNdx); // Not used.
+    tcu::Mat2x3 m;
+    m.setColumn(0, evalCtx.in[0].swizzle(0,1,2));
+    m.setColumn(1, evalCtx.in[1].swizzle(0,1,2));
+    return m;
 }
 
 template <> inline tcu::Mat2x4 getInputValue<INPUTTYPE_DYNAMIC, TYPE_FLOAT_MAT2X4> (const ShaderEvalContext& evalCtx, int inputNdx)
 {
-	DE_UNREF(inputNdx); // Not used.
-	tcu::Mat2x4 m;
-	m.setColumn(0, evalCtx.in[0]);
-	m.setColumn(1, evalCtx.in[1]);
-	return m;
+    DE_UNREF(inputNdx); // Not used.
+    tcu::Mat2x4 m;
+    m.setColumn(0, evalCtx.in[0]);
+    m.setColumn(1, evalCtx.in[1]);
+    return m;
 }
 
 template <> inline tcu::Mat3x2 getInputValue<INPUTTYPE_DYNAMIC, TYPE_FLOAT_MAT3X2> (const ShaderEvalContext& evalCtx, int inputNdx)
 {
-	DE_UNREF(inputNdx); // Not used.
-	tcu::Mat3x2 m;
-	m.setColumn(0, evalCtx.in[0].swizzle(0,1));
-	m.setColumn(1, evalCtx.in[1].swizzle(0,1));
-	m.setColumn(2, evalCtx.in[2].swizzle(0,1));
-	return m;
+    DE_UNREF(inputNdx); // Not used.
+    tcu::Mat3x2 m;
+    m.setColumn(0, evalCtx.in[0].swizzle(0,1));
+    m.setColumn(1, evalCtx.in[1].swizzle(0,1));
+    m.setColumn(2, evalCtx.in[2].swizzle(0,1));
+    return m;
 }
 
 template <> inline tcu::Mat3 getInputValue<INPUTTYPE_DYNAMIC, TYPE_FLOAT_MAT3> (const ShaderEvalContext& evalCtx, int inputNdx)
 {
-	DE_UNREF(inputNdx); // Not used.
-	tcu::Mat3 m;
-	m.setColumn(0, evalCtx.in[0].swizzle(0,1,2));
-	m.setColumn(1, evalCtx.in[1].swizzle(0,1,2));
-	m.setColumn(2, evalCtx.in[2].swizzle(0,1,2));
-	return m;
+    DE_UNREF(inputNdx); // Not used.
+    tcu::Mat3 m;
+    m.setColumn(0, evalCtx.in[0].swizzle(0,1,2));
+    m.setColumn(1, evalCtx.in[1].swizzle(0,1,2));
+    m.setColumn(2, evalCtx.in[2].swizzle(0,1,2));
+    return m;
 }
 
 template <> inline tcu::Mat3x4 getInputValue<INPUTTYPE_DYNAMIC, TYPE_FLOAT_MAT3X4> (const ShaderEvalContext& evalCtx, int inputNdx)
 {
-	DE_UNREF(inputNdx); // Not used.
-	tcu::Mat3x4 m;
-	m.setColumn(0, evalCtx.in[0]);
-	m.setColumn(1, evalCtx.in[1]);
-	m.setColumn(2, evalCtx.in[2]);
-	return m;
+    DE_UNREF(inputNdx); // Not used.
+    tcu::Mat3x4 m;
+    m.setColumn(0, evalCtx.in[0]);
+    m.setColumn(1, evalCtx.in[1]);
+    m.setColumn(2, evalCtx.in[2]);
+    return m;
 }
 
 template <> inline tcu::Mat4x2 getInputValue<INPUTTYPE_DYNAMIC, TYPE_FLOAT_MAT4X2> (const ShaderEvalContext& evalCtx, int inputNdx)
 {
-	DE_UNREF(inputNdx); // Not used.
-	tcu::Mat4x2 m;
-	m.setColumn(0, evalCtx.in[0].swizzle(0,1));
-	m.setColumn(1, evalCtx.in[1].swizzle(0,1));
-	m.setColumn(2, evalCtx.in[2].swizzle(0,1));
-	m.setColumn(3, evalCtx.in[3].swizzle(0,1));
-	return m;
+    DE_UNREF(inputNdx); // Not used.
+    tcu::Mat4x2 m;
+    m.setColumn(0, evalCtx.in[0].swizzle(0,1));
+    m.setColumn(1, evalCtx.in[1].swizzle(0,1));
+    m.setColumn(2, evalCtx.in[2].swizzle(0,1));
+    m.setColumn(3, evalCtx.in[3].swizzle(0,1));
+    return m;
 }
 
 template <> inline tcu::Mat4x3 getInputValue<INPUTTYPE_DYNAMIC, TYPE_FLOAT_MAT4X3> (const ShaderEvalContext& evalCtx, int inputNdx)
 {
-	DE_UNREF(inputNdx); // Not used.
-	tcu::Mat4x3 m;
-	m.setColumn(0, evalCtx.in[0].swizzle(0,1,2));
-	m.setColumn(1, evalCtx.in[1].swizzle(0,1,2));
-	m.setColumn(2, evalCtx.in[2].swizzle(0,1,2));
-	m.setColumn(3, evalCtx.in[3].swizzle(0,1,2));
-	return m;
+    DE_UNREF(inputNdx); // Not used.
+    tcu::Mat4x3 m;
+    m.setColumn(0, evalCtx.in[0].swizzle(0,1,2));
+    m.setColumn(1, evalCtx.in[1].swizzle(0,1,2));
+    m.setColumn(2, evalCtx.in[2].swizzle(0,1,2));
+    m.setColumn(3, evalCtx.in[3].swizzle(0,1,2));
+    return m;
 }
 
 template <> inline tcu::Mat4 getInputValue<INPUTTYPE_DYNAMIC, TYPE_FLOAT_MAT4> (const ShaderEvalContext& evalCtx, int inputNdx)
 {
-	DE_UNREF(inputNdx); // Not used.
-	tcu::Mat4 m;
-	m.setColumn(0, evalCtx.in[0]);
-	m.setColumn(1, evalCtx.in[1]);
-	m.setColumn(2, evalCtx.in[2]);
-	m.setColumn(3, evalCtx.in[3]);
-	return m;
+    DE_UNREF(inputNdx); // Not used.
+    tcu::Mat4 m;
+    m.setColumn(0, evalCtx.in[0]);
+    m.setColumn(1, evalCtx.in[1]);
+    m.setColumn(2, evalCtx.in[2]);
+    m.setColumn(3, evalCtx.in[3]);
+    return m;
 }
 
 // Reduction from expression result to vec3.
 
-inline tcu::Vec3 reduceToVec3 (const tcu::Vec2& value)		{ return value.swizzle(0,1,0); }
-inline tcu::Vec3 reduceToVec3 (const tcu::Vec3& value)		{ return value; }
-inline tcu::Vec3 reduceToVec3 (const tcu::Vec4& value)		{ return tcu::Vec3(value.x(), value.y(), value.z()+value.w()); }
-inline tcu::Vec3 reduceToVec3 (const tcu::Mat2& value)		{ return tcu::Vec3(value(0, 0), value(0, 1), value(1, 0)+value(1, 1)); }
-inline tcu::Vec3 reduceToVec3 (const tcu::Mat2x3& value)	{ return value.getColumn(0) + value.getColumn(1); }
-inline tcu::Vec3 reduceToVec3 (const tcu::Mat2x4& value)	{ return value.getColumn(0).swizzle(0,1,2) + value.getColumn(1).swizzle(1,2,3); }
-inline tcu::Vec3 reduceToVec3 (const tcu::Mat3x2& value)	{ return tcu::Vec3(value(0,0)+value(1,0), value(0,1)+value(1,1), value(0,2)+value(1,2)); }
-inline tcu::Vec3 reduceToVec3 (const tcu::Mat3& value)		{ return value.getColumn(0) + value.getColumn(1) + value.getColumn(2); }
-inline tcu::Vec3 reduceToVec3 (const tcu::Mat3x4& value)	{ return value.getColumn(0).swizzle(0,1,2) + value.getColumn(1).swizzle(1,2,3) + value.getColumn(2).swizzle(2,3,0); }
-inline tcu::Vec3 reduceToVec3 (const tcu::Mat4x2& value)	{ return tcu::Vec3(value(0,0)+value(1,0)+value(0,3), value(0,1)+value(1,1)+value(1,3), value(0,2)+value(1,2)); }
-inline tcu::Vec3 reduceToVec3 (const tcu::Mat4x3& value)	{ return value.getColumn(0) + value.getColumn(1) + value.getColumn(2) + value.getColumn(3); }
-inline tcu::Vec3 reduceToVec3 (const tcu::Mat4& value)		{ return value.getColumn(0).swizzle(0,1,2) + value.getColumn(1).swizzle(1,2,3) + value.getColumn(2).swizzle(2,3,0) + value.getColumn(3).swizzle(3,0,1); }
+inline tcu::Vec3 reduceToVec3 (const tcu::Vec2& value)      { return value.swizzle(0,1,0); }
+inline tcu::Vec3 reduceToVec3 (const tcu::Vec3& value)      { return value; }
+inline tcu::Vec3 reduceToVec3 (const tcu::Vec4& value)      { return tcu::Vec3(value.x(), value.y(), value.z()+value.w()); }
+inline tcu::Vec3 reduceToVec3 (const tcu::Mat2& value)      { return tcu::Vec3(value(0, 0), value(0, 1), value(1, 0)+value(1, 1)); }
+inline tcu::Vec3 reduceToVec3 (const tcu::Mat2x3& value)    { return value.getColumn(0) + value.getColumn(1); }
+inline tcu::Vec3 reduceToVec3 (const tcu::Mat2x4& value)    { return value.getColumn(0).swizzle(0,1,2) + value.getColumn(1).swizzle(1,2,3); }
+inline tcu::Vec3 reduceToVec3 (const tcu::Mat3x2& value)    { return tcu::Vec3(value(0,0)+value(1,0), value(0,1)+value(1,1), value(0,2)+value(1,2)); }
+inline tcu::Vec3 reduceToVec3 (const tcu::Mat3& value)      { return value.getColumn(0) + value.getColumn(1) + value.getColumn(2); }
+inline tcu::Vec3 reduceToVec3 (const tcu::Mat3x4& value)    { return value.getColumn(0).swizzle(0,1,2) + value.getColumn(1).swizzle(1,2,3) + value.getColumn(2).swizzle(2,3,0); }
+inline tcu::Vec3 reduceToVec3 (const tcu::Mat4x2& value)    { return tcu::Vec3(value(0,0)+value(1,0)+value(0,3), value(0,1)+value(1,1)+value(1,3), value(0,2)+value(1,2)); }
+inline tcu::Vec3 reduceToVec3 (const tcu::Mat4x3& value)    { return value.getColumn(0) + value.getColumn(1) + value.getColumn(2) + value.getColumn(3); }
+inline tcu::Vec3 reduceToVec3 (const tcu::Mat4& value)      { return value.getColumn(0).swizzle(0,1,2) + value.getColumn(1).swizzle(1,2,3) + value.getColumn(2).swizzle(2,3,0) + value.getColumn(3).swizzle(3,0,1); }
 
 // matrixCompMult
 
 template <typename T, int Rows, int Cols>
 tcu::Matrix<T, Rows, Cols> matrixCompMult (const tcu::Matrix<T, Rows, Cols>& a, const tcu::Matrix<T, Rows, Cols>& b)
 {
-	tcu::Matrix<T, Rows, Cols> retVal;
+    tcu::Matrix<T, Rows, Cols> retVal;
 
-	for (int r = 0; r < Rows; ++r)
-		for (int c = 0; c < Cols; ++c)
-			retVal(r,c) = a(r,c) * b(r, c);
+    for (int r = 0; r < Rows; ++r)
+        for (int c = 0; c < Cols; ++c)
+            retVal(r,c) = a(r,c) * b(r, c);
 
-	return retVal;
+    return retVal;
 }
 
 // transpose
@@ -637,13 +637,13 @@ tcu::Matrix<T, Rows, Cols> matrixCompMult (const tcu::Matrix<T, Rows, Cols>& a,
 template <typename T, int Rows, int Cols>
 tcu::Matrix<T, Cols, Rows> transpose (const tcu::Matrix<T, Rows, Cols>& mat)
 {
-	tcu::Matrix<T, Cols, Rows> retVal;
+    tcu::Matrix<T, Cols, Rows> retVal;
 
-	for (int r = 0; r < Rows; ++r)
-		for (int c = 0; c < Cols; ++c)
-			retVal(c, r) = mat(r, c);
+    for (int r = 0; r < Rows; ++r)
+        for (int c = 0; c < Cols; ++c)
+            retVal(c, r) = mat(r, c);
 
-	return retVal;
+    return retVal;
 }
 
 // outerProduct
@@ -651,13 +651,13 @@ tcu::Matrix<T, Cols, Rows> transpose (const tcu::Matrix<T, Rows, Cols>& mat)
 template <typename T, int Rows, int Cols>
 tcu::Matrix<T, Cols, Rows> outerProduct (const tcu::Vector<T, Cols>& a, const tcu::Vector<T, Rows>& b)
 {
-	tcu::Matrix<T, Rows, Cols> retVal;
+    tcu::Matrix<T, Rows, Cols> retVal;
 
-	for (int r = 0; r < Rows; ++r)
-		for (int c = 0; c < Cols; ++c)
-			retVal(r,c) = a[c] * b[r];
+    for (int r = 0; r < Rows; ++r)
+        for (int c = 0; c < Cols; ++c)
+            retVal(r,c) = a[c] * b[r];
 
-	return transpose(retVal); // to gl-form (column-major)
+    return transpose(retVal); // to gl-form (column-major)
 }
 
 // Determinant
@@ -668,51 +668,51 @@ float determinant (const tcu::Matrix<float, Size, Size>& mat);
 template <>
 float determinant<2> (const tcu::Matrix<float, 2, 2>& mat)
 {
-	return mat(0,0) * mat(1,1) - mat(1,0) * mat(0,1);
+    return mat(0,0) * mat(1,1) - mat(1,0) * mat(0,1);
 }
 
 template <>
 float determinant<3> (const tcu::Matrix<float, 3, 3>& mat)
 {
-	return	+ mat(0,0) * mat(1,1) * mat(2,2)
-			+ mat(0,1) * mat(1,2) * mat(2,0)
-			+ mat(0,2) * mat(1,0) * mat(2,1)
-			- mat(0,0) * mat(1,2) * mat(2,1)
-			- mat(0,1) * mat(1,0) * mat(2,2)
-			- mat(0,2) * mat(1,1) * mat(2,0);
+    return  + mat(0,0) * mat(1,1) * mat(2,2)
+            + mat(0,1) * mat(1,2) * mat(2,0)
+            + mat(0,2) * mat(1,0) * mat(2,1)
+            - mat(0,0) * mat(1,2) * mat(2,1)
+            - mat(0,1) * mat(1,0) * mat(2,2)
+            - mat(0,2) * mat(1,1) * mat(2,0);
 }
 
 template <>
 float determinant<4> (const tcu::Matrix<float, 4, 4>& mat)
 {
-	const float minorMatrices[4][3*3] =
-	{
-		{
-			mat(1,1),	mat(2,1),	mat(3,1),
-			mat(1,2),	mat(2,2),	mat(3,2),
-			mat(1,3),	mat(2,3),	mat(3,3),
-		},
-		{
-			mat(1,0),	mat(2,0),	mat(3,0),
-			mat(1,2),	mat(2,2),	mat(3,2),
-			mat(1,3),	mat(2,3),	mat(3,3),
-		},
-		{
-			mat(1,0),	mat(2,0),	mat(3,0),
-			mat(1,1),	mat(2,1),	mat(3,1),
-			mat(1,3),	mat(2,3),	mat(3,3),
-		},
-		{
-			mat(1,0),	mat(2,0),	mat(3,0),
-			mat(1,1),	mat(2,1),	mat(3,1),
-			mat(1,2),	mat(2,2),	mat(3,2),
-		}
-	};
-
-	return	+ mat(0,0) * determinant(tcu::Mat3(minorMatrices[0]))
-			- mat(0,1) * determinant(tcu::Mat3(minorMatrices[1]))
-			+ mat(0,2) * determinant(tcu::Mat3(minorMatrices[2]))
-			- mat(0,3) * determinant(tcu::Mat3(minorMatrices[3]));
+    const float minorMatrices[4][3*3] =
+    {
+        {
+            mat(1,1),   mat(2,1),   mat(3,1),
+            mat(1,2),   mat(2,2),   mat(3,2),
+            mat(1,3),   mat(2,3),   mat(3,3),
+        },
+        {
+            mat(1,0),   mat(2,0),   mat(3,0),
+            mat(1,2),   mat(2,2),   mat(3,2),
+            mat(1,3),   mat(2,3),   mat(3,3),
+        },
+        {
+            mat(1,0),   mat(2,0),   mat(3,0),
+            mat(1,1),   mat(2,1),   mat(3,1),
+            mat(1,3),   mat(2,3),   mat(3,3),
+        },
+        {
+            mat(1,0),   mat(2,0),   mat(3,0),
+            mat(1,1),   mat(2,1),   mat(3,1),
+            mat(1,2),   mat(2,2),   mat(3,2),
+        }
+    };
+
+    return  + mat(0,0) * determinant(tcu::Mat3(minorMatrices[0]))
+            - mat(0,1) * determinant(tcu::Mat3(minorMatrices[1]))
+            + mat(0,2) * determinant(tcu::Mat3(minorMatrices[2]))
+            - mat(0,3) * determinant(tcu::Mat3(minorMatrices[3]));
 }
 
 // Inverse
@@ -723,120 +723,120 @@ tcu::Matrix<float, Size, Size> inverse (const tcu::Matrix<float, Size, Size>& ma
 template <>
 tcu::Matrix<float, 2, 2> inverse<2> (const tcu::Matrix<float, 2, 2>& mat)
 {
-	const float					det		= determinant(mat);
-	tcu::Matrix<float, 2, 2>	retVal;
+    const float                 det     = determinant(mat);
+    tcu::Matrix<float, 2, 2>    retVal;
 
-	DE_ASSERT(det != 0.0f);
+    DE_ASSERT(det != 0.0f);
 
-	retVal(0, 0) =  mat(1, 1) / det;
-	retVal(0, 1) = -mat(0, 1) / det;
-	retVal(1, 0) = -mat(1, 0) / det;
-	retVal(1, 1) =  mat(0, 0) / det;
+    retVal(0, 0) =  mat(1, 1) / det;
+    retVal(0, 1) = -mat(0, 1) / det;
+    retVal(1, 0) = -mat(1, 0) / det;
+    retVal(1, 1) =  mat(0, 0) / det;
 
-	return retVal;
+    return retVal;
 }
 
 template <>
 tcu::Matrix<float, 3, 3> inverse<3> (const tcu::Matrix<float, 3, 3>& mat)
 {
-	// Blockwise inversion
-
-	DE_ASSERT(determinant(mat) != 0.0f);
-
-	const float areaA[2*2] =
-	{
-		mat(0,0),	mat(0,1),
-		mat(1,0),	mat(1,1)
-	};
-	const float areaB[2] =
-	{
-		mat(0,2),
-		mat(1,2),
-	};
-	const float areaC[2] =
-	{
-		mat(2,0),	mat(2,1),
-	};
-	const float areaD[1] =
-	{
-		mat(2,2)
-	};
-	const float nullField[4] = { 0.0f };
-
-	const tcu::Matrix<float, 2, 2>	invA = inverse(tcu::Matrix<float, 2, 2>(areaA));
-	const tcu::Matrix<float, 2, 1>	matB =         tcu::Matrix<float, 2, 1>(areaB);
-	const tcu::Matrix<float, 1, 2>	matC =         tcu::Matrix<float, 1, 2>(areaC);
-	const tcu::Matrix<float, 1, 1>	matD =         tcu::Matrix<float, 1, 1>(areaD);
-
-	const float						schurComplement = 1.0f / (matD - matC*invA*matB)(0,0);
-	const tcu::Matrix<float, 2, 2>	zeroMat         = Mat2(nullField);
-
-	const tcu::Matrix<float, 2, 2>	blockA = invA + invA*matB*schurComplement*matC*invA;
-	const tcu::Matrix<float, 2, 1>	blockB = (zeroMat-invA)*matB*schurComplement;
-	const tcu::Matrix<float, 1, 2>	blockC = matC*invA*(-schurComplement);
-	const float						blockD = schurComplement;
-
-	const float result[3*3] =
-	{
-		blockA(0,0),	blockA(0,1),	blockB(0,0),
-		blockA(1,0),	blockA(1,1),	blockB(1,0),
-		blockC(0,0),	blockC(0,1),	blockD,
-	};
-
-	return Mat3(result);
+    // Blockwise inversion
+
+    DE_ASSERT(determinant(mat) != 0.0f);
+
+    const float areaA[2*2] =
+    {
+        mat(0,0),   mat(0,1),
+        mat(1,0),   mat(1,1)
+    };
+    const float areaB[2] =
+    {
+        mat(0,2),
+        mat(1,2),
+    };
+    const float areaC[2] =
+    {
+        mat(2,0),   mat(2,1),
+    };
+    const float areaD[1] =
+    {
+        mat(2,2)
+    };
+    const float nullField[4] = { 0.0f };
+
+    const tcu::Matrix<float, 2, 2>  invA = inverse(tcu::Matrix<float, 2, 2>(areaA));
+    const tcu::Matrix<float, 2, 1>  matB =         tcu::Matrix<float, 2, 1>(areaB);
+    const tcu::Matrix<float, 1, 2>  matC =         tcu::Matrix<float, 1, 2>(areaC);
+    const tcu::Matrix<float, 1, 1>  matD =         tcu::Matrix<float, 1, 1>(areaD);
+
+    const float                     schurComplement = 1.0f / (matD - matC*invA*matB)(0,0);
+    const tcu::Matrix<float, 2, 2>  zeroMat         = Mat2(nullField);
+
+    const tcu::Matrix<float, 2, 2>  blockA = invA + invA*matB*schurComplement*matC*invA;
+    const tcu::Matrix<float, 2, 1>  blockB = (zeroMat-invA)*matB*schurComplement;
+    const tcu::Matrix<float, 1, 2>  blockC = matC*invA*(-schurComplement);
+    const float                     blockD = schurComplement;
+
+    const float result[3*3] =
+    {
+        blockA(0,0),    blockA(0,1),    blockB(0,0),
+        blockA(1,0),    blockA(1,1),    blockB(1,0),
+        blockC(0,0),    blockC(0,1),    blockD,
+    };
+
+    return Mat3(result);
 }
 
 template <>
 tcu::Matrix<float, 4, 4> inverse<4> (const tcu::Matrix<float, 4, 4>& mat)
 {
-	// Blockwise inversion
-
-	DE_ASSERT(determinant(mat) != 0.0f);
-
-	const float areaA[2*2] =
-	{
-		mat(0,0),	mat(0,1),
-		mat(1,0),	mat(1,1)
-	};
-	const float areaB[2*2] =
-	{
-		mat(0,2),	mat(0,3),
-		mat(1,2),	mat(1,3)
-	};
-	const float areaC[2*2] =
-	{
-		mat(2,0),	mat(2,1),
-		mat(3,0),	mat(3,1)
-	};
-	const float areaD[2*2] =
-	{
-		mat(2,2),	mat(2,3),
-		mat(3,2),	mat(3,3)
-	};
-	const float nullField[4] = { 0.0f };
-
-	const tcu::Matrix<float, 2, 2> invA = inverse(Mat2(areaA));
-	const tcu::Matrix<float, 2, 2> matB =         Mat2(areaB);
-	const tcu::Matrix<float, 2, 2> matC =         Mat2(areaC);
-	const tcu::Matrix<float, 2, 2> matD =         Mat2(areaD);
-
-	const tcu::Matrix<float, 2, 2> schurComplement = inverse(matD - matC*invA*matB);
-	const tcu::Matrix<float, 2, 2> zeroMat         = Mat2(nullField);
-
-	const tcu::Matrix<float, 2, 2> blockA = invA + invA*matB*schurComplement*matC*invA;
-	const tcu::Matrix<float, 2, 2> blockB = (zeroMat-invA)*matB*schurComplement;
-	const tcu::Matrix<float, 2, 2> blockC = (zeroMat-schurComplement)*matC*invA;
-	const tcu::Matrix<float, 2, 2> blockD = schurComplement;
-
-	const float result[4*4] =
-	{
-		blockA(0,0),	blockA(0,1),	blockB(0,0),	blockB(0,1),
-		blockA(1,0),	blockA(1,1),	blockB(1,0),	blockB(1,1),
-		blockC(0,0),	blockC(0,1),	blockD(0,0),	blockD(0,1),
-		blockC(1,0),	blockC(1,1),	blockD(1,0),	blockD(1,1),
-	};
-
-	return Mat4(result);
+    // Blockwise inversion
+
+    DE_ASSERT(determinant(mat) != 0.0f);
+
+    const float areaA[2*2] =
+    {
+        mat(0,0),   mat(0,1),
+        mat(1,0),   mat(1,1)
+    };
+    const float areaB[2*2] =
+    {
+        mat(0,2),   mat(0,3),
+        mat(1,2),   mat(1,3)
+    };
+    const float areaC[2*2] =
+    {
+        mat(2,0),   mat(2,1),
+        mat(3,0),   mat(3,1)
+    };
+    const float areaD[2*2] =
+    {
+        mat(2,2),   mat(2,3),
+        mat(3,2),   mat(3,3)
+    };
+    const float nullField[4] = { 0.0f };
+
+    const tcu::Matrix<float, 2, 2> invA = inverse(Mat2(areaA));
+    const tcu::Matrix<float, 2, 2> matB =         Mat2(areaB);
+    const tcu::Matrix<float, 2, 2> matC =         Mat2(areaC);
+    const tcu::Matrix<float, 2, 2> matD =         Mat2(areaD);
+
+    const tcu::Matrix<float, 2, 2> schurComplement = inverse(matD - matC*invA*matB);
+    const tcu::Matrix<float, 2, 2> zeroMat         = Mat2(nullField);
+
+    const tcu::Matrix<float, 2, 2> blockA = invA + invA*matB*schurComplement*matC*invA;
+    const tcu::Matrix<float, 2, 2> blockB = (zeroMat-invA)*matB*schurComplement;
+    const tcu::Matrix<float, 2, 2> blockC = (zeroMat-schurComplement)*matC*invA;
+    const tcu::Matrix<float, 2, 2> blockD = schurComplement;
+
+    const float result[4*4] =
+    {
+        blockA(0,0),    blockA(0,1),    blockB(0,0),    blockB(0,1),
+        blockA(1,0),    blockA(1,1),    blockB(1,0),    blockB(1,1),
+        blockC(0,0),    blockC(0,1),    blockD(0,0),    blockD(0,1),
+        blockC(1,0),    blockC(1,1),    blockD(1,0),    blockD(1,1),
+    };
+
+    return Mat4(result);
 }
 
 // negate
@@ -844,13 +844,13 @@ tcu::Matrix<float, 4, 4> inverse<4> (const tcu::Matrix<float, 4, 4>& mat)
 template <typename T, int Rows, int Cols>
 tcu::Matrix<T, Rows, Cols> negate (const tcu::Matrix<T, Rows, Cols>& mat)
 {
-	tcu::Matrix<T, Rows, Cols> retVal;
+    tcu::Matrix<T, Rows, Cols> retVal;
 
-	for (int r = 0; r < Rows; ++r)
-		for (int c = 0; c < Cols; ++c)
-			retVal(r,c) = -mat(r, c);
+    for (int r = 0; r < Rows; ++r)
+        for (int c = 0; c < Cols; ++c)
+            retVal(r,c) = -mat(r, c);
 
-	return retVal;
+    return retVal;
 }
 
 // increment/decrement
@@ -858,25 +858,25 @@ tcu::Matrix<T, Rows, Cols> negate (const tcu::Matrix<T, Rows, Cols>& mat)
 template <typename T, int Rows, int Cols>
 tcu::Matrix<T, Rows, Cols> increment (const tcu::Matrix<T, Rows, Cols>& mat)
 {
-	tcu::Matrix<T, Rows, Cols> retVal;
+    tcu::Matrix<T, Rows, Cols> retVal;
 
-	for (int r = 0; r < Rows; ++r)
-		for (int c = 0; c < Cols; ++c)
-			retVal(r,c) = mat(r, c) + 1.0f;
+    for (int r = 0; r < Rows; ++r)
+        for (int c = 0; c < Cols; ++c)
+            retVal(r,c) = mat(r, c) + 1.0f;
 
-	return retVal;
+    return retVal;
 }
 
 template <typename T, int Rows, int Cols>
 tcu::Matrix<T, Rows, Cols> decrement (const tcu::Matrix<T, Rows, Cols>& mat)
 {
-	tcu::Matrix<T, Rows, Cols> retVal;
+    tcu::Matrix<T, Rows, Cols> retVal;
 
-	for (int r = 0; r < Rows; ++r)
-		for (int c = 0; c < Cols; ++c)
-			retVal(r,c) = mat(r, c) - 1.0f;
+    for (int r = 0; r < Rows; ++r)
+        for (int c = 0; c < Cols; ++c)
+            retVal(r,c) = mat(r, c) - 1.0f;
 
-	return retVal;
+    return retVal;
 }
 
 // Evaluator template.
@@ -889,423 +889,423 @@ struct Evaluator;
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_ADD, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
-		typename TypeTraits<In1DataType>::Type	in1	= (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
-																				     : getInputValue<INPUTTYPE_CONST,	In1DataType>(evalCtx, 1);
-		evalCtx.color.xyz() = reduceToVec3(in0 + in1);
-	}
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
+        typename TypeTraits<In1DataType>::Type  in1 = (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In1DataType>(evalCtx, 1);
+        evalCtx.color.xyz() = reduceToVec3(in0 + in1);
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_SUB, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
-		typename TypeTraits<In1DataType>::Type	in1	= (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
-																				     : getInputValue<INPUTTYPE_CONST,	In1DataType>(evalCtx, 1);
-		evalCtx.color.xyz() = reduceToVec3(in0 - in1);
-	}
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
+        typename TypeTraits<In1DataType>::Type  in1 = (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In1DataType>(evalCtx, 1);
+        evalCtx.color.xyz() = reduceToVec3(in0 - in1);
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_MUL, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
-		typename TypeTraits<In1DataType>::Type	in1	= (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
-																				     : getInputValue<INPUTTYPE_CONST,	In1DataType>(evalCtx, 1);
-		evalCtx.color.xyz() = reduceToVec3(in0 * in1);
-	}
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
+        typename TypeTraits<In1DataType>::Type  in1 = (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In1DataType>(evalCtx, 1);
+        evalCtx.color.xyz() = reduceToVec3(in0 * in1);
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_DIV, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
-		typename TypeTraits<In1DataType>::Type	in1	= (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
-																				     : getInputValue<INPUTTYPE_CONST,	In1DataType>(evalCtx, 1);
-		evalCtx.color.xyz() = reduceToVec3(in0 / in1);
-	}
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
+        typename TypeTraits<In1DataType>::Type  in1 = (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In1DataType>(evalCtx, 1);
+        evalCtx.color.xyz() = reduceToVec3(in0 / in1);
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_COMP_MUL, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
-		typename TypeTraits<In1DataType>::Type	in1	= (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
-																				     : getInputValue<INPUTTYPE_CONST,	In1DataType>(evalCtx, 1);
-		evalCtx.color.xyz() = reduceToVec3(matrixCompMult(in0, in1));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
+        typename TypeTraits<In1DataType>::Type  in1 = (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In1DataType>(evalCtx, 1);
+        evalCtx.color.xyz() = reduceToVec3(matrixCompMult(in0, in1));
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_OUTER_PRODUCT, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
-		typename TypeTraits<In1DataType>::Type	in1	= (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
-																				     : getInputValue<INPUTTYPE_CONST,	In1DataType>(evalCtx, 1);
-		evalCtx.color.xyz() = reduceToVec3(outerProduct(in0, in1));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
+        typename TypeTraits<In1DataType>::Type  in1 = (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In1DataType>(evalCtx, 1);
+        evalCtx.color.xyz() = reduceToVec3(outerProduct(in0, in1));
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_TRANSPOSE, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		DE_UNREF(in1Type);
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
-		evalCtx.color.xyz() = reduceToVec3(transpose(in0));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        DE_UNREF(in1Type);
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
+        evalCtx.color.xyz() = reduceToVec3(transpose(in0));
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_INVERSE, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		DE_UNREF(in1Type);
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
-		evalCtx.color.xyz() = reduceToVec3(inverse(in0));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        DE_UNREF(in1Type);
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
+        evalCtx.color.xyz() = reduceToVec3(inverse(in0));
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_DETERMINANT, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		DE_UNREF(in1Type);
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
-		evalCtx.color.xyz() = Vec3(determinant(in0));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        DE_UNREF(in1Type);
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
+        evalCtx.color.xyz() = Vec3(determinant(in0));
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_UNARY_PLUS, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		DE_UNREF(in1Type);
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
-		evalCtx.color.xyz() = reduceToVec3(in0);
-	}
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        DE_UNREF(in1Type);
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
+        evalCtx.color.xyz() = reduceToVec3(in0);
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_NEGATION, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		DE_UNREF(in1Type);
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
-		evalCtx.color.xyz() = reduceToVec3(negate(in0));
-	}
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        DE_UNREF(in1Type);
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
+        evalCtx.color.xyz() = reduceToVec3(negate(in0));
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_PRE_INCREMENT, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		DE_UNREF(in1Type);
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        DE_UNREF(in1Type);
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
 
-		// modifying reduction: sum modified value too
-		evalCtx.color.xyz() = reduceToVec3(increment(in0)) + reduceToVec3(increment(in0));
-	}
+        // modifying reduction: sum modified value too
+        evalCtx.color.xyz() = reduceToVec3(increment(in0)) + reduceToVec3(increment(in0));
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_PRE_DECREMENT, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		DE_UNREF(in1Type);
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        DE_UNREF(in1Type);
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
 
-		// modifying reduction: sum modified value too
-		evalCtx.color.xyz() = reduceToVec3(decrement(in0)) + reduceToVec3(decrement(in0));
-	}
+        // modifying reduction: sum modified value too
+        evalCtx.color.xyz() = reduceToVec3(decrement(in0)) + reduceToVec3(decrement(in0));
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_POST_INCREMENT, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		DE_UNREF(in1Type);
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        DE_UNREF(in1Type);
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
 
-		// modifying reduction: sum modified value too
-		evalCtx.color.xyz() = reduceToVec3(in0) + reduceToVec3(increment(in0));
-	}
+        // modifying reduction: sum modified value too
+        evalCtx.color.xyz() = reduceToVec3(in0) + reduceToVec3(increment(in0));
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_POST_DECREMENT, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		DE_UNREF(in1Type);
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        DE_UNREF(in1Type);
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
 
-		// modifying reduction: sum modified value too
-		evalCtx.color.xyz() = reduceToVec3(in0) + reduceToVec3(decrement(in0));
-	}
+        // modifying reduction: sum modified value too
+        evalCtx.color.xyz() = reduceToVec3(in0) + reduceToVec3(decrement(in0));
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_ADD_INTO, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
-		typename TypeTraits<In1DataType>::Type	in1	= (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
-																				     : getInputValue<INPUTTYPE_CONST,	In1DataType>(evalCtx, 1);
-		evalCtx.color.xyz() = reduceToVec3(in0 + in1);
-	}
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
+        typename TypeTraits<In1DataType>::Type  in1 = (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In1DataType>(evalCtx, 1);
+        evalCtx.color.xyz() = reduceToVec3(in0 + in1);
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_SUBTRACT_FROM, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
-		typename TypeTraits<In1DataType>::Type	in1	= (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
-																				     : getInputValue<INPUTTYPE_CONST,	In1DataType>(evalCtx, 1);
-		evalCtx.color.xyz() = reduceToVec3(in0 - in1);
-	}
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
+        typename TypeTraits<In1DataType>::Type  in1 = (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In1DataType>(evalCtx, 1);
+        evalCtx.color.xyz() = reduceToVec3(in0 - in1);
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_MULTIPLY_INTO, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
-		typename TypeTraits<In1DataType>::Type	in1	= (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
-																				     : getInputValue<INPUTTYPE_CONST,	In1DataType>(evalCtx, 1);
-		evalCtx.color.xyz() = reduceToVec3(in0 * in1);
-	}
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
+        typename TypeTraits<In1DataType>::Type  in1 = (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In1DataType>(evalCtx, 1);
+        evalCtx.color.xyz() = reduceToVec3(in0 * in1);
+    }
 };
 
 template <int In0DataType, int In1DataType>
 struct Evaluator<OP_DIVIDE_INTO, In0DataType, In1DataType>
 {
-	static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
-	{
-		typename TypeTraits<In0DataType>::Type	in0	= (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
-																				     : getInputValue<INPUTTYPE_CONST,	In0DataType>(evalCtx, 0);
-		typename TypeTraits<In1DataType>::Type	in1	= (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
-																				     : getInputValue<INPUTTYPE_CONST,	In1DataType>(evalCtx, 1);
-		evalCtx.color.xyz() = reduceToVec3(in0 / in1);
-	}
+    static void evaluate (ShaderEvalContext& evalCtx, InputType in0Type, InputType in1Type)
+    {
+        typename TypeTraits<In0DataType>::Type  in0 = (in0Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In0DataType>(evalCtx, 0)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In0DataType>(evalCtx, 0);
+        typename TypeTraits<In1DataType>::Type  in1 = (in1Type == INPUTTYPE_DYNAMIC) ? getInputValue<INPUTTYPE_DYNAMIC, In1DataType>(evalCtx, 1)
+                                                                                     : getInputValue<INPUTTYPE_CONST,   In1DataType>(evalCtx, 1);
+        evalCtx.color.xyz() = reduceToVec3(in0 / in1);
+    }
 };
 
 MatrixShaderEvalFunc getEvalFunc (const ShaderInput& in0, const ShaderInput& in1, MatrixOp op)
 {
-	// Evaluator is selected based on op and input data types.
-	// For efficient lookup the types and op enums are packed together to form a 19-bit key:
-	// [18..14 OP] [13..7 TYPE0] [6..0 TYPE1]
-
-	DE_STATIC_ASSERT(TYPE_LAST	<= (1<<7));
-	DE_STATIC_ASSERT(OP_LAST	<= (1<<5));
-
-#define PACK_EVAL_CASE(OP, IN0DATATYPE, IN1DATATYPE)	(((OP) << 14) | ((IN0DATATYPE) << 7) | (IN1DATATYPE))
-
-#define MAKE_EVAL_CASE(OP, IN0DATATYPE, IN1DATATYPE)	\
-	case PACK_EVAL_CASE(OP, IN0DATATYPE, IN1DATATYPE):	\
-		return Evaluator<OP, IN0DATATYPE, IN1DATATYPE>::evaluate
-
-#define MAKE_SCALAR_OPS(IN0DATATYPE, IN1DATATYPE)		\
-	MAKE_EVAL_CASE(OP_ADD, IN0DATATYPE, IN1DATATYPE);	\
-	MAKE_EVAL_CASE(OP_SUB, IN0DATATYPE, IN1DATATYPE);	\
-	MAKE_EVAL_CASE(OP_MUL, IN0DATATYPE, IN1DATATYPE);	\
-	MAKE_EVAL_CASE(OP_DIV, IN0DATATYPE, IN1DATATYPE)
-
-#define MAKE_CWISE_OPS(IN0DATATYPE, IN1DATATYPE)			\
-	MAKE_EVAL_CASE(OP_ADD,		IN0DATATYPE, IN1DATATYPE);	\
-	MAKE_EVAL_CASE(OP_SUB,		IN0DATATYPE, IN1DATATYPE);	\
-	MAKE_EVAL_CASE(OP_DIV,		IN0DATATYPE, IN1DATATYPE);	\
-	MAKE_EVAL_CASE(OP_COMP_MUL,	IN0DATATYPE, IN1DATATYPE)
-
-#define MAKE_MUL_OP(IN0DATATYPE, IN1DATATYPE)			\
-	MAKE_EVAL_CASE(OP_MUL, IN0DATATYPE, IN1DATATYPE)
-
-#define MAKE_VECVEC_OP(IN0DATATYPE, IN1DATATYPE)			\
-	MAKE_EVAL_CASE(OP_OUTER_PRODUCT, IN0DATATYPE, IN1DATATYPE)
-
-#define MAKE_UNARY_OP(IN0DATATYPE)								\
-	MAKE_EVAL_CASE(OP_TRANSPOSE,		IN0DATATYPE, TYPE_LAST);	\
-	MAKE_EVAL_CASE(OP_UNARY_PLUS,		IN0DATATYPE, TYPE_LAST);	\
-	MAKE_EVAL_CASE(OP_NEGATION,			IN0DATATYPE, TYPE_LAST);	\
-	MAKE_EVAL_CASE(OP_PRE_INCREMENT,	IN0DATATYPE, TYPE_LAST);	\
-	MAKE_EVAL_CASE(OP_PRE_DECREMENT,	IN0DATATYPE, TYPE_LAST);	\
-	MAKE_EVAL_CASE(OP_POST_INCREMENT,	IN0DATATYPE, TYPE_LAST);	\
-	MAKE_EVAL_CASE(OP_POST_DECREMENT,	IN0DATATYPE, TYPE_LAST)
-
-#define MAKE_UNARY_SYMMETRIC_OP(IN0DATATYPE)					\
-	MAKE_UNARY_OP(IN0DATATYPE);									\
-	MAKE_EVAL_CASE(OP_DETERMINANT,	IN0DATATYPE, TYPE_LAST);	\
-	MAKE_EVAL_CASE(OP_INVERSE,		IN0DATATYPE, TYPE_LAST)
-
-#define MAKE_ASSIGNMENT_OP(IN0DATATYPE)								\
-	MAKE_EVAL_CASE(OP_ADD_INTO,			IN0DATATYPE, IN0DATATYPE);	\
-	MAKE_EVAL_CASE(OP_SUBTRACT_FROM,	IN0DATATYPE, IN0DATATYPE);	\
-	MAKE_EVAL_CASE(OP_DIVIDE_INTO,		IN0DATATYPE, IN0DATATYPE)
-
-#define MAKE_ASSIGNMENT_SYMMETRIC_OP(IN0DATATYPE)					\
-	MAKE_ASSIGNMENT_OP(IN0DATATYPE);								\
-	MAKE_EVAL_CASE(OP_MULTIPLY_INTO,	IN0DATATYPE, IN0DATATYPE)
-
-	switch (PACK_EVAL_CASE(op, in0.dataType, in1.dataType))
-	{
-		// Matrix-scalar.
-		MAKE_SCALAR_OPS(TYPE_FLOAT_MAT2,	TYPE_FLOAT);
-		MAKE_SCALAR_OPS(TYPE_FLOAT_MAT2X3,	TYPE_FLOAT);
-		MAKE_SCALAR_OPS(TYPE_FLOAT_MAT2X4,	TYPE_FLOAT);
-		MAKE_SCALAR_OPS(TYPE_FLOAT_MAT3X2,	TYPE_FLOAT);
-		MAKE_SCALAR_OPS(TYPE_FLOAT_MAT3,	TYPE_FLOAT);
-		MAKE_SCALAR_OPS(TYPE_FLOAT_MAT3X4,	TYPE_FLOAT);
-		MAKE_SCALAR_OPS(TYPE_FLOAT_MAT4X2,	TYPE_FLOAT);
-		MAKE_SCALAR_OPS(TYPE_FLOAT_MAT4X3,	TYPE_FLOAT);
-		MAKE_SCALAR_OPS(TYPE_FLOAT_MAT4,	TYPE_FLOAT);
-
-		// Matrix-vector.
-		MAKE_MUL_OP(TYPE_FLOAT_MAT2,	TYPE_FLOAT_VEC2);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT2X3,	TYPE_FLOAT_VEC2);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT2X4,	TYPE_FLOAT_VEC2);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT3X2,	TYPE_FLOAT_VEC3);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT3,	TYPE_FLOAT_VEC3);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT3X4,	TYPE_FLOAT_VEC3);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT4X2,	TYPE_FLOAT_VEC4);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT4X3,	TYPE_FLOAT_VEC4);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT4,	TYPE_FLOAT_VEC4);
-
-		// Vector-matrix.
-		MAKE_MUL_OP(TYPE_FLOAT_VEC2, TYPE_FLOAT_MAT2);
-		MAKE_MUL_OP(TYPE_FLOAT_VEC3, TYPE_FLOAT_MAT2X3);
-		MAKE_MUL_OP(TYPE_FLOAT_VEC4, TYPE_FLOAT_MAT2X4);
-		MAKE_MUL_OP(TYPE_FLOAT_VEC2, TYPE_FLOAT_MAT3X2);
-		MAKE_MUL_OP(TYPE_FLOAT_VEC3, TYPE_FLOAT_MAT3);
-		MAKE_MUL_OP(TYPE_FLOAT_VEC4, TYPE_FLOAT_MAT3X4);
-		MAKE_MUL_OP(TYPE_FLOAT_VEC2, TYPE_FLOAT_MAT4X2);
-		MAKE_MUL_OP(TYPE_FLOAT_VEC3, TYPE_FLOAT_MAT4X3);
-		MAKE_MUL_OP(TYPE_FLOAT_VEC4, TYPE_FLOAT_MAT4);
-
-		// Matrix-matrix.
-		MAKE_CWISE_OPS(TYPE_FLOAT_MAT2,		TYPE_FLOAT_MAT2);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT2,		TYPE_FLOAT_MAT2);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT2,		TYPE_FLOAT_MAT3X2);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT2,		TYPE_FLOAT_MAT4X2);
-
-		MAKE_CWISE_OPS(TYPE_FLOAT_MAT2X3,	TYPE_FLOAT_MAT2X3);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT2X3,		TYPE_FLOAT_MAT2);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT2X3,		TYPE_FLOAT_MAT3X2);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT2X3,		TYPE_FLOAT_MAT4X2);
-
-		MAKE_CWISE_OPS(TYPE_FLOAT_MAT2X4,	TYPE_FLOAT_MAT2X4);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT2X4,		TYPE_FLOAT_MAT2);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT2X4,		TYPE_FLOAT_MAT3X2);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT2X4,		TYPE_FLOAT_MAT4X2);
-
-		MAKE_CWISE_OPS(TYPE_FLOAT_MAT3X2,	TYPE_FLOAT_MAT3X2);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT3X2,		TYPE_FLOAT_MAT2X3);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT3X2,		TYPE_FLOAT_MAT3);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT3X2,		TYPE_FLOAT_MAT4X3);
-
-		MAKE_CWISE_OPS(TYPE_FLOAT_MAT3,		TYPE_FLOAT_MAT3);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT3,		TYPE_FLOAT_MAT2X3);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT3,		TYPE_FLOAT_MAT3);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT3,		TYPE_FLOAT_MAT4X3);
-
-		MAKE_CWISE_OPS(TYPE_FLOAT_MAT3X4,	TYPE_FLOAT_MAT3X4);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT3X4,		TYPE_FLOAT_MAT2X3);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT3X4,		TYPE_FLOAT_MAT3);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT3X4,		TYPE_FLOAT_MAT4X3);
-
-		MAKE_CWISE_OPS(TYPE_FLOAT_MAT4X2,	TYPE_FLOAT_MAT4X2);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT4X2,		TYPE_FLOAT_MAT2X4);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT4X2,		TYPE_FLOAT_MAT3X4);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT4X2,		TYPE_FLOAT_MAT4);
-
-		MAKE_CWISE_OPS(TYPE_FLOAT_MAT4X3,	TYPE_FLOAT_MAT4X3);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT4X3,		TYPE_FLOAT_MAT2X4);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT4X3,		TYPE_FLOAT_MAT3X4);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT4X3,		TYPE_FLOAT_MAT4);
-
-		MAKE_CWISE_OPS(TYPE_FLOAT_MAT4,		TYPE_FLOAT_MAT4);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT4,		TYPE_FLOAT_MAT2X4);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT4,		TYPE_FLOAT_MAT3X4);
-		MAKE_MUL_OP(TYPE_FLOAT_MAT4,		TYPE_FLOAT_MAT4);
-
-		// Vector-vector.
-		MAKE_VECVEC_OP(TYPE_FLOAT_VEC2,		TYPE_FLOAT_VEC2);
-		MAKE_VECVEC_OP(TYPE_FLOAT_VEC2,		TYPE_FLOAT_VEC3);
-		MAKE_VECVEC_OP(TYPE_FLOAT_VEC2,		TYPE_FLOAT_VEC4);
-		MAKE_VECVEC_OP(TYPE_FLOAT_VEC3,		TYPE_FLOAT_VEC2);
-		MAKE_VECVEC_OP(TYPE_FLOAT_VEC3,		TYPE_FLOAT_VEC3);
-		MAKE_VECVEC_OP(TYPE_FLOAT_VEC3,		TYPE_FLOAT_VEC4);
-		MAKE_VECVEC_OP(TYPE_FLOAT_VEC4,		TYPE_FLOAT_VEC2);
-		MAKE_VECVEC_OP(TYPE_FLOAT_VEC4,		TYPE_FLOAT_VEC3);
-		MAKE_VECVEC_OP(TYPE_FLOAT_VEC4,		TYPE_FLOAT_VEC4);
-
-		// Unary Matrix.
-		MAKE_UNARY_SYMMETRIC_OP(TYPE_FLOAT_MAT2);
-		MAKE_UNARY_OP(TYPE_FLOAT_MAT2X3);
-		MAKE_UNARY_OP(TYPE_FLOAT_MAT2X4);
-		MAKE_UNARY_OP(TYPE_FLOAT_MAT3X2);
-		MAKE_UNARY_SYMMETRIC_OP(TYPE_FLOAT_MAT3);
-		MAKE_UNARY_OP(TYPE_FLOAT_MAT3X4);
-		MAKE_UNARY_OP(TYPE_FLOAT_MAT4X2);
-		MAKE_UNARY_OP(TYPE_FLOAT_MAT4X3);
-		MAKE_UNARY_SYMMETRIC_OP(TYPE_FLOAT_MAT4);
-
-		// Assignments
-		MAKE_ASSIGNMENT_SYMMETRIC_OP(TYPE_FLOAT_MAT2);
-		MAKE_ASSIGNMENT_OP(TYPE_FLOAT_MAT2X3);
-		MAKE_ASSIGNMENT_OP(TYPE_FLOAT_MAT2X4);
-		MAKE_ASSIGNMENT_OP(TYPE_FLOAT_MAT3X2);
-		MAKE_ASSIGNMENT_SYMMETRIC_OP(TYPE_FLOAT_MAT3);
-		MAKE_ASSIGNMENT_OP(TYPE_FLOAT_MAT3X4);
-		MAKE_ASSIGNMENT_OP(TYPE_FLOAT_MAT4X2);
-		MAKE_ASSIGNMENT_OP(TYPE_FLOAT_MAT4X3);
-		MAKE_ASSIGNMENT_SYMMETRIC_OP(TYPE_FLOAT_MAT4);
-
-		default:
-			DE_ASSERT(DE_FALSE);
-			return DE_NULL;
-	}
+    // Evaluator is selected based on op and input data types.
+    // For efficient lookup the types and op enums are packed together to form a 19-bit key:
+    // [18..14 OP] [13..7 TYPE0] [6..0 TYPE1]
+
+    DE_STATIC_ASSERT(TYPE_LAST  <= (1<<7));
+    DE_STATIC_ASSERT(OP_LAST    <= (1<<5));
+
+#define PACK_EVAL_CASE(OP, IN0DATATYPE, IN1DATATYPE)    (((OP) << 14) | ((IN0DATATYPE) << 7) | (IN1DATATYPE))
+
+#define MAKE_EVAL_CASE(OP, IN0DATATYPE, IN1DATATYPE)    \
+    case PACK_EVAL_CASE(OP, IN0DATATYPE, IN1DATATYPE):  \
+        return Evaluator<OP, IN0DATATYPE, IN1DATATYPE>::evaluate
+
+#define MAKE_SCALAR_OPS(IN0DATATYPE, IN1DATATYPE)       \
+    MAKE_EVAL_CASE(OP_ADD, IN0DATATYPE, IN1DATATYPE);   \
+    MAKE_EVAL_CASE(OP_SUB, IN0DATATYPE, IN1DATATYPE);   \
+    MAKE_EVAL_CASE(OP_MUL, IN0DATATYPE, IN1DATATYPE);   \
+    MAKE_EVAL_CASE(OP_DIV, IN0DATATYPE, IN1DATATYPE)
+
+#define MAKE_CWISE_OPS(IN0DATATYPE, IN1DATATYPE)            \
+    MAKE_EVAL_CASE(OP_ADD,      IN0DATATYPE, IN1DATATYPE);  \
+    MAKE_EVAL_CASE(OP_SUB,      IN0DATATYPE, IN1DATATYPE);  \
+    MAKE_EVAL_CASE(OP_DIV,      IN0DATATYPE, IN1DATATYPE);  \
+    MAKE_EVAL_CASE(OP_COMP_MUL, IN0DATATYPE, IN1DATATYPE)
+
+#define MAKE_MUL_OP(IN0DATATYPE, IN1DATATYPE)           \
+    MAKE_EVAL_CASE(OP_MUL, IN0DATATYPE, IN1DATATYPE)
+
+#define MAKE_VECVEC_OP(IN0DATATYPE, IN1DATATYPE)            \
+    MAKE_EVAL_CASE(OP_OUTER_PRODUCT, IN0DATATYPE, IN1DATATYPE)
+
+#define MAKE_UNARY_OP(IN0DATATYPE)                              \
+    MAKE_EVAL_CASE(OP_TRANSPOSE,        IN0DATATYPE, TYPE_LAST);    \
+    MAKE_EVAL_CASE(OP_UNARY_PLUS,       IN0DATATYPE, TYPE_LAST);    \
+    MAKE_EVAL_CASE(OP_NEGATION,         IN0DATATYPE, TYPE_LAST);    \
+    MAKE_EVAL_CASE(OP_PRE_INCREMENT,    IN0DATATYPE, TYPE_LAST);    \
+    MAKE_EVAL_CASE(OP_PRE_DECREMENT,    IN0DATATYPE, TYPE_LAST);    \
+    MAKE_EVAL_CASE(OP_POST_INCREMENT,   IN0DATATYPE, TYPE_LAST);    \
+    MAKE_EVAL_CASE(OP_POST_DECREMENT,   IN0DATATYPE, TYPE_LAST)
+
+#define MAKE_UNARY_SYMMETRIC_OP(IN0DATATYPE)                    \
+    MAKE_UNARY_OP(IN0DATATYPE);                                 \
+    MAKE_EVAL_CASE(OP_DETERMINANT,  IN0DATATYPE, TYPE_LAST);    \
+    MAKE_EVAL_CASE(OP_INVERSE,      IN0DATATYPE, TYPE_LAST)
+
+#define MAKE_ASSIGNMENT_OP(IN0DATATYPE)                             \
+    MAKE_EVAL_CASE(OP_ADD_INTO,         IN0DATATYPE, IN0DATATYPE);  \
+    MAKE_EVAL_CASE(OP_SUBTRACT_FROM,    IN0DATATYPE, IN0DATATYPE);  \
+    MAKE_EVAL_CASE(OP_DIVIDE_INTO,      IN0DATATYPE, IN0DATATYPE)
+
+#define MAKE_ASSIGNMENT_SYMMETRIC_OP(IN0DATATYPE)                   \
+    MAKE_ASSIGNMENT_OP(IN0DATATYPE);                                \
+    MAKE_EVAL_CASE(OP_MULTIPLY_INTO,    IN0DATATYPE, IN0DATATYPE)
+
+    switch (PACK_EVAL_CASE(op, in0.dataType, in1.dataType))
+    {
+        // Matrix-scalar.
+        MAKE_SCALAR_OPS(TYPE_FLOAT_MAT2,    TYPE_FLOAT);
+        MAKE_SCALAR_OPS(TYPE_FLOAT_MAT2X3,  TYPE_FLOAT);
+        MAKE_SCALAR_OPS(TYPE_FLOAT_MAT2X4,  TYPE_FLOAT);
+        MAKE_SCALAR_OPS(TYPE_FLOAT_MAT3X2,  TYPE_FLOAT);
+        MAKE_SCALAR_OPS(TYPE_FLOAT_MAT3,    TYPE_FLOAT);
+        MAKE_SCALAR_OPS(TYPE_FLOAT_MAT3X4,  TYPE_FLOAT);
+        MAKE_SCALAR_OPS(TYPE_FLOAT_MAT4X2,  TYPE_FLOAT);
+        MAKE_SCALAR_OPS(TYPE_FLOAT_MAT4X3,  TYPE_FLOAT);
+        MAKE_SCALAR_OPS(TYPE_FLOAT_MAT4,    TYPE_FLOAT);
+
+        // Matrix-vector.
+        MAKE_MUL_OP(TYPE_FLOAT_MAT2,    TYPE_FLOAT_VEC2);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT2X3,  TYPE_FLOAT_VEC2);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT2X4,  TYPE_FLOAT_VEC2);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT3X2,  TYPE_FLOAT_VEC3);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT3,    TYPE_FLOAT_VEC3);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT3X4,  TYPE_FLOAT_VEC3);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT4X2,  TYPE_FLOAT_VEC4);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT4X3,  TYPE_FLOAT_VEC4);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT4,    TYPE_FLOAT_VEC4);
+
+        // Vector-matrix.
+        MAKE_MUL_OP(TYPE_FLOAT_VEC2, TYPE_FLOAT_MAT2);
+        MAKE_MUL_OP(TYPE_FLOAT_VEC3, TYPE_FLOAT_MAT2X3);
+        MAKE_MUL_OP(TYPE_FLOAT_VEC4, TYPE_FLOAT_MAT2X4);
+        MAKE_MUL_OP(TYPE_FLOAT_VEC2, TYPE_FLOAT_MAT3X2);
+        MAKE_MUL_OP(TYPE_FLOAT_VEC3, TYPE_FLOAT_MAT3);
+        MAKE_MUL_OP(TYPE_FLOAT_VEC4, TYPE_FLOAT_MAT3X4);
+        MAKE_MUL_OP(TYPE_FLOAT_VEC2, TYPE_FLOAT_MAT4X2);
+        MAKE_MUL_OP(TYPE_FLOAT_VEC3, TYPE_FLOAT_MAT4X3);
+        MAKE_MUL_OP(TYPE_FLOAT_VEC4, TYPE_FLOAT_MAT4);
+
+        // Matrix-matrix.
+        MAKE_CWISE_OPS(TYPE_FLOAT_MAT2,     TYPE_FLOAT_MAT2);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT2,        TYPE_FLOAT_MAT2);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT2,        TYPE_FLOAT_MAT3X2);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT2,        TYPE_FLOAT_MAT4X2);
+
+        MAKE_CWISE_OPS(TYPE_FLOAT_MAT2X3,   TYPE_FLOAT_MAT2X3);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT2X3,      TYPE_FLOAT_MAT2);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT2X3,      TYPE_FLOAT_MAT3X2);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT2X3,      TYPE_FLOAT_MAT4X2);
+
+        MAKE_CWISE_OPS(TYPE_FLOAT_MAT2X4,   TYPE_FLOAT_MAT2X4);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT2X4,      TYPE_FLOAT_MAT2);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT2X4,      TYPE_FLOAT_MAT3X2);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT2X4,      TYPE_FLOAT_MAT4X2);
+
+        MAKE_CWISE_OPS(TYPE_FLOAT_MAT3X2,   TYPE_FLOAT_MAT3X2);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT3X2,      TYPE_FLOAT_MAT2X3);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT3X2,      TYPE_FLOAT_MAT3);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT3X2,      TYPE_FLOAT_MAT4X3);
+
+        MAKE_CWISE_OPS(TYPE_FLOAT_MAT3,     TYPE_FLOAT_MAT3);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT3,        TYPE_FLOAT_MAT2X3);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT3,        TYPE_FLOAT_MAT3);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT3,        TYPE_FLOAT_MAT4X3);
+
+        MAKE_CWISE_OPS(TYPE_FLOAT_MAT3X4,   TYPE_FLOAT_MAT3X4);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT3X4,      TYPE_FLOAT_MAT2X3);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT3X4,      TYPE_FLOAT_MAT3);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT3X4,      TYPE_FLOAT_MAT4X3);
+
+        MAKE_CWISE_OPS(TYPE_FLOAT_MAT4X2,   TYPE_FLOAT_MAT4X2);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT4X2,      TYPE_FLOAT_MAT2X4);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT4X2,      TYPE_FLOAT_MAT3X4);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT4X2,      TYPE_FLOAT_MAT4);
+
+        MAKE_CWISE_OPS(TYPE_FLOAT_MAT4X3,   TYPE_FLOAT_MAT4X3);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT4X3,      TYPE_FLOAT_MAT2X4);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT4X3,      TYPE_FLOAT_MAT3X4);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT4X3,      TYPE_FLOAT_MAT4);
+
+        MAKE_CWISE_OPS(TYPE_FLOAT_MAT4,     TYPE_FLOAT_MAT4);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT4,        TYPE_FLOAT_MAT2X4);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT4,        TYPE_FLOAT_MAT3X4);
+        MAKE_MUL_OP(TYPE_FLOAT_MAT4,        TYPE_FLOAT_MAT4);
+
+        // Vector-vector.
+        MAKE_VECVEC_OP(TYPE_FLOAT_VEC2,     TYPE_FLOAT_VEC2);
+        MAKE_VECVEC_OP(TYPE_FLOAT_VEC2,     TYPE_FLOAT_VEC3);
+        MAKE_VECVEC_OP(TYPE_FLOAT_VEC2,     TYPE_FLOAT_VEC4);
+        MAKE_VECVEC_OP(TYPE_FLOAT_VEC3,     TYPE_FLOAT_VEC2);
+        MAKE_VECVEC_OP(TYPE_FLOAT_VEC3,     TYPE_FLOAT_VEC3);
+        MAKE_VECVEC_OP(TYPE_FLOAT_VEC3,     TYPE_FLOAT_VEC4);
+        MAKE_VECVEC_OP(TYPE_FLOAT_VEC4,     TYPE_FLOAT_VEC2);
+        MAKE_VECVEC_OP(TYPE_FLOAT_VEC4,     TYPE_FLOAT_VEC3);
+        MAKE_VECVEC_OP(TYPE_FLOAT_VEC4,     TYPE_FLOAT_VEC4);
+
+        // Unary Matrix.
+        MAKE_UNARY_SYMMETRIC_OP(TYPE_FLOAT_MAT2);
+        MAKE_UNARY_OP(TYPE_FLOAT_MAT2X3);
+        MAKE_UNARY_OP(TYPE_FLOAT_MAT2X4);
+        MAKE_UNARY_OP(TYPE_FLOAT_MAT3X2);
+        MAKE_UNARY_SYMMETRIC_OP(TYPE_FLOAT_MAT3);
+        MAKE_UNARY_OP(TYPE_FLOAT_MAT3X4);
+        MAKE_UNARY_OP(TYPE_FLOAT_MAT4X2);
+        MAKE_UNARY_OP(TYPE_FLOAT_MAT4X3);
+        MAKE_UNARY_SYMMETRIC_OP(TYPE_FLOAT_MAT4);
+
+        // Assignments
+        MAKE_ASSIGNMENT_SYMMETRIC_OP(TYPE_FLOAT_MAT2);
+        MAKE_ASSIGNMENT_OP(TYPE_FLOAT_MAT2X3);
+        MAKE_ASSIGNMENT_OP(TYPE_FLOAT_MAT2X4);
+        MAKE_ASSIGNMENT_OP(TYPE_FLOAT_MAT3X2);
+        MAKE_ASSIGNMENT_SYMMETRIC_OP(TYPE_FLOAT_MAT3);
+        MAKE_ASSIGNMENT_OP(TYPE_FLOAT_MAT3X4);
+        MAKE_ASSIGNMENT_OP(TYPE_FLOAT_MAT4X2);
+        MAKE_ASSIGNMENT_OP(TYPE_FLOAT_MAT4X3);
+        MAKE_ASSIGNMENT_SYMMETRIC_OP(TYPE_FLOAT_MAT4);
+
+        default:
+            DE_ASSERT(DE_FALSE);
+            return DE_NULL;
+    }
 
 #undef PACK_EVAL_CASE
 #undef MAKE_EVAL_CASE
@@ -1320,35 +1320,35 @@ MatrixShaderEvalFunc getEvalFunc (const ShaderInput& in0, const ShaderInput& in1
 template <int Size>
 void writeVectorConstructor (std::ostream& str, const tcu::Vector<float, Size>& v)
 {
-	str << "vec" << Size << "(";
-	for (int ndx = 0; ndx < Size; ndx++)
-	{
-		if (ndx != 0)
-			str << ", ";
-		str << de::floatToString(v[ndx], 1);
-	}
-	str << ")";
+    str << "vec" << Size << "(";
+    for (int ndx = 0; ndx < Size; ndx++)
+    {
+        if (ndx != 0)
+            str << ", ";
+        str << de::floatToString(v[ndx], 1);
+    }
+    str << ")";
 }
 
 template <int Cols, int Rows>
 void writeMatrixConstructor (std::ostream& str, const tcu::Matrix<float, Rows, Cols>& m)
 {
-	if (Rows == Cols)
-		str << "mat" << Cols;
-	else
-		str << "mat" << Cols << "x" << Rows;
-
-	str << "(";
-	for (int colNdx = 0; colNdx < Cols; colNdx++)
-	{
-		for (int rowNdx = 0; rowNdx < Rows; rowNdx++)
-		{
-			if (rowNdx > 0 || colNdx > 0)
-				str << ", ";
-			str << de::floatToString(m(rowNdx, colNdx), 1);
-		}
-	}
-	str << ")";
+    if (Rows == Cols)
+        str << "mat" << Cols;
+    else
+        str << "mat" << Cols << "x" << Rows;
+
+    str << "(";
+    for (int colNdx = 0; colNdx < Cols; colNdx++)
+    {
+        for (int rowNdx = 0; rowNdx < Rows; rowNdx++)
+        {
+            if (rowNdx > 0 || colNdx > 0)
+                str << ", ";
+            str << de::floatToString(m(rowNdx, colNdx), 1);
+        }
+    }
+    str << ")";
 }
 
 } // MatrixCaseUtils
@@ -1358,53 +1358,53 @@ using namespace MatrixCaseUtils;
 class MatrixShaderEvaluator : public ShaderEvaluator
 {
 public:
-							MatrixShaderEvaluator	(MatrixShaderEvalFunc evalFunc, InputType inType0, InputType inType1);
+                            MatrixShaderEvaluator   (MatrixShaderEvalFunc evalFunc, InputType inType0, InputType inType1);
 
-	virtual void			evaluate				(ShaderEvalContext& evalCtx);
+    virtual void            evaluate                (ShaderEvalContext& evalCtx);
 
 private:
-	MatrixShaderEvalFunc	m_matEvalFunc;
-	InputType				m_inType0;
-	InputType				m_inType1;
+    MatrixShaderEvalFunc    m_matEvalFunc;
+    InputType               m_inType0;
+    InputType               m_inType1;
 };
 
 MatrixShaderEvaluator::MatrixShaderEvaluator (MatrixShaderEvalFunc evalFunc, InputType inType0, InputType inType1)
-	: m_matEvalFunc	(evalFunc)
-	, m_inType0		(inType0)
-	, m_inType1		(inType1)
+    : m_matEvalFunc (evalFunc)
+    , m_inType0     (inType0)
+    , m_inType1     (inType1)
 {
 }
 
 void MatrixShaderEvaluator::evaluate (ShaderEvalContext& evalCtx)
 {
-	m_matEvalFunc(evalCtx, m_inType0, m_inType1);
+    m_matEvalFunc(evalCtx, m_inType0, m_inType1);
 }
 
 class ShaderMatrixCase : public ShaderRenderCase
 {
 public:
-							ShaderMatrixCase			(Context& context, const char* name, const char* desc, const ShaderInput& in0, const ShaderInput& in1, MatrixOp op, bool isVertexCase);
-							~ShaderMatrixCase			(void);
+                            ShaderMatrixCase            (Context& context, const char* name, const char* desc, const ShaderInput& in0, const ShaderInput& in1, MatrixOp op, bool isVertexCase);
+                            ~ShaderMatrixCase           (void);
 
-	void					init						(void);
+    void                    init                        (void);
 
 protected:
-	std::string				genGLSLMatToVec3Reduction	(const glu::DataType& matType, const char* varName);
-	void					setupUniforms				(int programID, const tcu::Vec4& constCoords);
+    std::string             genGLSLMatToVec3Reduction   (const glu::DataType& matType, const char* varName);
+    void                    setupUniforms               (int programID, const tcu::Vec4& constCoords);
 
 private:
-	ShaderInput				m_in0;
-	ShaderInput				m_in1;
-	MatrixOp				m_op;
-	MatrixShaderEvaluator	m_matEvaluator;
+    ShaderInput             m_in0;
+    ShaderInput             m_in1;
+    MatrixOp                m_op;
+    MatrixShaderEvaluator   m_matEvaluator;
 };
 
 ShaderMatrixCase::ShaderMatrixCase (Context& context, const char* name, const char* desc, const ShaderInput& in0, const ShaderInput& in1, MatrixOp op, bool isVertexCase)
-	: ShaderRenderCase	(context.getTestContext(), context.getRenderContext(), context.getContextInfo(), name, desc, isVertexCase, m_matEvaluator)
-	, m_in0				(in0)
-	, m_in1				(in1)
-	, m_op				(op)
-	, m_matEvaluator	(getEvalFunc(in0, in1, op), in0.inputType, in1.inputType)
+    : ShaderRenderCase  (context.getTestContext(), context.getRenderContext(), context.getContextInfo(), name, desc, isVertexCase, m_matEvaluator)
+    , m_in0             (in0)
+    , m_in1             (in1)
+    , m_op              (op)
+    , m_matEvaluator    (getEvalFunc(in0, in1, op), in0.inputType, in1.inputType)
 {
 }
 
@@ -1414,374 +1414,374 @@ ShaderMatrixCase::~ShaderMatrixCase (void)
 
 void ShaderMatrixCase::init (void)
 {
-	std::ostringstream	vtx;
-	std::ostringstream	frag;
-	std::ostringstream&	op				= m_isVertexCase ? vtx : frag;
-
-	bool				isInDynMat0		= isDataTypeMatrix(m_in0.dataType) && m_in0.inputType == INPUTTYPE_DYNAMIC;
-	bool				isInDynMat1		= isDataTypeMatrix(m_in1.dataType) && m_in1.inputType == INPUTTYPE_DYNAMIC;
-	string				inValue0;
-	string				inValue1;
-	DataType			resultType		= TYPE_LAST;
-	Precision			resultPrec		= m_in0.precision;
-	vector<string>		passVars;
-	int					numInputs		= (isOperationBinary(m_op)) ? (2) : (1);
-
-	std::string			operationValue0;
-	std::string			operationValue1;
-
-	DE_ASSERT(!isInDynMat0 || !isInDynMat1); // Only single dynamic matrix input is allowed.
-	DE_UNREF(isInDynMat0 && isInDynMat1);
-
-	// Compute result type.
-	if (m_op == OP_MUL && isDataTypeMatrix(m_in0.dataType) && isDataTypeMatrix(m_in1.dataType))
-	{
-		resultType = getDataTypeMatrix(getDataTypeMatrixNumColumns(m_in1.dataType), getDataTypeMatrixNumRows(m_in0.dataType));
-	}
-	else if (m_op == OP_OUTER_PRODUCT)
-	{
-		resultType = getDataTypeMatrix(getDataTypeScalarSize(m_in1.dataType), getDataTypeScalarSize(m_in0.dataType));
-	}
-	else if (m_op == OP_TRANSPOSE)
-	{
-		resultType = getDataTypeMatrix(getDataTypeMatrixNumRows(m_in0.dataType), getDataTypeMatrixNumColumns(m_in0.dataType));
-	}
-	else if (m_op == OP_INVERSE)
-	{
-		resultType = m_in0.dataType;
-	}
-	else if (m_op == OP_DETERMINANT)
-	{
-		resultType = TYPE_FLOAT;
-	}
-	else if (getOperationType(m_op) == OPERATIONTYPE_UNARY_PREFIX_OPERATOR ||
-			 getOperationType(m_op) == OPERATIONTYPE_UNARY_POSTFIX_OPERATOR)
-	{
-		resultType = m_in0.dataType;
-	}
-	else if (isDataTypeMatrix(m_in0.dataType) && isDataTypeMatrix(m_in1.dataType))
-	{
-		DE_ASSERT(m_in0.dataType == m_in1.dataType);
-		resultType = m_in0.dataType;
-	}
-	else if (isDataTypeMatrix(m_in0.dataType) || isDataTypeMatrix(m_in1.dataType))
-	{
-		int			matNdx		= isDataTypeMatrix(m_in0.dataType) ? 0 : 1;
-		DataType	matrixType	= matNdx == 0 ? m_in0.dataType : m_in1.dataType;
-		DataType	otherType	= matNdx == 0 ? m_in1.dataType : m_in0.dataType;
-
-		if (otherType == TYPE_FLOAT)
-			resultType = matrixType;
-		else
-		{
-			DE_ASSERT(isDataTypeVector(otherType));
-			resultType = getDataTypeFloatVec(matNdx == 0 ? getDataTypeMatrixNumRows(matrixType) : getDataTypeMatrixNumColumns(matrixType));
-		}
-	}
-	else
-	{
-		DE_ASSERT(DE_FALSE);
-	}
-
-	vtx << "#version 300 es\n";
-	frag << "#version 300 es\n";
-
-	vtx << "in highp vec4 a_position;\n";
-	frag << "layout(location = 0) out mediump vec4 dEQP_FragColor;\n";
-	if (m_isVertexCase)
-	{
-		vtx << "out mediump vec4 v_color;\n";
-		frag << "in mediump vec4 v_color;\n";
-	}
-
-	// Input declarations.
-	for (int inNdx = 0; inNdx < numInputs; inNdx++)
-	{
-		const ShaderInput&	in			= inNdx > 0 ? m_in1 : m_in0;
-		const char*			precName	= getPrecisionName(in.precision);
-		const char*			typeName	= getDataTypeName(in.dataType);
-		string&				inValue		= inNdx > 0 ? inValue1 : inValue0;
-
-		if (in.inputType == INPUTTYPE_DYNAMIC)
-		{
-			vtx << "in " << precName << " " << typeName << " a_";
-
-			if (isDataTypeMatrix(in.dataType))
-			{
-				// a_matN, v_matN
-				vtx << typeName << ";\n";
-				if (!m_isVertexCase)
-				{
-					vtx << "out " << precName << " " << typeName << " v_" << typeName << ";\n";
-					frag << "in " << precName << " " << typeName << " v_" << typeName << ";\n";
-					passVars.push_back(typeName);
-				}
-
-				inValue = string(m_isVertexCase ? "a_" : "v_") + getDataTypeName(in.dataType);
-			}
-			else
-			{
-				// a_coords, v_coords
-				vtx << "coords;\n";
-				if (!m_isVertexCase)
-				{
-					vtx << "out " << precName << " " << typeName << " v_coords;\n";
-					frag << "in " << precName << " " << typeName << " v_coords;\n";
-					passVars.push_back("coords");
-				}
-
-				inValue = m_isVertexCase ? "a_coords" : "v_coords";
-			}
-		}
-		else if (in.inputType == INPUTTYPE_UNIFORM)
-		{
-			op << "uniform " << precName << " " << typeName << " u_in" << inNdx << ";\n";
-			inValue = string("u_in") + de::toString(inNdx);
-		}
-		else if (in.inputType == INPUTTYPE_CONST)
-		{
-			op << "const " << precName << " " << typeName << " in" << inNdx << " = ";
-
-			// Generate declaration.
-			switch (in.dataType)
-			{
-				case TYPE_FLOAT:		op << de::floatToString(s_constInFloat[inNdx], 1);					break;
-				case TYPE_FLOAT_VEC2:	writeVectorConstructor<2>(op, s_constInVec2[inNdx]);				break;
-				case TYPE_FLOAT_VEC3:	writeVectorConstructor<3>(op, s_constInVec3[inNdx]);				break;
-				case TYPE_FLOAT_VEC4:	writeVectorConstructor<4>(op, s_constInVec4[inNdx]);				break;
-				case TYPE_FLOAT_MAT2:	writeMatrixConstructor<2, 2>(op, Mat2(s_constInMat2x2[inNdx]));		break;
-				case TYPE_FLOAT_MAT2X3:	writeMatrixConstructor<2, 3>(op, Mat2x3(s_constInMat2x3[inNdx]));	break;
-				case TYPE_FLOAT_MAT2X4:	writeMatrixConstructor<2, 4>(op, Mat2x4(s_constInMat2x4[inNdx]));	break;
-				case TYPE_FLOAT_MAT3X2:	writeMatrixConstructor<3, 2>(op, Mat3x2(s_constInMat3x2[inNdx]));	break;
-				case TYPE_FLOAT_MAT3:	writeMatrixConstructor<3, 3>(op, Mat3(s_constInMat3x3[inNdx]));		break;
-				case TYPE_FLOAT_MAT3X4:	writeMatrixConstructor<3, 4>(op, Mat3x4(s_constInMat3x4[inNdx]));	break;
-				case TYPE_FLOAT_MAT4X2:	writeMatrixConstructor<4, 2>(op, Mat4x2(s_constInMat4x2[inNdx]));	break;
-				case TYPE_FLOAT_MAT4X3:	writeMatrixConstructor<4, 3>(op, Mat4x3(s_constInMat4x3[inNdx]));	break;
-				case TYPE_FLOAT_MAT4:	writeMatrixConstructor<4, 4>(op, Mat4(s_constInMat4x4[inNdx]));		break;
-
-				default:
-					DE_ASSERT(DE_FALSE);
-			}
-
-			op << ";\n";
-
-			inValue = string("in") + de::toString(inNdx);
-		}
-	}
-
-	vtx << "\n"
-		<< "void main (void)\n"
-		<< "{\n"
-		<< "	gl_Position = a_position;\n";
-	frag << "\n"
-		 << "void main (void)\n"
-		 << "{\n";
-
-	if (m_isVertexCase)
-		frag << "	dEQP_FragColor = v_color;\n";
-	else
-	{
-		for (vector<string>::const_iterator copyIter = passVars.begin(); copyIter != passVars.end(); copyIter++)
-			vtx << "	v_" << *copyIter << " = " << "a_" << *copyIter << ";\n";
-	}
-
-	// Operation.
-
-	switch (getOperationNature(m_op))
-	{
-		case OPERATIONNATURE_PURE:
-			DE_ASSERT(getOperationType(m_op) != OPERATIONTYPE_ASSIGNMENT);
-
-			operationValue0 = inValue0;
-			operationValue1 = inValue1;
-			break;
-
-		case OPERATIONNATURE_MUTATING:
-			DE_ASSERT(getOperationType(m_op) != OPERATIONTYPE_ASSIGNMENT);
-
-			op << "	" << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " tmpValue = " << inValue0 << ";\n";
-
-			operationValue0 = "tmpValue";
-			operationValue1 = inValue1;
-			break;
-
-		case OPERATIONNATURE_ASSIGNMENT:
-			DE_ASSERT(getOperationType(m_op) == OPERATIONTYPE_ASSIGNMENT);
-
-			operationValue0 = inValue0;
-			operationValue1 = inValue1;
-			break;
-
-		default:
-			DE_ASSERT(DE_FALSE);
-	}
-
-	switch (getOperationType(m_op))
-	{
-		case OPERATIONTYPE_BINARY_OPERATOR:
-			op << "	" << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << operationValue0 << " " << getOperationName(m_op) << " " << operationValue1 << ";\n";
-			break;
-
-		case OPERATIONTYPE_UNARY_PREFIX_OPERATOR:
-			op << "	" << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << getOperationName(m_op) << operationValue0 << ";\n";
-			break;
-
-		case OPERATIONTYPE_UNARY_POSTFIX_OPERATOR:
-			op << "	" << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << operationValue0 << getOperationName(m_op) << ";\n";
-			break;
-
-		case OPERATIONTYPE_BINARY_FUNCTION:
-			op << "	" << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << getOperationName(m_op) << "(" << operationValue0 << ", " << operationValue1 << ");\n";
-			break;
-
-		case OPERATIONTYPE_UNARY_FUNCTION:
-			op << "	" << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << getOperationName(m_op) << "(" << operationValue0 << ");\n";
-			break;
-
-		case OPERATIONTYPE_ASSIGNMENT:
-			op << "	" << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << operationValue0 << ";\n";
-			op << "	res " << getOperationName(m_op) << " " << operationValue1 << ";\n";
-			break;
-
-		default:
-			DE_ASSERT(DE_FALSE);
-	}
-
-	// Reduction to vec3 (rgb). Check the used value too if it was modified
-	op << "	" << (m_isVertexCase ? "v_color" : "dEQP_FragColor") << " = ";
-
-	if (isOperationValueModifying(m_op))
-		op << "vec4(" << genGLSLMatToVec3Reduction(resultType, "res") << ", 1.0) + vec4(" << genGLSLMatToVec3Reduction(resultType, "tmpValue") << ", 0.0);\n";
-	else
-		op << "vec4(" << genGLSLMatToVec3Reduction(resultType, "res") << ", 1.0);\n";
-
-	vtx << "}\n";
-	frag << "}\n";
-
-	m_vertShaderSource	= vtx.str();
-	m_fragShaderSource	= frag.str();
-
-	// \todo [2012-02-14 pyry] Compute better values for matrix tests.
-	m_userAttribTransforms.resize(4);
-	for (int attribNdx = 0; attribNdx < 4; attribNdx++)
-	{
-		m_userAttribTransforms[attribNdx] = Mat4(0.0f);
-		m_userAttribTransforms[attribNdx](                  0, 3) = 0.2f;								// !< prevent matrix*vec from going into zero (assuming vec.w != 0)
-		m_userAttribTransforms[attribNdx](                  1, 3) = 0.1f;								// !<
-		m_userAttribTransforms[attribNdx](                  2, 3) = 0.4f + 0.15f * float(attribNdx);	// !<
-		m_userAttribTransforms[attribNdx](                  3, 3) = 0.7f;								// !<
-		m_userAttribTransforms[attribNdx]((0 + attribNdx) % 4, 0) = 1.0f;
-		m_userAttribTransforms[attribNdx]((1 + attribNdx) % 4, 1) = 1.0f;
-		m_userAttribTransforms[attribNdx]((2 + attribNdx) % 4, 2) = 1.0f;
-		m_userAttribTransforms[attribNdx]((3 + attribNdx) % 4, 3) = 1.0f;
-	}
-
-	// prevent bad reference cases such as black result images by fine-tuning used matrices
-	if (getOperationTestMatrixType(m_op) != TESTMATRIXTYPE_DEFAULT)
-	{
-		for (int attribNdx = 0; attribNdx < 4; attribNdx++)
-		{
-			for (int row = 0; row < 4; row++)
-			for (int col = 0; col < 4; col++)
-			{
-				switch (getOperationTestMatrixType(m_op))
-				{
-					case TESTMATRIXTYPE_NEGATED:
-						m_userAttribTransforms[attribNdx](row, col) = -m_userAttribTransforms[attribNdx](row, col);
-						break;
-					case TESTMATRIXTYPE_INCREMENTED:
-						m_userAttribTransforms[attribNdx](row, col) += 0.3f;
-						break;
-					case TESTMATRIXTYPE_DECREMENTED:
-						m_userAttribTransforms[attribNdx](row, col) -= 0.3f;
-						break;
-					case TESTMATRIXTYPE_NEGATED_INCREMENTED:
-						m_userAttribTransforms[attribNdx](row, col) = -m_userAttribTransforms[attribNdx](row, col) + 0.3f;
-						break;
-					case TESTMATRIXTYPE_INCREMENTED_LESS:
-						m_userAttribTransforms[attribNdx](row, col) -= 0.1f;
-						break;
-
-					default:
-						DE_ASSERT(DE_FALSE);
-						break;
-				}
-			}
-		}
-	}
-
-	ShaderRenderCase::init();
+    std::ostringstream  vtx;
+    std::ostringstream  frag;
+    std::ostringstream& op              = m_isVertexCase ? vtx : frag;
+
+    bool                isInDynMat0     = isDataTypeMatrix(m_in0.dataType) && m_in0.inputType == INPUTTYPE_DYNAMIC;
+    bool                isInDynMat1     = isDataTypeMatrix(m_in1.dataType) && m_in1.inputType == INPUTTYPE_DYNAMIC;
+    string              inValue0;
+    string              inValue1;
+    DataType            resultType      = TYPE_LAST;
+    Precision           resultPrec      = m_in0.precision;
+    vector<string>      passVars;
+    int                 numInputs       = (isOperationBinary(m_op)) ? (2) : (1);
+
+    std::string         operationValue0;
+    std::string         operationValue1;
+
+    DE_ASSERT(!isInDynMat0 || !isInDynMat1); // Only single dynamic matrix input is allowed.
+    DE_UNREF(isInDynMat0 && isInDynMat1);
+
+    // Compute result type.
+    if (m_op == OP_MUL && isDataTypeMatrix(m_in0.dataType) && isDataTypeMatrix(m_in1.dataType))
+    {
+        resultType = getDataTypeMatrix(getDataTypeMatrixNumColumns(m_in1.dataType), getDataTypeMatrixNumRows(m_in0.dataType));
+    }
+    else if (m_op == OP_OUTER_PRODUCT)
+    {
+        resultType = getDataTypeMatrix(getDataTypeScalarSize(m_in1.dataType), getDataTypeScalarSize(m_in0.dataType));
+    }
+    else if (m_op == OP_TRANSPOSE)
+    {
+        resultType = getDataTypeMatrix(getDataTypeMatrixNumRows(m_in0.dataType), getDataTypeMatrixNumColumns(m_in0.dataType));
+    }
+    else if (m_op == OP_INVERSE)
+    {
+        resultType = m_in0.dataType;
+    }
+    else if (m_op == OP_DETERMINANT)
+    {
+        resultType = TYPE_FLOAT;
+    }
+    else if (getOperationType(m_op) == OPERATIONTYPE_UNARY_PREFIX_OPERATOR ||
+             getOperationType(m_op) == OPERATIONTYPE_UNARY_POSTFIX_OPERATOR)
+    {
+        resultType = m_in0.dataType;
+    }
+    else if (isDataTypeMatrix(m_in0.dataType) && isDataTypeMatrix(m_in1.dataType))
+    {
+        DE_ASSERT(m_in0.dataType == m_in1.dataType);
+        resultType = m_in0.dataType;
+    }
+    else if (isDataTypeMatrix(m_in0.dataType) || isDataTypeMatrix(m_in1.dataType))
+    {
+        int         matNdx      = isDataTypeMatrix(m_in0.dataType) ? 0 : 1;
+        DataType    matrixType  = matNdx == 0 ? m_in0.dataType : m_in1.dataType;
+        DataType    otherType   = matNdx == 0 ? m_in1.dataType : m_in0.dataType;
+
+        if (otherType == TYPE_FLOAT)
+            resultType = matrixType;
+        else
+        {
+            DE_ASSERT(isDataTypeVector(otherType));
+            resultType = getDataTypeFloatVec(matNdx == 0 ? getDataTypeMatrixNumRows(matrixType) : getDataTypeMatrixNumColumns(matrixType));
+        }
+    }
+    else
+    {
+        DE_ASSERT(DE_FALSE);
+    }
+
+    vtx << "#version 300 es\n";
+    frag << "#version 300 es\n";
+
+    vtx << "in highp vec4 a_position;\n";
+    frag << "layout(location = 0) out mediump vec4 dEQP_FragColor;\n";
+    if (m_isVertexCase)
+    {
+        vtx << "out mediump vec4 v_color;\n";
+        frag << "in mediump vec4 v_color;\n";
+    }
+
+    // Input declarations.
+    for (int inNdx = 0; inNdx < numInputs; inNdx++)
+    {
+        const ShaderInput&  in          = inNdx > 0 ? m_in1 : m_in0;
+        const char*         precName    = getPrecisionName(in.precision);
+        const char*         typeName    = getDataTypeName(in.dataType);
+        string&             inValue     = inNdx > 0 ? inValue1 : inValue0;
+
+        if (in.inputType == INPUTTYPE_DYNAMIC)
+        {
+            vtx << "in " << precName << " " << typeName << " a_";
+
+            if (isDataTypeMatrix(in.dataType))
+            {
+                // a_matN, v_matN
+                vtx << typeName << ";\n";
+                if (!m_isVertexCase)
+                {
+                    vtx << "out " << precName << " " << typeName << " v_" << typeName << ";\n";
+                    frag << "in " << precName << " " << typeName << " v_" << typeName << ";\n";
+                    passVars.push_back(typeName);
+                }
+
+                inValue = string(m_isVertexCase ? "a_" : "v_") + getDataTypeName(in.dataType);
+            }
+            else
+            {
+                // a_coords, v_coords
+                vtx << "coords;\n";
+                if (!m_isVertexCase)
+                {
+                    vtx << "out " << precName << " " << typeName << " v_coords;\n";
+                    frag << "in " << precName << " " << typeName << " v_coords;\n";
+                    passVars.push_back("coords");
+                }
+
+                inValue = m_isVertexCase ? "a_coords" : "v_coords";
+            }
+        }
+        else if (in.inputType == INPUTTYPE_UNIFORM)
+        {
+            op << "uniform " << precName << " " << typeName << " u_in" << inNdx << ";\n";
+            inValue = string("u_in") + de::toString(inNdx);
+        }
+        else if (in.inputType == INPUTTYPE_CONST)
+        {
+            op << "const " << precName << " " << typeName << " in" << inNdx << " = ";
+
+            // Generate declaration.
+            switch (in.dataType)
+            {
+                case TYPE_FLOAT:        op << de::floatToString(s_constInFloat[inNdx], 1);                  break;
+                case TYPE_FLOAT_VEC2:   writeVectorConstructor<2>(op, s_constInVec2[inNdx]);                break;
+                case TYPE_FLOAT_VEC3:   writeVectorConstructor<3>(op, s_constInVec3[inNdx]);                break;
+                case TYPE_FLOAT_VEC4:   writeVectorConstructor<4>(op, s_constInVec4[inNdx]);                break;
+                case TYPE_FLOAT_MAT2:   writeMatrixConstructor<2, 2>(op, Mat2(s_constInMat2x2[inNdx]));     break;
+                case TYPE_FLOAT_MAT2X3: writeMatrixConstructor<2, 3>(op, Mat2x3(s_constInMat2x3[inNdx]));   break;
+                case TYPE_FLOAT_MAT2X4: writeMatrixConstructor<2, 4>(op, Mat2x4(s_constInMat2x4[inNdx]));   break;
+                case TYPE_FLOAT_MAT3X2: writeMatrixConstructor<3, 2>(op, Mat3x2(s_constInMat3x2[inNdx]));   break;
+                case TYPE_FLOAT_MAT3:   writeMatrixConstructor<3, 3>(op, Mat3(s_constInMat3x3[inNdx]));     break;
+                case TYPE_FLOAT_MAT3X4: writeMatrixConstructor<3, 4>(op, Mat3x4(s_constInMat3x4[inNdx]));   break;
+                case TYPE_FLOAT_MAT4X2: writeMatrixConstructor<4, 2>(op, Mat4x2(s_constInMat4x2[inNdx]));   break;
+                case TYPE_FLOAT_MAT4X3: writeMatrixConstructor<4, 3>(op, Mat4x3(s_constInMat4x3[inNdx]));   break;
+                case TYPE_FLOAT_MAT4:   writeMatrixConstructor<4, 4>(op, Mat4(s_constInMat4x4[inNdx]));     break;
+
+                default:
+                    DE_ASSERT(DE_FALSE);
+            }
+
+            op << ";\n";
+
+            inValue = string("in") + de::toString(inNdx);
+        }
+    }
+
+    vtx << "\n"
+        << "void main (void)\n"
+        << "{\n"
+        << "    gl_Position = a_position;\n";
+    frag << "\n"
+         << "void main (void)\n"
+         << "{\n";
+
+    if (m_isVertexCase)
+        frag << "   dEQP_FragColor = v_color;\n";
+    else
+    {
+        for (vector<string>::const_iterator copyIter = passVars.begin(); copyIter != passVars.end(); copyIter++)
+            vtx << "    v_" << *copyIter << " = " << "a_" << *copyIter << ";\n";
+    }
+
+    // Operation.
+
+    switch (getOperationNature(m_op))
+    {
+        case OPERATIONNATURE_PURE:
+            DE_ASSERT(getOperationType(m_op) != OPERATIONTYPE_ASSIGNMENT);
+
+            operationValue0 = inValue0;
+            operationValue1 = inValue1;
+            break;
+
+        case OPERATIONNATURE_MUTATING:
+            DE_ASSERT(getOperationType(m_op) != OPERATIONTYPE_ASSIGNMENT);
+
+            op << " " << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " tmpValue = " << inValue0 << ";\n";
+
+            operationValue0 = "tmpValue";
+            operationValue1 = inValue1;
+            break;
+
+        case OPERATIONNATURE_ASSIGNMENT:
+            DE_ASSERT(getOperationType(m_op) == OPERATIONTYPE_ASSIGNMENT);
+
+            operationValue0 = inValue0;
+            operationValue1 = inValue1;
+            break;
+
+        default:
+            DE_ASSERT(DE_FALSE);
+    }
+
+    switch (getOperationType(m_op))
+    {
+        case OPERATIONTYPE_BINARY_OPERATOR:
+            op << " " << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << operationValue0 << " " << getOperationName(m_op) << " " << operationValue1 << ";\n";
+            break;
+
+        case OPERATIONTYPE_UNARY_PREFIX_OPERATOR:
+            op << " " << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << getOperationName(m_op) << operationValue0 << ";\n";
+            break;
+
+        case OPERATIONTYPE_UNARY_POSTFIX_OPERATOR:
+            op << " " << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << operationValue0 << getOperationName(m_op) << ";\n";
+            break;
+
+        case OPERATIONTYPE_BINARY_FUNCTION:
+            op << " " << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << getOperationName(m_op) << "(" << operationValue0 << ", " << operationValue1 << ");\n";
+            break;
+
+        case OPERATIONTYPE_UNARY_FUNCTION:
+            op << " " << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << getOperationName(m_op) << "(" << operationValue0 << ");\n";
+            break;
+
+        case OPERATIONTYPE_ASSIGNMENT:
+            op << " " << getPrecisionName(resultPrec) << " " << getDataTypeName(resultType) << " res = " << operationValue0 << ";\n";
+            op << " res " << getOperationName(m_op) << " " << operationValue1 << ";\n";
+            break;
+
+        default:
+            DE_ASSERT(DE_FALSE);
+    }
+
+    // Reduction to vec3 (rgb). Check the used value too if it was modified
+    op << " " << (m_isVertexCase ? "v_color" : "dEQP_FragColor") << " = ";
+
+    if (isOperationValueModifying(m_op))
+        op << "vec4(" << genGLSLMatToVec3Reduction(resultType, "res") << ", 1.0) + vec4(" << genGLSLMatToVec3Reduction(resultType, "tmpValue") << ", 0.0);\n";
+    else
+        op << "vec4(" << genGLSLMatToVec3Reduction(resultType, "res") << ", 1.0);\n";
+
+    vtx << "}\n";
+    frag << "}\n";
+
+    m_vertShaderSource  = vtx.str();
+    m_fragShaderSource  = frag.str();
+
+    // \todo [2012-02-14 pyry] Compute better values for matrix tests.
+    m_userAttribTransforms.resize(4);
+    for (int attribNdx = 0; attribNdx < 4; attribNdx++)
+    {
+        m_userAttribTransforms[attribNdx] = Mat4(0.0f);
+        m_userAttribTransforms[attribNdx](                  0, 3) = 0.2f;                               // !< prevent matrix*vec from going into zero (assuming vec.w != 0)
+        m_userAttribTransforms[attribNdx](                  1, 3) = 0.1f;                               // !<
+        m_userAttribTransforms[attribNdx](                  2, 3) = 0.4f + 0.15f * float(attribNdx);    // !<
+        m_userAttribTransforms[attribNdx](                  3, 3) = 0.7f;                               // !<
+        m_userAttribTransforms[attribNdx]((0 + attribNdx) % 4, 0) = 1.0f;
+        m_userAttribTransforms[attribNdx]((1 + attribNdx) % 4, 1) = 1.0f;
+        m_userAttribTransforms[attribNdx]((2 + attribNdx) % 4, 2) = 1.0f;
+        m_userAttribTransforms[attribNdx]((3 + attribNdx) % 4, 3) = 1.0f;
+    }
+
+    // prevent bad reference cases such as black result images by fine-tuning used matrices
+    if (getOperationTestMatrixType(m_op) != TESTMATRIXTYPE_DEFAULT)
+    {
+        for (int attribNdx = 0; attribNdx < 4; attribNdx++)
+        {
+            for (int row = 0; row < 4; row++)
+            for (int col = 0; col < 4; col++)
+            {
+                switch (getOperationTestMatrixType(m_op))
+                {
+                    case TESTMATRIXTYPE_NEGATED:
+                        m_userAttribTransforms[attribNdx](row, col) = -m_userAttribTransforms[attribNdx](row, col);
+                        break;
+                    case TESTMATRIXTYPE_INCREMENTED:
+                        m_userAttribTransforms[attribNdx](row, col) += 0.3f;
+                        break;
+                    case TESTMATRIXTYPE_DECREMENTED:
+                        m_userAttribTransforms[attribNdx](row, col) -= 0.3f;
+                        break;
+                    case TESTMATRIXTYPE_NEGATED_INCREMENTED:
+                        m_userAttribTransforms[attribNdx](row, col) = -m_userAttribTransforms[attribNdx](row, col) + 0.3f;
+                        break;
+                    case TESTMATRIXTYPE_INCREMENTED_LESS:
+                        m_userAttribTransforms[attribNdx](row, col) -= 0.1f;
+                        break;
+
+                    default:
+                        DE_ASSERT(DE_FALSE);
+                        break;
+                }
+            }
+        }
+    }
+
+    ShaderRenderCase::init();
 }
 
 std::string ShaderMatrixCase::genGLSLMatToVec3Reduction (const glu::DataType& matType, const char* varName)
 {
-	std::ostringstream op;
-
-	switch (matType)
-	{
-		case TYPE_FLOAT:		op << varName << ", "			<< varName << ", "			<< varName << "";																																			break;
-		case TYPE_FLOAT_VEC2:	op << varName << ".x, "			<< varName << ".y, "		<< varName << ".x";																																			break;
-		case TYPE_FLOAT_VEC3:	op << varName << "";																																																	break;
-		case TYPE_FLOAT_VEC4:	op << varName << ".x, "			<< varName << ".y, "		<< varName << ".z+"			<< varName << ".w";																												break;
-		case TYPE_FLOAT_MAT2:	op << varName << "[0][0], "		<< varName << "[1][0], "	<< varName << "[0][1]+"		<< varName << "[1][1]";																											break;
-		case TYPE_FLOAT_MAT2X3:	op << varName << "[0] + "		<< varName << "[1]";																																									break;
-		case TYPE_FLOAT_MAT2X4:	op << varName << "[0].xyz + "	<< varName << "[1].yzw";																																								break;
-		case TYPE_FLOAT_MAT3X2:	op << varName << "[0][0]+"		<< varName << "[0][1], "	<< varName << "[1][0]+"		<< varName << "[1][1], "	<< varName << "[2][0]+" << varName << "[2][1]";														break;
-		case TYPE_FLOAT_MAT3:	op << varName << "[0] + "		<< varName << "[1] + "		<< varName << "[2]";																																		break;
-		case TYPE_FLOAT_MAT3X4:	op << varName << "[0].xyz + "	<< varName << "[1].yzw + "	<< varName << "[2].zwx";																																	break;
-		case TYPE_FLOAT_MAT4X2:	op << varName << "[0][0]+"		<< varName << "[0][1]+"		<< varName << "[3][0], "	<< varName << "[1][0]+"		<< varName << "[1][1]+" << varName << "[3][1], " << varName << "[2][0]+" << varName << "[2][1]";	break;
-		case TYPE_FLOAT_MAT4X3:	op << varName << "[0] + "		<< varName << "[1] + "		<< varName << "[2] + "		<< varName << "[3]";																											break;
-		case TYPE_FLOAT_MAT4:	op << varName << "[0].xyz+"		<< varName << "[1].yzw+"	<< varName << "[2].zwx+"	<< varName << "[3].wxy";																										break;
-
-		default:
-			DE_ASSERT(DE_FALSE);
-	}
-
-	return op.str();
+    std::ostringstream op;
+
+    switch (matType)
+    {
+        case TYPE_FLOAT:        op << varName << ", "           << varName << ", "          << varName << "";                                                                                                                                           break;
+        case TYPE_FLOAT_VEC2:   op << varName << ".x, "         << varName << ".y, "        << varName << ".x";                                                                                                                                         break;
+        case TYPE_FLOAT_VEC3:   op << varName << "";                                                                                                                                                                                                    break;
+        case TYPE_FLOAT_VEC4:   op << varName << ".x, "         << varName << ".y, "        << varName << ".z+"         << varName << ".w";                                                                                                             break;
+        case TYPE_FLOAT_MAT2:   op << varName << "[0][0], "     << varName << "[1][0], "    << varName << "[0][1]+"     << varName << "[1][1]";                                                                                                         break;
+        case TYPE_FLOAT_MAT2X3: op << varName << "[0] + "       << varName << "[1]";                                                                                                                                                                    break;
+        case TYPE_FLOAT_MAT2X4: op << varName << "[0].xyz + "   << varName << "[1].yzw";                                                                                                                                                                break;
+        case TYPE_FLOAT_MAT3X2: op << varName << "[0][0]+"      << varName << "[0][1], "    << varName << "[1][0]+"     << varName << "[1][1], "    << varName << "[2][0]+" << varName << "[2][1]";                                                     break;
+        case TYPE_FLOAT_MAT3:   op << varName << "[0] + "       << varName << "[1] + "      << varName << "[2]";                                                                                                                                        break;
+        case TYPE_FLOAT_MAT3X4: op << varName << "[0].xyz + "   << varName << "[1].yzw + "  << varName << "[2].zwx";                                                                                                                                    break;
+        case TYPE_FLOAT_MAT4X2: op << varName << "[0][0]+"      << varName << "[0][1]+"     << varName << "[3][0], "    << varName << "[1][0]+"     << varName << "[1][1]+" << varName << "[3][1], " << varName << "[2][0]+" << varName << "[2][1]";    break;
+        case TYPE_FLOAT_MAT4X3: op << varName << "[0] + "       << varName << "[1] + "      << varName << "[2] + "      << varName << "[3]";                                                                                                            break;
+        case TYPE_FLOAT_MAT4:   op << varName << "[0].xyz+"     << varName << "[1].yzw+"    << varName << "[2].zwx+"    << varName << "[3].wxy";                                                                                                        break;
+
+        default:
+            DE_ASSERT(DE_FALSE);
+    }
+
+    return op.str();
 }
 
 void ShaderMatrixCase::setupUniforms (int programID, const tcu::Vec4& constCoords)
 {
-	const glw::Functions& gl = m_renderCtx.getFunctions();
-
-	DE_UNREF(constCoords);
-
-	for (int inNdx = 0; inNdx < 2; inNdx++)
-	{
-		const ShaderInput& in = inNdx > 0 ? m_in1 : m_in0;
-
-		if (in.inputType == INPUTTYPE_UNIFORM)
-		{
-			int loc = gl.getUniformLocation(programID, (string("u_in") + de::toString(inNdx)).c_str());
-
-			if (loc < 0)
-				continue;
-
-			switch (in.dataType)
-			{
-				case TYPE_FLOAT:		gl.uniform1f(loc, s_constInFloat[inNdx]);						break;
-				case TYPE_FLOAT_VEC2:	gl.uniform2fv(loc, 1, s_constInVec2[inNdx].getPtr());			break;
-				case TYPE_FLOAT_VEC3:	gl.uniform3fv(loc, 1, s_constInVec3[inNdx].getPtr());			break;
-				case TYPE_FLOAT_VEC4:	gl.uniform4fv(loc, 1, s_constInVec4[inNdx].getPtr());			break;
-				// \note GLES3 supports transpose in matrix upload.
-				case TYPE_FLOAT_MAT2:	gl.uniformMatrix2fv	(loc, 1, GL_TRUE, s_constInMat2x2[inNdx]);	break;
-				case TYPE_FLOAT_MAT2X3:	gl.uniformMatrix2x3fv(loc, 1, GL_TRUE, s_constInMat2x3[inNdx]);	break;
-				case TYPE_FLOAT_MAT2X4:	gl.uniformMatrix2x4fv(loc, 1, GL_TRUE, s_constInMat2x4[inNdx]);	break;
-				case TYPE_FLOAT_MAT3X2:	gl.uniformMatrix3x2fv(loc, 1, GL_TRUE, s_constInMat3x2[inNdx]);	break;
-				case TYPE_FLOAT_MAT3:	gl.uniformMatrix3fv	(loc, 1, GL_TRUE, s_constInMat3x3[inNdx]);	break;
-				case TYPE_FLOAT_MAT3X4:	gl.uniformMatrix3x4fv(loc, 1, GL_TRUE, s_constInMat3x4[inNdx]);	break;
-				case TYPE_FLOAT_MAT4X2:	gl.uniformMatrix4x2fv(loc, 1, GL_TRUE, s_constInMat4x2[inNdx]);	break;
-				case TYPE_FLOAT_MAT4X3:	gl.uniformMatrix4x3fv(loc, 1, GL_TRUE, s_constInMat4x3[inNdx]);	break;
-				case TYPE_FLOAT_MAT4:	gl.uniformMatrix4fv	(loc, 1, GL_TRUE, s_constInMat4x4[inNdx]);	break;
-				default:
-					DE_ASSERT(false);
-			}
-		}
-	}
+    const glw::Functions& gl = m_renderCtx.getFunctions();
+
+    DE_UNREF(constCoords);
+
+    for (int inNdx = 0; inNdx < 2; inNdx++)
+    {
+        const ShaderInput& in = inNdx > 0 ? m_in1 : m_in0;
+
+        if (in.inputType == INPUTTYPE_UNIFORM)
+        {
+            int loc = gl.getUniformLocation(programID, (string("u_in") + de::toString(inNdx)).c_str());
+
+            if (loc < 0)
+                continue;
+
+            switch (in.dataType)
+            {
+                case TYPE_FLOAT:        gl.uniform1f(loc, s_constInFloat[inNdx]);                       break;
+                case TYPE_FLOAT_VEC2:   gl.uniform2fv(loc, 1, s_constInVec2[inNdx].getPtr());           break;
+                case TYPE_FLOAT_VEC3:   gl.uniform3fv(loc, 1, s_constInVec3[inNdx].getPtr());           break;
+                case TYPE_FLOAT_VEC4:   gl.uniform4fv(loc, 1, s_constInVec4[inNdx].getPtr());           break;
+                // \note GLES3 supports transpose in matrix upload.
+                case TYPE_FLOAT_MAT2:   gl.uniformMatrix2fv (loc, 1, GL_TRUE, s_constInMat2x2[inNdx]);  break;
+                case TYPE_FLOAT_MAT2X3: gl.uniformMatrix2x3fv(loc, 1, GL_TRUE, s_constInMat2x3[inNdx]); break;
+                case TYPE_FLOAT_MAT2X4: gl.uniformMatrix2x4fv(loc, 1, GL_TRUE, s_constInMat2x4[inNdx]); break;
+                case TYPE_FLOAT_MAT3X2: gl.uniformMatrix3x2fv(loc, 1, GL_TRUE, s_constInMat3x2[inNdx]); break;
+                case TYPE_FLOAT_MAT3:   gl.uniformMatrix3fv (loc, 1, GL_TRUE, s_constInMat3x3[inNdx]);  break;
+                case TYPE_FLOAT_MAT3X4: gl.uniformMatrix3x4fv(loc, 1, GL_TRUE, s_constInMat3x4[inNdx]); break;
+                case TYPE_FLOAT_MAT4X2: gl.uniformMatrix4x2fv(loc, 1, GL_TRUE, s_constInMat4x2[inNdx]); break;
+                case TYPE_FLOAT_MAT4X3: gl.uniformMatrix4x3fv(loc, 1, GL_TRUE, s_constInMat4x3[inNdx]); break;
+                case TYPE_FLOAT_MAT4:   gl.uniformMatrix4fv (loc, 1, GL_TRUE, s_constInMat4x4[inNdx]);  break;
+                default:
+                    DE_ASSERT(false);
+            }
+        }
+    }
 }
 
 ShaderMatrixTests::ShaderMatrixTests (Context& context)
-	: TestCaseGroup(context, "matrix", "Matrix Tests")
+    : TestCaseGroup(context, "matrix", "Matrix Tests")
 {
 }
 
@@ -1791,181 +1791,181 @@ ShaderMatrixTests::~ShaderMatrixTests (void)
 
 void ShaderMatrixTests::init (void)
 {
-	static const struct
-	{
-		const char*		name;
-		const char*		desc;
-		MatrixOp		op;
-		bool			extendedInputTypeCases; // !< test with const and uniform types too
-		bool			createInputTypeGroup;	// !< create group for input types
-	} ops[] =
-	{
-		{ "add",			"Matrix addition tests",						OP_ADD,				true,	true	},
-		{ "sub",			"Matrix subtraction tests",						OP_SUB,				true,	true	},
-		{ "mul",			"Matrix multiplication tests",					OP_MUL,				true,	true	},
-		{ "div",			"Matrix division tests",						OP_DIV,				true,	true	},
-		{ "matrixcompmult",	"Matrix component-wise multiplication tests",	OP_COMP_MUL,		false,	true	},
-		{ "outerproduct",	"Matrix outerProduct() tests",					OP_OUTER_PRODUCT,	false,	true	},
-		{ "transpose",		"Matrix transpose() tests",						OP_TRANSPOSE,		false,	true	},
-		{ "determinant",	"Matrix determinant() tests",					OP_DETERMINANT,		false,	true	},
-		{ "inverse",		"Matrix inverse() tests",						OP_INVERSE,			false,	true	},
-		{ "unary_addition",	"Matrix unary addition tests",					OP_UNARY_PLUS,		false,	false	},
-		{ "negation",		"Matrix negation tests",						OP_NEGATION,		false,	false	},
-		{ "pre_increment",	"Matrix prefix increment tests",				OP_PRE_INCREMENT,	false,	false	},
-		{ "pre_decrement",	"Matrix prefix decrement tests",				OP_PRE_DECREMENT,	false,	false	},
-		{ "post_increment",	"Matrix postfix increment tests",				OP_POST_INCREMENT,	false,	false	},
-		{ "post_decrement",	"Matrix postfix decrement tests",				OP_POST_DECREMENT,	false,	false	},
-		{ "add_assign",		"Matrix add into tests",						OP_ADD_INTO,		false,	false	},
-		{ "sub_assign",		"Matrix subtract from tests",					OP_SUBTRACT_FROM,	false,	false	},
-		{ "mul_assign",		"Matrix multiply into tests",					OP_MULTIPLY_INTO,	false,	false	},
-		{ "div_assign",		"Matrix divide into tests",						OP_DIVIDE_INTO,		false,	false	},
-	};
-
-	struct InputTypeSpec
-	{
-		const char*		name;
-		const char*		desc;
-		InputType		type;
-	};
-	static const InputTypeSpec extendedInputTypes[] =
-	{
-		{ "const",		"Constant matrix input",	INPUTTYPE_CONST		},
-		{ "uniform",	"Uniform matrix input",		INPUTTYPE_UNIFORM	},
-		{ "dynamic",	"Dynamic matrix input",		INPUTTYPE_DYNAMIC	}
-	};
-	static const InputTypeSpec reducedInputTypes[] =
-	{
-		{ "dynamic",	"Dynamic matrix input",		INPUTTYPE_DYNAMIC	}
-	};
-
-	static const DataType matrixTypes[] =
-	{
-		TYPE_FLOAT_MAT2,
-		TYPE_FLOAT_MAT2X3,
-		TYPE_FLOAT_MAT2X4,
-		TYPE_FLOAT_MAT3X2,
-		TYPE_FLOAT_MAT3,
-		TYPE_FLOAT_MAT3X4,
-		TYPE_FLOAT_MAT4X2,
-		TYPE_FLOAT_MAT4X3,
-		TYPE_FLOAT_MAT4
-	};
-
-	static const Precision precisions[] =
-	{
-		PRECISION_LOWP,
-		PRECISION_MEDIUMP,
-		PRECISION_HIGHP
-	};
-
-	for (int opNdx = 0; opNdx < DE_LENGTH_OF_ARRAY(ops); opNdx++)
-	{
-		const InputTypeSpec*	inTypeList		= (ops[opNdx].extendedInputTypeCases) ? (extendedInputTypes) : (reducedInputTypes);
-		const int				inTypeListSize	= (ops[opNdx].extendedInputTypeCases) ? (DE_LENGTH_OF_ARRAY(extendedInputTypes)) : (DE_LENGTH_OF_ARRAY(reducedInputTypes));
-		const MatrixOp			op				= ops[opNdx].op;
-		tcu::TestCaseGroup*		opGroup			= new tcu::TestCaseGroup(m_testCtx, ops[opNdx].name, ops[opNdx].desc);
-
-		addChild(opGroup);
-
-		for (int inTypeNdx = 0; inTypeNdx < inTypeListSize; inTypeNdx++)
-		{
-			const InputType		inputType	= inTypeList[inTypeNdx].type;
-			tcu::TestCaseGroup* inGroup;
-
-			if (ops[opNdx].createInputTypeGroup)
-			{
-				inGroup = new tcu::TestCaseGroup(m_testCtx, inTypeList[inTypeNdx].name, inTypeList[inTypeNdx].desc);
-				opGroup->addChild(inGroup);
-			}
-			else
-				inGroup = opGroup;
-
-			for (int matTypeNdx = 0; matTypeNdx < DE_LENGTH_OF_ARRAY(matrixTypes); matTypeNdx++)
-			{
-				DataType	matType		= matrixTypes[matTypeNdx];
-				int			numCols		= getDataTypeMatrixNumColumns(matType);
-				int			numRows		= getDataTypeMatrixNumRows(matType);
-				const char*	matTypeName	= getDataTypeName(matType);
-
-				for (int precNdx = 0; precNdx < DE_LENGTH_OF_ARRAY(precisions); precNdx++)
-				{
-					Precision	precision	= precisions[precNdx];
-					const char*	precName	= getPrecisionName(precision);
-					string		baseName	= string(precName) + "_" + matTypeName + "_";
-					ShaderInput	matIn		(inputType, matType, precision);
-
-					if (isOperationMatrixScalar(op))
-					{
-						// Matrix-scalar \note For div cases we use uniform input.
-						ShaderInput scalarIn(op == OP_DIV ? INPUTTYPE_UNIFORM : INPUTTYPE_DYNAMIC, TYPE_FLOAT, precision);
-						inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_vertex").c_str(),		"Matrix-scalar case", matIn, scalarIn, op, true));
-						inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_fragment").c_str(),	"Matrix-scalar case", matIn, scalarIn, op, false));
-					}
-
-					if (isOperationMatrixVector(op))
-					{
-						// Matrix-vector.
-						DataType	colVecType	= getDataTypeFloatVec(numCols);
-						ShaderInput colVecIn	(op == OP_DIV ? INPUTTYPE_UNIFORM : INPUTTYPE_DYNAMIC, colVecType, precision);
-
-						inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + getDataTypeName(colVecType) + "_vertex").c_str(),		"Matrix-vector case", matIn, colVecIn, op, true));
-						inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + getDataTypeName(colVecType) + "_fragment").c_str(),	"Matrix-vector case", matIn, colVecIn, op, false));
-
-						// Vector-matrix.
-						DataType	rowVecType	= getDataTypeFloatVec(numRows);
-						ShaderInput	rowVecIn	(op == OP_DIV ? INPUTTYPE_UNIFORM : INPUTTYPE_DYNAMIC, rowVecType, precision);
-						string		vecMatName	= string(precName) + "_" + getDataTypeName(rowVecType) + "_" + matTypeName;
-
-						inGroup->addChild(new ShaderMatrixCase(m_context, (vecMatName + "_vertex").c_str(),		"Vector-matrix case", rowVecIn, matIn, op, true));
-						inGroup->addChild(new ShaderMatrixCase(m_context, (vecMatName + "_fragment").c_str(),	"Vector-matrix case", rowVecIn, matIn, op, false));
-					}
-
-					if (isOperationArithmeticMatrixMatrix(op))
-					{
-						// Arithmetic matrix-matrix multiplication.
-						for (int otherCols = 2; otherCols <= 4; otherCols++)
-						{
-							ShaderInput otherMatIn(inputType == INPUTTYPE_DYNAMIC ? INPUTTYPE_UNIFORM : inputType, getDataTypeMatrix(otherCols, numCols /* rows */), precision);
-							inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + getDataTypeName(otherMatIn.dataType) + "_vertex").c_str(),	"Matrix-matrix case", matIn, otherMatIn, op, true));
-							inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + getDataTypeName(otherMatIn.dataType) + "_fragment").c_str(),	"Matrix-matrix case", matIn, otherMatIn, op, false));
-						}
-					}
-					else if (isOperationComponentwiseMatrixMatrix(op))
-					{
-						// Component-wise.
-						ShaderInput otherMatIn(inputType == INPUTTYPE_DYNAMIC ? INPUTTYPE_UNIFORM : inputType, matType, precision);
-						inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + matTypeName + "_vertex").c_str(),		"Matrix-matrix case", matIn, otherMatIn, op, true));
-						inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + matTypeName + "_fragment").c_str(),	"Matrix-matrix case", matIn, otherMatIn, op, false));
-					}
-
-					if (isOperationVectorVector(op))
-					{
-						ShaderInput vec1In(inputType,																getDataTypeFloatVec(numRows), precision);
-						ShaderInput vec2In((inputType == INPUTTYPE_DYNAMIC) ? (INPUTTYPE_UNIFORM) : (inputType),	getDataTypeFloatVec(numCols), precision);
-
-						inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_vertex").c_str(),		"Vector-vector case", vec1In, vec2In, op, true));
-						inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_fragment").c_str(),	"Vector-vector case", vec1In, vec2In, op, false));
-					}
-
-					if ((isOperationUnaryAnyMatrix(op)) ||
-						(isOperationUnarySymmetricMatrix(op) && numCols == numRows))
-					{
-						ShaderInput voidInput(INPUTTYPE_LAST, TYPE_LAST, PRECISION_LAST);
-						inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_vertex").c_str(),		"Matrix case", matIn, voidInput, op, true));
-						inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_fragment").c_str(),	"Matrix case", matIn, voidInput, op, false));
-					}
-
-					if ((isOperationAssignmentAnyMatrix(op)) ||
-						(isOperationAssignmentSymmetricMatrix(op) && numCols == numRows))
-					{
-						ShaderInput otherMatIn(inputType == INPUTTYPE_DYNAMIC ? INPUTTYPE_UNIFORM : inputType, matType, precision);
-						inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_vertex").c_str(),		"Matrix assignment case", matIn, otherMatIn, op, true));
-						inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_fragment").c_str(),	"Matrix assignment case", matIn, otherMatIn, op, false));
-					}
-				}
-			}
-		}
-	}
+    static const struct
+    {
+        const char*     name;
+        const char*     desc;
+        MatrixOp        op;
+        bool            extendedInputTypeCases; // !< test with const and uniform types too
+        bool            createInputTypeGroup;   // !< create group for input types
+    } ops[] =
+    {
+        { "add",            "Matrix addition tests",                        OP_ADD,             true,   true    },
+        { "sub",            "Matrix subtraction tests",                     OP_SUB,             true,   true    },
+        { "mul",            "Matrix multiplication tests",                  OP_MUL,             true,   true    },
+        { "div",            "Matrix division tests",                        OP_DIV,             true,   true    },
+        { "matrixcompmult", "Matrix component-wise multiplication tests",   OP_COMP_MUL,        false,  true    },
+        { "outerproduct",   "Matrix outerProduct() tests",                  OP_OUTER_PRODUCT,   false,  true    },
+        { "transpose",      "Matrix transpose() tests",                     OP_TRANSPOSE,       false,  true    },
+        { "determinant",    "Matrix determinant() tests",                   OP_DETERMINANT,     false,  true    },
+        { "inverse",        "Matrix inverse() tests",                       OP_INVERSE,         false,  true    },
+        { "unary_addition", "Matrix unary addition tests",                  OP_UNARY_PLUS,      false,  false   },
+        { "negation",       "Matrix negation tests",                        OP_NEGATION,        false,  false   },
+        { "pre_increment",  "Matrix prefix increment tests",                OP_PRE_INCREMENT,   false,  false   },
+        { "pre_decrement",  "Matrix prefix decrement tests",                OP_PRE_DECREMENT,   false,  false   },
+        { "post_increment", "Matrix postfix increment tests",               OP_POST_INCREMENT,  false,  false   },
+        { "post_decrement", "Matrix postfix decrement tests",               OP_POST_DECREMENT,  false,  false   },
+        { "add_assign",     "Matrix add into tests",                        OP_ADD_INTO,        false,  false   },
+        { "sub_assign",     "Matrix subtract from tests",                   OP_SUBTRACT_FROM,   false,  false   },
+        { "mul_assign",     "Matrix multiply into tests",                   OP_MULTIPLY_INTO,   false,  false   },
+        { "div_assign",     "Matrix divide into tests",                     OP_DIVIDE_INTO,     false,  false   },
+    };
+
+    struct InputTypeSpec
+    {
+        const char*     name;
+        const char*     desc;
+        InputType       type;
+    };
+    static const InputTypeSpec extendedInputTypes[] =
+    {
+        { "const",      "Constant matrix input",    INPUTTYPE_CONST     },
+        { "uniform",    "Uniform matrix input",     INPUTTYPE_UNIFORM   },
+        { "dynamic",    "Dynamic matrix input",     INPUTTYPE_DYNAMIC   }
+    };
+    static const InputTypeSpec reducedInputTypes[] =
+    {
+        { "dynamic",    "Dynamic matrix input",     INPUTTYPE_DYNAMIC   }
+    };
+
+    static const DataType matrixTypes[] =
+    {
+        TYPE_FLOAT_MAT2,
+        TYPE_FLOAT_MAT2X3,
+        TYPE_FLOAT_MAT2X4,
+        TYPE_FLOAT_MAT3X2,
+        TYPE_FLOAT_MAT3,
+        TYPE_FLOAT_MAT3X4,
+        TYPE_FLOAT_MAT4X2,
+        TYPE_FLOAT_MAT4X3,
+        TYPE_FLOAT_MAT4
+    };
+
+    static const Precision precisions[] =
+    {
+        PRECISION_LOWP,
+        PRECISION_MEDIUMP,
+        PRECISION_HIGHP
+    };
+
+    for (int opNdx = 0; opNdx < DE_LENGTH_OF_ARRAY(ops); opNdx++)
+    {
+        const InputTypeSpec*    inTypeList      = (ops[opNdx].extendedInputTypeCases) ? (extendedInputTypes) : (reducedInputTypes);
+        const int               inTypeListSize  = (ops[opNdx].extendedInputTypeCases) ? (DE_LENGTH_OF_ARRAY(extendedInputTypes)) : (DE_LENGTH_OF_ARRAY(reducedInputTypes));
+        const MatrixOp          op              = ops[opNdx].op;
+        tcu::TestCaseGroup*     opGroup         = new tcu::TestCaseGroup(m_testCtx, ops[opNdx].name, ops[opNdx].desc);
+
+        addChild(opGroup);
+
+        for (int inTypeNdx = 0; inTypeNdx < inTypeListSize; inTypeNdx++)
+        {
+            const InputType     inputType   = inTypeList[inTypeNdx].type;
+            tcu::TestCaseGroup* inGroup;
+
+            if (ops[opNdx].createInputTypeGroup)
+            {
+                inGroup = new tcu::TestCaseGroup(m_testCtx, inTypeList[inTypeNdx].name, inTypeList[inTypeNdx].desc);
+                opGroup->addChild(inGroup);
+            }
+            else
+                inGroup = opGroup;
+
+            for (int matTypeNdx = 0; matTypeNdx < DE_LENGTH_OF_ARRAY(matrixTypes); matTypeNdx++)
+            {
+                DataType    matType     = matrixTypes[matTypeNdx];
+                int         numCols     = getDataTypeMatrixNumColumns(matType);
+                int         numRows     = getDataTypeMatrixNumRows(matType);
+                const char* matTypeName = getDataTypeName(matType);
+
+                for (int precNdx = 0; precNdx < DE_LENGTH_OF_ARRAY(precisions); precNdx++)
+                {
+                    Precision   precision   = precisions[precNdx];
+                    const char* precName    = getPrecisionName(precision);
+                    string      baseName    = string(precName) + "_" + matTypeName + "_";
+                    ShaderInput matIn       (inputType, matType, precision);
+
+                    if (isOperationMatrixScalar(op))
+                    {
+                        // Matrix-scalar \note For div cases we use uniform input.
+                        ShaderInput scalarIn(op == OP_DIV ? INPUTTYPE_UNIFORM : INPUTTYPE_DYNAMIC, TYPE_FLOAT, precision);
+                        inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_vertex").c_str(),      "Matrix-scalar case", matIn, scalarIn, op, true));
+                        inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_fragment").c_str(),    "Matrix-scalar case", matIn, scalarIn, op, false));
+                    }
+
+                    if (isOperationMatrixVector(op))
+                    {
+                        // Matrix-vector.
+                        DataType    colVecType  = getDataTypeFloatVec(numCols);
+                        ShaderInput colVecIn    (op == OP_DIV ? INPUTTYPE_UNIFORM : INPUTTYPE_DYNAMIC, colVecType, precision);
+
+                        inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + getDataTypeName(colVecType) + "_vertex").c_str(),     "Matrix-vector case", matIn, colVecIn, op, true));
+                        inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + getDataTypeName(colVecType) + "_fragment").c_str(),   "Matrix-vector case", matIn, colVecIn, op, false));
+
+                        // Vector-matrix.
+                        DataType    rowVecType  = getDataTypeFloatVec(numRows);
+                        ShaderInput rowVecIn    (op == OP_DIV ? INPUTTYPE_UNIFORM : INPUTTYPE_DYNAMIC, rowVecType, precision);
+                        string      vecMatName  = string(precName) + "_" + getDataTypeName(rowVecType) + "_" + matTypeName;
+
+                        inGroup->addChild(new ShaderMatrixCase(m_context, (vecMatName + "_vertex").c_str(),     "Vector-matrix case", rowVecIn, matIn, op, true));
+                        inGroup->addChild(new ShaderMatrixCase(m_context, (vecMatName + "_fragment").c_str(),   "Vector-matrix case", rowVecIn, matIn, op, false));
+                    }
+
+                    if (isOperationArithmeticMatrixMatrix(op))
+                    {
+                        // Arithmetic matrix-matrix multiplication.
+                        for (int otherCols = 2; otherCols <= 4; otherCols++)
+                        {
+                            ShaderInput otherMatIn(inputType == INPUTTYPE_DYNAMIC ? INPUTTYPE_UNIFORM : inputType, getDataTypeMatrix(otherCols, numCols /* rows */), precision);
+                            inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + getDataTypeName(otherMatIn.dataType) + "_vertex").c_str(),    "Matrix-matrix case", matIn, otherMatIn, op, true));
+                            inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + getDataTypeName(otherMatIn.dataType) + "_fragment").c_str(),  "Matrix-matrix case", matIn, otherMatIn, op, false));
+                        }
+                    }
+                    else if (isOperationComponentwiseMatrixMatrix(op))
+                    {
+                        // Component-wise.
+                        ShaderInput otherMatIn(inputType == INPUTTYPE_DYNAMIC ? INPUTTYPE_UNIFORM : inputType, matType, precision);
+                        inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + matTypeName + "_vertex").c_str(),     "Matrix-matrix case", matIn, otherMatIn, op, true));
+                        inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + matTypeName + "_fragment").c_str(),   "Matrix-matrix case", matIn, otherMatIn, op, false));
+                    }
+
+                    if (isOperationVectorVector(op))
+                    {
+                        ShaderInput vec1In(inputType,                                                               getDataTypeFloatVec(numRows), precision);
+                        ShaderInput vec2In((inputType == INPUTTYPE_DYNAMIC) ? (INPUTTYPE_UNIFORM) : (inputType),    getDataTypeFloatVec(numCols), precision);
+
+                        inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_vertex").c_str(),      "Vector-vector case", vec1In, vec2In, op, true));
+                        inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_fragment").c_str(),    "Vector-vector case", vec1In, vec2In, op, false));
+                    }
+
+                    if ((isOperationUnaryAnyMatrix(op)) ||
+                        (isOperationUnarySymmetricMatrix(op) && numCols == numRows))
+                    {
+                        ShaderInput voidInput(INPUTTYPE_LAST, TYPE_LAST, PRECISION_LAST);
+                        inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_vertex").c_str(),      "Matrix case", matIn, voidInput, op, true));
+                        inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_fragment").c_str(),    "Matrix case", matIn, voidInput, op, false));
+                    }
+
+                    if ((isOperationAssignmentAnyMatrix(op)) ||
+                        (isOperationAssignmentSymmetricMatrix(op) && numCols == numRows))
+                    {
+                        ShaderInput otherMatIn(inputType == INPUTTYPE_DYNAMIC ? INPUTTYPE_UNIFORM : inputType, matType, precision);
+                        inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_vertex").c_str(),      "Matrix assignment case", matIn, otherMatIn, op, true));
+                        inGroup->addChild(new ShaderMatrixCase(m_context, (baseName + "float_fragment").c_str(),    "Matrix assignment case", matIn, otherMatIn, op, false));
+                    }
+                }
+            }
+        }
+    }
 }
 
 } // Functional
diff --git a/src/tests/deqp_support/qpTestLog.c b/src/tests/deqp_support/qpTestLog.c
index 7252ae049..e3eaa9b14 100644
--- a/src/tests/deqp_support/qpTestLog.c
+++ b/src/tests/deqp_support/qpTestLog.c
@@ -33,7 +33,7 @@
 #include "deMutex.h"
 
 #if defined(QP_SUPPORT_PNG)
-#	include <png.h>
+#   include <png.h>
 #endif
 
 #include <stdio.h>
@@ -41,8 +41,8 @@
 #include <stdarg.h>
 
 #if (DE_OS == DE_OS_WIN32)
-#	include <windows.h>
-#	include <io.h>
+#   include <windows.h>
+#   include <io.h>
 #endif
 
 #if defined(DE_DEBUG)
@@ -51,70 +51,70 @@
 
 typedef enum ContainerType_e
 {
-	CONTAINERTYPE_SECTION = 0,
-	CONTAINERTYPE_IMAGESET,
-	CONTAINERTYPE_EGLCONFIGSET,
-	CONTAINERTYPE_SHADERPROGRAM,
-	CONTAINERTYPE_SAMPLELIST,
-	CONTAINERTYPE_SAMPLEINFO,
-	CONTAINERTYPE_SAMPLE,
+    CONTAINERTYPE_SECTION = 0,
+    CONTAINERTYPE_IMAGESET,
+    CONTAINERTYPE_EGLCONFIGSET,
+    CONTAINERTYPE_SHADERPROGRAM,
+    CONTAINERTYPE_SAMPLELIST,
+    CONTAINERTYPE_SAMPLEINFO,
+    CONTAINERTYPE_SAMPLE,
 
-	CONTAINERTYPE_LAST
+    CONTAINERTYPE_LAST
 } ContainerType;
 
 DE_INLINE deBool childContainersOk (ContainerType type)
 {
-	return type == CONTAINERTYPE_SECTION || type == CONTAINERTYPE_SAMPLELIST;
+    return type == CONTAINERTYPE_SECTION || type == CONTAINERTYPE_SAMPLELIST;
 }
 
 enum
 {
-	MAX_CONTAINER_STACK_DEPTH		= 32
+    MAX_CONTAINER_STACK_DEPTH       = 32
 };
 
 typedef struct ContainerStack_s
 {
-	int				numElements;
-	ContainerType	elements[MAX_CONTAINER_STACK_DEPTH];
+    int             numElements;
+    ContainerType   elements[MAX_CONTAINER_STACK_DEPTH];
 } ContainerStack;
 
 DE_INLINE void ContainerStack_reset (ContainerStack* stack)
 {
-	deMemset(stack, 0, sizeof(ContainerStack));
+    deMemset(stack, 0, sizeof(ContainerStack));
 }
 
 DE_INLINE deBool ContainerStack_isEmpty (const ContainerStack* stack)
 {
-	return stack->numElements == 0;
+    return stack->numElements == 0;
 }
 
 DE_INLINE deBool ContainerStack_push (ContainerStack* stack, ContainerType type)
 {
-	if (stack->numElements == MAX_CONTAINER_STACK_DEPTH)
-		return DE_FALSE;
+    if (stack->numElements == MAX_CONTAINER_STACK_DEPTH)
+        return DE_FALSE;
 
-	if (stack->numElements > 0 && !childContainersOk(stack->elements[stack->numElements-1]))
-		return DE_FALSE;
+    if (stack->numElements > 0 && !childContainersOk(stack->elements[stack->numElements-1]))
+        return DE_FALSE;
 
-	stack->elements[stack->numElements]  = type;
-	stack->numElements					+= 1;
+    stack->elements[stack->numElements]  = type;
+    stack->numElements                  += 1;
 
-	return DE_TRUE;
+    return DE_TRUE;
 }
 
 DE_INLINE ContainerType ContainerStack_pop (ContainerStack* stack)
 {
-	DE_ASSERT(stack->numElements > 0);
-	stack->numElements -= 1;
-	return stack->elements[stack->numElements];
+    DE_ASSERT(stack->numElements > 0);
+    stack->numElements -= 1;
+    return stack->elements[stack->numElements];
 }
 
 DE_INLINE ContainerType ContainerStack_getTop (const ContainerStack* stack)
 {
-	if (stack->numElements > 0)
-		return stack->elements[stack->numElements-1];
-	else
-		return CONTAINERTYPE_LAST;
+    if (stack->numElements > 0)
+        return stack->elements[stack->numElements-1];
+    else
+        return CONTAINERTYPE_LAST;
 }
 
 #endif
@@ -122,26 +122,26 @@ DE_INLINE ContainerType ContainerStack_getTop (const ContainerStack* stack)
 /* qpTestLog instance */
 struct qpTestLog_s
 {
-	deUint32				flags;				/*!< Logging flags.						*/
+    deUint32                flags;              /*!< Logging flags.                     */
 
-	deMutex					lock;				/*!< Lock for mutable state below.		*/
+    deMutex                 lock;               /*!< Lock for mutable state below.      */
 
-	/* State protected by lock. */
-	FILE*					outputFile;
-	qpXmlWriter*			writer;
-	deBool					isSessionOpen;
-	deBool					isCaseOpen;
+    /* State protected by lock. */
+    FILE*                   outputFile;
+    qpXmlWriter*            writer;
+    deBool                  isSessionOpen;
+    deBool                  isCaseOpen;
 
 #if defined(DE_DEBUG)
-	ContainerStack			containerStack;		/*!< For container usage verification.	*/
+    ContainerStack          containerStack;     /*!< For container usage verification.  */
 #endif
 };
 
 /* Maps integer to string. */
 typedef struct qpKeyStringMap_s
 {
-	int		key;
-	char*	string;
+    int     key;
+    char*   string;
 } qpKeyStringMap;
 
 static const char* LOG_FORMAT_VERSION = "0.3.4";
@@ -149,32 +149,32 @@ static const char* LOG_FORMAT_VERSION = "0.3.4";
 /* Mapping enum to above strings... */
 static const qpKeyStringMap s_qpTestTypeMap[] =
 {
-	{ QP_TEST_CASE_TYPE_SELF_VALIDATE,		"SelfValidate"	},
-	{ QP_TEST_CASE_TYPE_PERFORMANCE,		"Performance"	},
-	{ QP_TEST_CASE_TYPE_CAPABILITY,			"Capability"	},
-	{ QP_TEST_CASE_TYPE_ACCURACY,			"Accuracy"		},
+    { QP_TEST_CASE_TYPE_SELF_VALIDATE,      "SelfValidate"  },
+    { QP_TEST_CASE_TYPE_PERFORMANCE,        "Performance"   },
+    { QP_TEST_CASE_TYPE_CAPABILITY,         "Capability"    },
+    { QP_TEST_CASE_TYPE_ACCURACY,           "Accuracy"      },
 
-	{ QP_TEST_CASE_TYPE_LAST,				DE_NULL			}
+    { QP_TEST_CASE_TYPE_LAST,               DE_NULL         }
 };
 
 DE_STATIC_ASSERT(DE_LENGTH_OF_ARRAY(s_qpTestTypeMap) == QP_TEST_CASE_TYPE_LAST + 1);
 
 static const qpKeyStringMap s_qpTestResultMap[] =
 {
-	{ QP_TEST_RESULT_PASS,						"Pass"					},
-	{ QP_TEST_RESULT_FAIL,						"Fail"					},
-	{ QP_TEST_RESULT_QUALITY_WARNING,			"QualityWarning"		},
-	{ QP_TEST_RESULT_COMPATIBILITY_WARNING,		"CompatibilityWarning"	},
-	{ QP_TEST_RESULT_PENDING,					"Pending"				},	/* should not be needed here */
-	{ QP_TEST_RESULT_NOT_SUPPORTED,				"NotSupported"			},
-	{ QP_TEST_RESULT_RESOURCE_ERROR,			"ResourceError"			},
-	{ QP_TEST_RESULT_INTERNAL_ERROR,			"InternalError"			},
-	{ QP_TEST_RESULT_CRASH,						"Crash"					},
-	{ QP_TEST_RESULT_TIMEOUT,					"Timeout"				},
+    { QP_TEST_RESULT_PASS,                      "Pass"                  },
+    { QP_TEST_RESULT_FAIL,                      "Fail"                  },
+    { QP_TEST_RESULT_QUALITY_WARNING,           "QualityWarning"        },
+    { QP_TEST_RESULT_COMPATIBILITY_WARNING,     "CompatibilityWarning"  },
+    { QP_TEST_RESULT_PENDING,                   "Pending"               },  /* should not be needed here */
+    { QP_TEST_RESULT_NOT_SUPPORTED,             "NotSupported"          },
+    { QP_TEST_RESULT_RESOURCE_ERROR,            "ResourceError"         },
+    { QP_TEST_RESULT_INTERNAL_ERROR,            "InternalError"         },
+    { QP_TEST_RESULT_CRASH,                     "Crash"                 },
+    { QP_TEST_RESULT_TIMEOUT,                   "Timeout"               },
 
-	/* Add new values here if needed, remember to update qpTestResult enumeration. */
+    /* Add new values here if needed, remember to update qpTestResult enumeration. */
 
-	{ QP_TEST_RESULT_LAST,						DE_NULL					}
+    { QP_TEST_RESULT_LAST,                      DE_NULL                 }
 };
 
 DE_STATIC_ASSERT(DE_LENGTH_OF_ARRAY(s_qpTestResultMap) == QP_TEST_RESULT_LAST + 1);
@@ -183,13 +183,13 @@ DE_STATIC_ASSERT(DE_LENGTH_OF_ARRAY(s_qpTestResultMap) == QP_TEST_RESULT_LAST +
 
 static const qpKeyStringMap s_qpTagMap[] =
 {
-	{ QP_KEY_TAG_NONE,			DE_NULL			},
-	{ QP_KEY_TAG_PERFORMANCE,	"Performance"	},
-	{ QP_KEY_TAG_QUALITY,		"Quality"		},
-	{ QP_KEY_TAG_PRECISION,		"Precision"		},
-	{ QP_KEY_TAG_TIME,			"Time"			},
+    { QP_KEY_TAG_NONE,          DE_NULL         },
+    { QP_KEY_TAG_PERFORMANCE,   "Performance"   },
+    { QP_KEY_TAG_QUALITY,       "Quality"       },
+    { QP_KEY_TAG_PRECISION,     "Precision"     },
+    { QP_KEY_TAG_TIME,          "Time"          },
 
-	{ QP_KEY_TAG_LAST,			DE_NULL			}
+    { QP_KEY_TAG_LAST,          DE_NULL         }
 };
 
 DE_STATIC_ASSERT(DE_LENGTH_OF_ARRAY(s_qpTagMap) == QP_KEY_TAG_LAST + 1);
@@ -198,10 +198,10 @@ DE_STATIC_ASSERT(DE_LENGTH_OF_ARRAY(s_qpTagMap) == QP_KEY_TAG_LAST + 1);
 
 static const qpKeyStringMap s_qpSampleValueTagMap[] =
 {
-	{ QP_SAMPLE_VALUE_TAG_PREDICTOR,	"Predictor"	},
-	{ QP_SAMPLE_VALUE_TAG_RESPONSE,		"Response"	},
+    { QP_SAMPLE_VALUE_TAG_PREDICTOR,    "Predictor" },
+    { QP_SAMPLE_VALUE_TAG_RESPONSE,     "Response"  },
 
-	{ QP_SAMPLE_VALUE_TAG_LAST,			DE_NULL		}
+    { QP_SAMPLE_VALUE_TAG_LAST,         DE_NULL     }
 };
 
 DE_STATIC_ASSERT(DE_LENGTH_OF_ARRAY(s_qpSampleValueTagMap) == QP_SAMPLE_VALUE_TAG_LAST + 1);
@@ -210,12 +210,12 @@ DE_STATIC_ASSERT(DE_LENGTH_OF_ARRAY(s_qpSampleValueTagMap) == QP_SAMPLE_VALUE_TA
 
 static const qpKeyStringMap s_qpImageCompressionModeMap[] =
 {
-	{ QP_IMAGE_COMPRESSION_MODE_NONE,	"None"	},
-	{ QP_IMAGE_COMPRESSION_MODE_PNG,	"PNG"	},
+    { QP_IMAGE_COMPRESSION_MODE_NONE,   "None"  },
+    { QP_IMAGE_COMPRESSION_MODE_PNG,    "PNG"   },
 
-	{ QP_IMAGE_COMPRESSION_MODE_BEST,	DE_NULL	},	/* not allowed to be written! */
+    { QP_IMAGE_COMPRESSION_MODE_BEST,   DE_NULL },  /* not allowed to be written! */
 
-	{ QP_IMAGE_COMPRESSION_MODE_LAST,	DE_NULL	}
+    { QP_IMAGE_COMPRESSION_MODE_LAST,   DE_NULL }
 };
 
 DE_STATIC_ASSERT(DE_LENGTH_OF_ARRAY(s_qpImageCompressionModeMap) == QP_IMAGE_COMPRESSION_MODE_LAST + 1);
@@ -224,10 +224,10 @@ DE_STATIC_ASSERT(DE_LENGTH_OF_ARRAY(s_qpImageCompressionModeMap) == QP_IMAGE_COM
 
 static const qpKeyStringMap s_qpImageFormatMap[] =
 {
-	{ QP_IMAGE_FORMAT_RGB888,	"RGB888"	},
-	{ QP_IMAGE_FORMAT_RGBA8888,	"RGBA8888"	},
+    { QP_IMAGE_FORMAT_RGB888,   "RGB888"    },
+    { QP_IMAGE_FORMAT_RGBA8888, "RGBA8888"  },
 
-	{ QP_IMAGE_FORMAT_LAST,		DE_NULL		}
+    { QP_IMAGE_FORMAT_LAST,     DE_NULL     }
 };
 
 DE_STATIC_ASSERT(DE_LENGTH_OF_ARRAY(s_qpImageFormatMap) == QP_IMAGE_FORMAT_LAST + 1);
@@ -236,91 +236,91 @@ DE_STATIC_ASSERT(DE_LENGTH_OF_ARRAY(s_qpImageFormatMap) == QP_IMAGE_FORMAT_LAST
 
 static const qpKeyStringMap s_qpShaderTypeMap[] =
 {
-	{ QP_SHADER_TYPE_VERTEX,			"VertexShader"			},
-	{ QP_SHADER_TYPE_FRAGMENT,			"FragmentShader"		},
-	{ QP_SHADER_TYPE_GEOMETRY,			"GeometryShader"		},
-	{ QP_SHADER_TYPE_TESS_CONTROL,		"TessControlShader"		},
-	{ QP_SHADER_TYPE_TESS_EVALUATION,	"TessEvaluationShader"	},
-	{ QP_SHADER_TYPE_COMPUTE,			"ComputeShader"			},
+    { QP_SHADER_TYPE_VERTEX,            "VertexShader"          },
+    { QP_SHADER_TYPE_FRAGMENT,          "FragmentShader"        },
+    { QP_SHADER_TYPE_GEOMETRY,          "GeometryShader"        },
+    { QP_SHADER_TYPE_TESS_CONTROL,      "TessControlShader"     },
+    { QP_SHADER_TYPE_TESS_EVALUATION,   "TessEvaluationShader"  },
+    { QP_SHADER_TYPE_COMPUTE,           "ComputeShader"         },
 
-	{ QP_SHADER_TYPE_LAST,				DE_NULL					}
+    { QP_SHADER_TYPE_LAST,              DE_NULL                 }
 };
 
 DE_STATIC_ASSERT(DE_LENGTH_OF_ARRAY(s_qpShaderTypeMap) == QP_SHADER_TYPE_LAST + 1);
 
 static void qpTestLog_flushFile (qpTestLog* log)
 {
-	DE_ASSERT(log && log->outputFile);
-	fflush(log->outputFile);
+    DE_ASSERT(log && log->outputFile);
+    fflush(log->outputFile);
 #if (DE_OS == DE_OS_WIN32) && (DE_COMPILER == DE_COMPILER_MSC)
-	/* \todo [petri] Is this really necessary? */
-	FlushFileBuffers((HANDLE)_get_osfhandle(_fileno(log->outputFile)));
+    /* \todo [petri] Is this really necessary? */
+    FlushFileBuffers((HANDLE)_get_osfhandle(_fileno(log->outputFile)));
 #endif
 }
 
-#define QP_LOOKUP_STRING(KEYMAP, KEY)	qpLookupString(KEYMAP, DE_LENGTH_OF_ARRAY(KEYMAP), (int)(KEY))
+#define QP_LOOKUP_STRING(KEYMAP, KEY)   qpLookupString(KEYMAP, DE_LENGTH_OF_ARRAY(KEYMAP), (int)(KEY))
 
 static const char* qpLookupString (const qpKeyStringMap* keyMap, int keyMapSize, int key)
 {
-	DE_ASSERT(keyMap);
-	DE_ASSERT(deInBounds32(key, 0, keyMapSize));
-	DE_ASSERT(keyMap[key].key == key);
-	DE_UNREF(keyMapSize); /* for asserting only */
-	return keyMap[key].string;
+    DE_ASSERT(keyMap);
+    DE_ASSERT(deInBounds32(key, 0, keyMapSize));
+    DE_ASSERT(keyMap[key].key == key);
+    DE_UNREF(keyMapSize); /* for asserting only */
+    return keyMap[key].string;
 }
 
 DE_INLINE void int32ToString (int val, char buf[32])
 {
-	deSprintf(&buf[0], 32, "%d", val);
+    deSprintf(&buf[0], 32, "%d", val);
 }
 
 DE_INLINE void int64ToString (deInt64 val, char buf[32])
 {
-	deSprintf(&buf[0], 32, "%lld", (long long int)val);
+    deSprintf(&buf[0], 32, "%lld", (long long int)val);
 }
 
 DE_INLINE void floatToString (float value, char* buf, size_t bufSize)
 {
-	deSprintf(buf, bufSize, "%f", value);
+    deSprintf(buf, bufSize, "%f", value);
 }
 
 DE_INLINE void doubleToString (double value, char* buf, size_t bufSize)
 {
-	deSprintf(buf, bufSize, "%f", value);
+    deSprintf(buf, bufSize, "%f", value);
 }
 
 static deBool beginSession (qpTestLog* log)
 {
-	DE_ASSERT(log && !log->isSessionOpen);
+    DE_ASSERT(log && !log->isSessionOpen);
 
-	/* Write session info. */
-	fprintf(log->outputFile, "#sessionInfo releaseName %s\n", qpGetReleaseName());
-	fprintf(log->outputFile, "#sessionInfo releaseId 0x%08x\n", qpGetReleaseId());
-	fprintf(log->outputFile, "#sessionInfo targetName \"%s\"\n", qpGetTargetName());
+    /* Write session info. */
+    fprintf(log->outputFile, "#sessionInfo releaseName %s\n", qpGetReleaseName());
+    fprintf(log->outputFile, "#sessionInfo releaseId 0x%08x\n", qpGetReleaseId());
+    fprintf(log->outputFile, "#sessionInfo targetName \"%s\"\n", qpGetTargetName());
 
     /* Write out #beginSession. */
-	fprintf(log->outputFile, "#beginSession\n");
-	qpTestLog_flushFile(log);
+    fprintf(log->outputFile, "#beginSession\n");
+    qpTestLog_flushFile(log);
 
-	log->isSessionOpen = DE_TRUE;
+    log->isSessionOpen = DE_TRUE;
 
-	return DE_TRUE;
+    return DE_TRUE;
 }
 
 static deBool endSession (qpTestLog* log)
 {
-	DE_ASSERT(log && log->isSessionOpen);
+    DE_ASSERT(log && log->isSessionOpen);
 
     /* Make sure xml is flushed. */
     qpXmlWriter_flush(log->writer);
 
     /* Write out #endSession. */
-	fprintf(log->outputFile, "\n#endSession\n");
-	qpTestLog_flushFile(log);
+    fprintf(log->outputFile, "\n#endSession\n");
+    qpTestLog_flushFile(log);
 
-	log->isSessionOpen = DE_FALSE;
+    log->isSessionOpen = DE_FALSE;
 
-	return DE_TRUE;
+    return DE_TRUE;
 }
 
 /*--------------------------------------------------------------------*//*!
@@ -330,117 +330,117 @@ static deBool endSession (qpTestLog* log)
  *//*--------------------------------------------------------------------*/
 qpTestLog* qpTestLog_createFileLog (const char* fileName, deUint32 flags)
 {
-	qpTestLog* log = (qpTestLog*)deCalloc(sizeof(qpTestLog));
-	if (!log)
-		return DE_NULL;
+    qpTestLog* log = (qpTestLog*)deCalloc(sizeof(qpTestLog));
+    if (!log)
+        return DE_NULL;
 
-	DE_ASSERT(fileName && fileName[0]); /* must have filename. */
+    DE_ASSERT(fileName && fileName[0]); /* must have filename. */
 
 #if defined(DE_DEBUG)
-	ContainerStack_reset(&log->containerStack);
+    ContainerStack_reset(&log->containerStack);
 #endif
 
-	qpPrintf("Writing test log into %s\n", fileName);
-
-	/* Create output file. */
-	log->outputFile = fopen(fileName, "wb");
-	if (!log->outputFile)
-	{
-		qpPrintf("ERROR: Unable to open test log output file '%s'.\n", fileName);
-		qpTestLog_destroy(log);
-		return DE_NULL;
-	}
-
-	log->flags			= flags;
-	log->writer			= qpXmlWriter_createFileWriter(log->outputFile, 0, !(flags & QP_TEST_LOG_NO_FLUSH));
-	log->lock			= deMutex_create(DE_NULL);
-	log->isSessionOpen	= DE_FALSE;
-	log->isCaseOpen		= DE_FALSE;
-
-	if (!log->writer)
-	{
-		qpPrintf("ERROR: Unable to create output XML writer to file '%s'.\n", fileName);
-		qpTestLog_destroy(log);
-		return DE_NULL;
-	}
-
-	if (!log->lock)
-	{
-		qpPrintf("ERROR: Unable to create mutex.\n");
-		qpTestLog_destroy(log);
-		return DE_NULL;
-	}
-
-	beginSession(log);
-
-	return log;
+    qpPrintf("Writing test log into %s\n", fileName);
+
+    /* Create output file. */
+    log->outputFile = fopen(fileName, "wb");
+    if (!log->outputFile)
+    {
+        qpPrintf("ERROR: Unable to open test log output file '%s'.\n", fileName);
+        qpTestLog_destroy(log);
+        return DE_NULL;
+    }
+
+    log->flags          = flags;
+    log->writer         = qpXmlWriter_createFileWriter(log->outputFile, 0, !(flags & QP_TEST_LOG_NO_FLUSH));
+    log->lock           = deMutex_create(DE_NULL);
+    log->isSessionOpen  = DE_FALSE;
+    log->isCaseOpen     = DE_FALSE;
+
+    if (!log->writer)
+    {
+        qpPrintf("ERROR: Unable to create output XML writer to file '%s'.\n", fileName);
+        qpTestLog_destroy(log);
+        return DE_NULL;
+    }
+
+    if (!log->lock)
+    {
+        qpPrintf("ERROR: Unable to create mutex.\n");
+        qpTestLog_destroy(log);
+        return DE_NULL;
+    }
+
+    beginSession(log);
+
+    return log;
 }
 
 /*--------------------------------------------------------------------*//*!
  * \brief Destroy a logger instance
- * \param a	qpTestLog instance
+ * \param a qpTestLog instance
  *//*--------------------------------------------------------------------*/
 void qpTestLog_destroy (qpTestLog* log)
 {
-	DE_ASSERT(log);
+    DE_ASSERT(log);
 
-	if (log->isSessionOpen)
-		endSession(log);
+    if (log->isSessionOpen)
+        endSession(log);
 
-	if (log->writer)
-		qpXmlWriter_destroy(log->writer);
+    if (log->writer)
+        qpXmlWriter_destroy(log->writer);
 
-	if (log->outputFile)
-		fclose(log->outputFile);
+    if (log->outputFile)
+        fclose(log->outputFile);
 
-	if (log->lock)
-		deMutex_destroy(log->lock);
+    if (log->lock)
+        deMutex_destroy(log->lock);
 
-	deFree(log);
+    deFree(log);
 }
 
 /*--------------------------------------------------------------------*//*!
  * \brief Log start of test case
  * \param log qpTestLog instance
- * \param testCasePath	Full test case path (as seen in Candy).
- * \param testCaseType	Test case type
+ * \param testCasePath  Full test case path (as seen in Candy).
+ * \param testCaseType  Test case type
  * \return true if ok, false otherwise
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_startCase (qpTestLog* log, const char* testCasePath, qpTestCaseType testCaseType)
 {
-	const char*		typeStr				= QP_LOOKUP_STRING(s_qpTestTypeMap, testCaseType);
-	int				numResultAttribs	= 0;
-	qpXmlAttribute	resultAttribs[8];
+    const char*     typeStr             = QP_LOOKUP_STRING(s_qpTestTypeMap, testCaseType);
+    int             numResultAttribs    = 0;
+    qpXmlAttribute  resultAttribs[8];
 
-	DE_ASSERT(log && testCasePath && (testCasePath[0] != 0));
-	deMutex_lock(log->lock);
+    DE_ASSERT(log && testCasePath && (testCasePath[0] != 0));
+    deMutex_lock(log->lock);
 
-	DE_ASSERT(!log->isCaseOpen);
-	DE_ASSERT(ContainerStack_isEmpty(&log->containerStack));
+    DE_ASSERT(!log->isCaseOpen);
+    DE_ASSERT(ContainerStack_isEmpty(&log->containerStack));
 
-	/* Flush XML and write out #beginTestCaseResult. */
-	qpXmlWriter_flush(log->writer);
-	fprintf(log->outputFile, "\n#beginTestCaseResult %s\n", testCasePath);
-	if (!(log->flags & QP_TEST_LOG_NO_FLUSH))
-		qpTestLog_flushFile(log);
-
-	log->isCaseOpen = DE_TRUE;
-
-	/* Fill in attributes. */
-	resultAttribs[numResultAttribs++] = qpSetStringAttrib("Version", LOG_FORMAT_VERSION);
-	resultAttribs[numResultAttribs++] = qpSetStringAttrib("CasePath", testCasePath);
-	resultAttribs[numResultAttribs++] = qpSetStringAttrib("CaseType", typeStr);
-
-	if (!qpXmlWriter_startDocument(log->writer) ||
-		!qpXmlWriter_startElement(log->writer, "TestCaseResult", numResultAttribs, resultAttribs))
-	{
-		qpPrintf("qpTestLog_startCase(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
-
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    /* Flush XML and write out #beginTestCaseResult. */
+    qpXmlWriter_flush(log->writer);
+    fprintf(log->outputFile, "\n#beginTestCaseResult %s\n", testCasePath);
+    if (!(log->flags & QP_TEST_LOG_NO_FLUSH))
+        qpTestLog_flushFile(log);
+
+    log->isCaseOpen = DE_TRUE;
+
+    /* Fill in attributes. */
+    resultAttribs[numResultAttribs++] = qpSetStringAttrib("Version", LOG_FORMAT_VERSION);
+    resultAttribs[numResultAttribs++] = qpSetStringAttrib("CasePath", testCasePath);
+    resultAttribs[numResultAttribs++] = qpSetStringAttrib("CaseType", typeStr);
+
+    if (!qpXmlWriter_startDocument(log->writer) ||
+        !qpXmlWriter_startElement(log->writer, "TestCaseResult", numResultAttribs, resultAttribs))
+    {
+        qpPrintf("qpTestLog_startCase(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
+
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 /*--------------------------------------------------------------------*//*!
@@ -452,600 +452,600 @@ deBool qpTestLog_startCase (qpTestLog* log, const char* testCasePath, qpTestCase
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_endCase (qpTestLog* log, qpTestResult result, const char* resultDetails)
 {
-	const char*		statusStr		= QP_LOOKUP_STRING(s_qpTestResultMap, result);
-	qpXmlAttribute	statusAttrib	= qpSetStringAttrib("StatusCode", statusStr);
-
-	deMutex_lock(log->lock);
-
-	DE_ASSERT(log->isCaseOpen);
-	DE_ASSERT(ContainerStack_isEmpty(&log->containerStack));
-
-	/* <Result StatusCode="Pass">Result details</Result>
-	 * </TestCaseResult>
-	 */
-	if (!qpXmlWriter_startElement(log->writer, "Result", 1, &statusAttrib) ||
-		(resultDetails && !qpXmlWriter_writeString(log->writer, resultDetails)) ||
-		!qpXmlWriter_endElement(log->writer, "Result") ||
-		!qpXmlWriter_endElement(log->writer, "TestCaseResult") ||
-		!qpXmlWriter_endDocument(log->writer))		/* Close any XML elements still open */
-	{
-		qpPrintf("qpTestLog_endCase(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
-
-	/* Flush XML and write #endTestCaseResult. */
-	qpXmlWriter_flush(log->writer);
-	fprintf(log->outputFile, "\n#endTestCaseResult\n");
-	if (!(log->flags & QP_TEST_LOG_NO_FLUSH))
-		qpTestLog_flushFile(log);
-
-	log->isCaseOpen = DE_FALSE;
-
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    const char*     statusStr       = QP_LOOKUP_STRING(s_qpTestResultMap, result);
+    qpXmlAttribute  statusAttrib    = qpSetStringAttrib("StatusCode", statusStr);
+
+    deMutex_lock(log->lock);
+
+    DE_ASSERT(log->isCaseOpen);
+    DE_ASSERT(ContainerStack_isEmpty(&log->containerStack));
+
+    /* <Result StatusCode="Pass">Result details</Result>
+     * </TestCaseResult>
+     */
+    if (!qpXmlWriter_startElement(log->writer, "Result", 1, &statusAttrib) ||
+        (resultDetails && !qpXmlWriter_writeString(log->writer, resultDetails)) ||
+        !qpXmlWriter_endElement(log->writer, "Result") ||
+        !qpXmlWriter_endElement(log->writer, "TestCaseResult") ||
+        !qpXmlWriter_endDocument(log->writer))      /* Close any XML elements still open */
+    {
+        qpPrintf("qpTestLog_endCase(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
+
+    /* Flush XML and write #endTestCaseResult. */
+    qpXmlWriter_flush(log->writer);
+    fprintf(log->outputFile, "\n#endTestCaseResult\n");
+    if (!(log->flags & QP_TEST_LOG_NO_FLUSH))
+        qpTestLog_flushFile(log);
+
+    log->isCaseOpen = DE_FALSE;
+
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 /*--------------------------------------------------------------------*//*!
  * \brief Abrupt termination of logging.
- * \param log		qpTestLog instance
- * \param result	Result code, only Crash and Timeout are allowed.
+ * \param log       qpTestLog instance
+ * \param result    Result code, only Crash and Timeout are allowed.
  * \return true if ok, false otherwise
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_terminateCase (qpTestLog* log, qpTestResult result)
 {
-	const char* resultStr = QP_LOOKUP_STRING(s_qpTestResultMap, result);
+    const char* resultStr = QP_LOOKUP_STRING(s_qpTestResultMap, result);
 
-	DE_ASSERT(log);
-	DE_ASSERT(result == QP_TEST_RESULT_CRASH || result == QP_TEST_RESULT_TIMEOUT);
+    DE_ASSERT(log);
+    DE_ASSERT(result == QP_TEST_RESULT_CRASH || result == QP_TEST_RESULT_TIMEOUT);
 
-	deMutex_lock(log->lock);
+    deMutex_lock(log->lock);
 
-	if (!log->isCaseOpen)
-	{
-		deMutex_unlock(log->lock);
-		return DE_FALSE; /* Soft error. This is called from error handler. */
-	}
+    if (!log->isCaseOpen)
+    {
+        deMutex_unlock(log->lock);
+        return DE_FALSE; /* Soft error. This is called from error handler. */
+    }
 
-	/* Flush XML and write #terminateTestCaseResult. */
-	qpXmlWriter_flush(log->writer);
-	fprintf(log->outputFile, "\n#terminateTestCaseResult %s\n", resultStr);
-	qpTestLog_flushFile(log);
+    /* Flush XML and write #terminateTestCaseResult. */
+    qpXmlWriter_flush(log->writer);
+    fprintf(log->outputFile, "\n#terminateTestCaseResult %s\n", resultStr);
+    qpTestLog_flushFile(log);
 
-	log->isCaseOpen = DE_FALSE;
+    log->isCaseOpen = DE_FALSE;
 
 #if defined(DE_DEBUG)
-	ContainerStack_reset(&log->containerStack);
+    ContainerStack_reset(&log->containerStack);
 #endif
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 static deBool qpTestLog_writeKeyValuePair (qpTestLog* log, const char* elementName, const char* name, const char* description, const char* unit, qpKeyValueTag tag, const char* text)
 {
-	const char*		tagString = QP_LOOKUP_STRING(s_qpTagMap, tag);
-	qpXmlAttribute	attribs[8];
-	int				numAttribs = 0;
-
-	DE_ASSERT(log && elementName && text);
-	deMutex_lock(log->lock);
-
-	/* Fill in attributes. */
-	if (name)			attribs[numAttribs++] = qpSetStringAttrib("Name", name);
-	if (description)	attribs[numAttribs++] = qpSetStringAttrib("Description", description);
-	if (tagString)		attribs[numAttribs++] = qpSetStringAttrib("Tag", tagString);
-	if (unit)			attribs[numAttribs++] = qpSetStringAttrib("Unit", unit);
-
-	if (!qpXmlWriter_startElement(log->writer, elementName, numAttribs, attribs) ||
-		!qpXmlWriter_writeString(log->writer, text) ||
-		!qpXmlWriter_endElement(log->writer, elementName))
-	{
-		qpPrintf("qpTestLog_writeKeyValuePair(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
-
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    const char*     tagString = QP_LOOKUP_STRING(s_qpTagMap, tag);
+    qpXmlAttribute  attribs[8];
+    int             numAttribs = 0;
+
+    DE_ASSERT(log && elementName && text);
+    deMutex_lock(log->lock);
+
+    /* Fill in attributes. */
+    if (name)           attribs[numAttribs++] = qpSetStringAttrib("Name", name);
+    if (description)    attribs[numAttribs++] = qpSetStringAttrib("Description", description);
+    if (tagString)      attribs[numAttribs++] = qpSetStringAttrib("Tag", tagString);
+    if (unit)           attribs[numAttribs++] = qpSetStringAttrib("Unit", unit);
+
+    if (!qpXmlWriter_startElement(log->writer, elementName, numAttribs, attribs) ||
+        !qpXmlWriter_writeString(log->writer, text) ||
+        !qpXmlWriter_endElement(log->writer, elementName))
+    {
+        qpPrintf("qpTestLog_writeKeyValuePair(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
+
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 /*--------------------------------------------------------------------*//*!
  * \brief Write a message to output log
- * \param log		qpTestLog instance
- * \param format	Format string of message
- * \param ...		Parameters for message
+ * \param log       qpTestLog instance
+ * \param format    Format string of message
+ * \param ...       Parameters for message
  * \return true if ok, false otherwise
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_writeMessage (qpTestLog* log, const char* format, ...)
 {
-	char	buffer[1024];
-	va_list	args;
+    char    buffer[1024];
+    va_list args;
 
-	/* \todo [petri] Handle buffer overflows! */
+    /* \todo [petri] Handle buffer overflows! */
 
-	va_start(args, format);
-	buffer[DE_LENGTH_OF_ARRAY(buffer) - 1] = 0;
-	vsnprintf(buffer, sizeof(buffer), format, args);
-	va_end(args);
+    va_start(args, format);
+    buffer[DE_LENGTH_OF_ARRAY(buffer) - 1] = 0;
+    vsnprintf(buffer, sizeof(buffer), format, args);
+    va_end(args);
 
-	/* <Text>text</Text> */
-	return qpTestLog_writeKeyValuePair(log, "Text", DE_NULL, DE_NULL, DE_NULL, QP_KEY_TAG_LAST, buffer);
+    /* <Text>text</Text> */
+    return qpTestLog_writeKeyValuePair(log, "Text", DE_NULL, DE_NULL, DE_NULL, QP_KEY_TAG_LAST, buffer);
 }
 
 /*--------------------------------------------------------------------*//*!
  * \brief Write key-value-pair into log
- * \param log			qpTestLog instance
- * \param name			Unique identifier for entry
- * \param description	Human readable description
- * \param tag			Optional tag
- * \param value			Value of the key-value-pair
+ * \param log           qpTestLog instance
+ * \param name          Unique identifier for entry
+ * \param description   Human readable description
+ * \param tag           Optional tag
+ * \param value         Value of the key-value-pair
  * \return true if ok, false otherwise
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_writeText (qpTestLog* log, const char* name, const char* description, qpKeyValueTag tag, const char* text)
 {
-	/* <Text Name="name" Description="description" Tag="tag">text</Text> */
-	return qpTestLog_writeKeyValuePair(log, "Text", name, description, DE_NULL, tag, text);
+    /* <Text Name="name" Description="description" Tag="tag">text</Text> */
+    return qpTestLog_writeKeyValuePair(log, "Text", name, description, DE_NULL, tag, text);
 }
 
 /*--------------------------------------------------------------------*//*!
  * \brief Write key-value-pair into log
- * \param log			qpTestLog instance
- * \param name			Unique identifier for entry
- * \param description	Human readable description
- * \param tag			Optional tag
- * \param value			Value of the key-value-pair
+ * \param log           qpTestLog instance
+ * \param name          Unique identifier for entry
+ * \param description   Human readable description
+ * \param tag           Optional tag
+ * \param value         Value of the key-value-pair
  * \return true if ok, false otherwise
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_writeInteger (qpTestLog* log, const char* name, const char* description, const char* unit, qpKeyValueTag tag, deInt64 value)
 {
-	char tmpString[64];
-	int64ToString(value, tmpString);
+    char tmpString[64];
+    int64ToString(value, tmpString);
 
-	/* <Number Name="name" Description="description" Tag="Performance">15</Number> */
-	return qpTestLog_writeKeyValuePair(log, "Number", name, description, unit, tag, tmpString);
+    /* <Number Name="name" Description="description" Tag="Performance">15</Number> */
+    return qpTestLog_writeKeyValuePair(log, "Number", name, description, unit, tag, tmpString);
 }
 
 /*--------------------------------------------------------------------*//*!
  * \brief Write key-value-pair into log
- * \param log			qpTestLog instance
- * \param name			Unique identifier for entry
- * \param description	Human readable description
- * \param tag			Optional tag
- * \param value			Value of the key-value-pair
+ * \param log           qpTestLog instance
+ * \param name          Unique identifier for entry
+ * \param description   Human readable description
+ * \param tag           Optional tag
+ * \param value         Value of the key-value-pair
  * \return true if ok, false otherwise
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_writeFloat (qpTestLog* log, const char* name, const char* description, const char* unit, qpKeyValueTag tag, float value)
 {
-	char tmpString[64];
-	floatToString(value, tmpString, sizeof(tmpString));
+    char tmpString[64];
+    floatToString(value, tmpString, sizeof(tmpString));
 
-	/* <Number Name="name" Description="description" Tag="Performance">15</Number> */
-	return qpTestLog_writeKeyValuePair(log, "Number", name, description, unit, tag, tmpString);
+    /* <Number Name="name" Description="description" Tag="Performance">15</Number> */
+    return qpTestLog_writeKeyValuePair(log, "Number", name, description, unit, tag, tmpString);
 }
 
 typedef struct Buffer_s
 {
-	size_t		capacity;
-	size_t		size;
-	deUint8*	data;
+    size_t      capacity;
+    size_t      size;
+    deUint8*    data;
 } Buffer;
 
 void Buffer_init (Buffer* buffer)
 {
-	buffer->capacity	= 0;
-	buffer->size		= 0;
-	buffer->data		= DE_NULL;
+    buffer->capacity    = 0;
+    buffer->size        = 0;
+    buffer->data        = DE_NULL;
 }
 
 void Buffer_deinit (Buffer* buffer)
 {
-	deFree(buffer->data);
-	Buffer_init(buffer);
+    deFree(buffer->data);
+    Buffer_init(buffer);
 }
 
 deBool Buffer_resize (Buffer* buffer, size_t newSize)
 {
-	/* Grow buffer if necessary. */
-	if (newSize > buffer->capacity)
-	{
-		size_t		newCapacity	= (size_t)deAlign32(deMax32(2*(int)buffer->capacity, (int)newSize), 512);
-		deUint8*	newData		= (deUint8*)deMalloc(newCapacity);
-		if (!newData)
-			return DE_FALSE;
-
-		memcpy(newData, buffer->data, buffer->size);
-		deFree(buffer->data);
-		buffer->data		= newData;
-		buffer->capacity	= newCapacity;
-	}
-
-	buffer->size = newSize;
-	return DE_TRUE;
+    /* Grow buffer if necessary. */
+    if (newSize > buffer->capacity)
+    {
+        size_t      newCapacity = (size_t)deAlign32(deMax32(2*(int)buffer->capacity, (int)newSize), 512);
+        deUint8*    newData     = (deUint8*)deMalloc(newCapacity);
+        if (!newData)
+            return DE_FALSE;
+
+        memcpy(newData, buffer->data, buffer->size);
+        deFree(buffer->data);
+        buffer->data        = newData;
+        buffer->capacity    = newCapacity;
+    }
+
+    buffer->size = newSize;
+    return DE_TRUE;
 }
 
 deBool Buffer_append (Buffer* buffer, const deUint8* data, size_t numBytes)
 {
-	size_t offset = buffer->size;
+    size_t offset = buffer->size;
 
-	if (!Buffer_resize(buffer, buffer->size + numBytes))
-		return DE_FALSE;
+    if (!Buffer_resize(buffer, buffer->size + numBytes))
+        return DE_FALSE;
 
-	/* Append bytes. */
-	memcpy(&buffer->data[offset], data, numBytes);
-	return DE_TRUE;
+    /* Append bytes. */
+    memcpy(&buffer->data[offset], data, numBytes);
+    return DE_TRUE;
 }
 
 #if defined(QP_SUPPORT_PNG)
 void pngWriteData (png_structp png, png_bytep dataPtr, png_size_t numBytes)
 {
-	Buffer* buffer = (Buffer*)png_get_io_ptr(png);
-	if (!Buffer_append(buffer, (const deUint8*)dataPtr, numBytes))
-		png_error(png, "unable to resize PNG write buffer!");
+    Buffer* buffer = (Buffer*)png_get_io_ptr(png);
+    if (!Buffer_append(buffer, (const deUint8*)dataPtr, numBytes))
+        png_error(png, "unable to resize PNG write buffer!");
 }
 
 void pngFlushData (png_structp png)
 {
-	DE_UNREF(png);
-	/* nada */
+    DE_UNREF(png);
+    /* nada */
 }
 
 static deBool writeCompressedPNG (png_structp png, png_infop info, png_byte** rowPointers, int width, int height, int colorFormat)
 {
-	if (setjmp(png_jmpbuf(png)) == 0)
-	{
-		/* Write data. */
-		png_set_IHDR(png, info, (png_uint_32)width, (png_uint_32)height,
-			8,
-			colorFormat,
-			PNG_INTERLACE_NONE,
-			PNG_COMPRESSION_TYPE_BASE,
-			PNG_FILTER_TYPE_BASE);
-		png_write_info(png, info);
-		png_write_image(png, rowPointers);
-		png_write_end(png, NULL);
-
-		return DE_TRUE;
-	}
-	else
-		return DE_FALSE;
+    if (setjmp(png_jmpbuf(png)) == 0)
+    {
+        /* Write data. */
+        png_set_IHDR(png, info, (png_uint_32)width, (png_uint_32)height,
+            8,
+            colorFormat,
+            PNG_INTERLACE_NONE,
+            PNG_COMPRESSION_TYPE_BASE,
+            PNG_FILTER_TYPE_BASE);
+        png_write_info(png, info);
+        png_write_image(png, rowPointers);
+        png_write_end(png, NULL);
+
+        return DE_TRUE;
+    }
+    else
+        return DE_FALSE;
 }
 
 static deBool compressImagePNG (Buffer* buffer, qpImageFormat imageFormat, int width, int height, int rowStride, const void* data)
 {
-	deBool			compressOk		= DE_FALSE;
-	png_structp		png				= DE_NULL;
-	png_infop		info			= DE_NULL;
-	png_byte**		rowPointers		= DE_NULL;
-	deBool			hasAlpha		= imageFormat == QP_IMAGE_FORMAT_RGBA8888;
-	int				ndx;
-
-	/* Handle format. */
-	DE_ASSERT(imageFormat == QP_IMAGE_FORMAT_RGB888 || imageFormat == QP_IMAGE_FORMAT_RGBA8888);
-
-	/* Allocate & set row pointers. */
-	rowPointers = (png_byte**)deMalloc((size_t)height * sizeof(png_byte*));
-	if (!rowPointers)
-		return DE_FALSE;
-
-	for (ndx = 0; ndx < height; ndx++)
-		rowPointers[ndx] = (png_byte*)((const deUint8*)data + ndx*rowStride);
-
-	/* Initialize PNG compressor. */
-	png = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-	info = png ? png_create_info_struct(png) : DE_NULL;
-	if (png && info)
-	{
-		/* Set our own write function. */
-		png_set_write_fn(png, buffer, pngWriteData, pngFlushData);
-
-		compressOk = writeCompressedPNG(png, info, rowPointers, width, height,
-										hasAlpha ? PNG_COLOR_TYPE_RGBA : PNG_COLOR_TYPE_RGB);
-	}
-
-	/* Cleanup & return. */
-	if (png && info)
-	{
-		png_destroy_info_struct(png, &info);
-		png_destroy_write_struct(&png, DE_NULL);
-	}
-	else if (png)
-		png_destroy_write_struct(&png, &info);
-
-	deFree(rowPointers);
-	return compressOk;
+    deBool          compressOk      = DE_FALSE;
+    png_structp     png             = DE_NULL;
+    png_infop       info            = DE_NULL;
+    png_byte**      rowPointers     = DE_NULL;
+    deBool          hasAlpha        = imageFormat == QP_IMAGE_FORMAT_RGBA8888;
+    int             ndx;
+
+    /* Handle format. */
+    DE_ASSERT(imageFormat == QP_IMAGE_FORMAT_RGB888 || imageFormat == QP_IMAGE_FORMAT_RGBA8888);
+
+    /* Allocate & set row pointers. */
+    rowPointers = (png_byte**)deMalloc((size_t)height * sizeof(png_byte*));
+    if (!rowPointers)
+        return DE_FALSE;
+
+    for (ndx = 0; ndx < height; ndx++)
+        rowPointers[ndx] = (png_byte*)((const deUint8*)data + ndx*rowStride);
+
+    /* Initialize PNG compressor. */
+    png = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+    info = png ? png_create_info_struct(png) : DE_NULL;
+    if (png && info)
+    {
+        /* Set our own write function. */
+        png_set_write_fn(png, buffer, pngWriteData, pngFlushData);
+
+        compressOk = writeCompressedPNG(png, info, rowPointers, width, height,
+                                        hasAlpha ? PNG_COLOR_TYPE_RGBA : PNG_COLOR_TYPE_RGB);
+    }
+
+    /* Cleanup & return. */
+    if (png && info)
+    {
+        png_destroy_info_struct(png, &info);
+        png_destroy_write_struct(&png, DE_NULL);
+    }
+    else if (png)
+        png_destroy_write_struct(&png, &info);
+
+    deFree(rowPointers);
+    return compressOk;
 }
 #endif /* QP_SUPPORT_PNG */
 
 /*--------------------------------------------------------------------*//*!
  * \brief Start image set
- * \param log			qpTestLog instance
- * \param name			Unique identifier for the set
- * \param description	Human readable description
+ * \param log           qpTestLog instance
+ * \param name          Unique identifier for the set
+ * \param description   Human readable description
  * \return true if ok, false otherwise
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_startImageSet (qpTestLog* log, const char* name, const char* description)
 {
-	qpXmlAttribute	attribs[4];
-	int				numAttribs = 0;
+    qpXmlAttribute  attribs[4];
+    int             numAttribs = 0;
 
-	DE_ASSERT(log && name);
-	deMutex_lock(log->lock);
+    DE_ASSERT(log && name);
+    deMutex_lock(log->lock);
 
-	attribs[numAttribs++] = qpSetStringAttrib("Name", name);
-	if (description)
-		attribs[numAttribs++] = qpSetStringAttrib("Description", description);
+    attribs[numAttribs++] = qpSetStringAttrib("Name", name);
+    if (description)
+        attribs[numAttribs++] = qpSetStringAttrib("Description", description);
 
-	/* <ImageSet Name="<name>"> */
-	if (!qpXmlWriter_startElement(log->writer, "ImageSet", numAttribs, attribs))
-	{
-		qpPrintf("qpTestLog_startImageSet(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    /* <ImageSet Name="<name>"> */
+    if (!qpXmlWriter_startElement(log->writer, "ImageSet", numAttribs, attribs))
+    {
+        qpPrintf("qpTestLog_startImageSet(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	DE_ASSERT(ContainerStack_push(&log->containerStack, CONTAINERTYPE_IMAGESET));
+    DE_ASSERT(ContainerStack_push(&log->containerStack, CONTAINERTYPE_IMAGESET));
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 /*--------------------------------------------------------------------*//*!
  * \brief End image set
- * \param log			qpTestLog instance
+ * \param log           qpTestLog instance
  * \return true if ok, false otherwise
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_endImageSet (qpTestLog* log)
 {
-	DE_ASSERT(log);
-	deMutex_lock(log->lock);
+    DE_ASSERT(log);
+    deMutex_lock(log->lock);
 
-	/* <ImageSet Name="<name>"> */
-	if (!qpXmlWriter_endElement(log->writer, "ImageSet"))
-	{
-		qpPrintf("qpTestLog_endImageSet(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    /* <ImageSet Name="<name>"> */
+    if (!qpXmlWriter_endElement(log->writer, "ImageSet"))
+    {
+        qpPrintf("qpTestLog_endImageSet(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	DE_ASSERT(ContainerStack_pop(&log->containerStack) == CONTAINERTYPE_IMAGESET);
+    DE_ASSERT(ContainerStack_pop(&log->containerStack) == CONTAINERTYPE_IMAGESET);
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 /*--------------------------------------------------------------------*//*!
  * \brief Write base64 encoded raw image data into log
- * \param log				qpTestLog instance
- * \param name				Unique name (matching names can be compared across BatchResults).
- * \param description		Textual description (shown in Candy).
- * \param compressionMode	Compression mode
- * \param imageFormat		Color format
- * \param width				Width in pixels
- * \param height			Height in pixels
- * \param stride			Data stride (offset between rows)
- * \param data				Pointer to pixel data
+ * \param log               qpTestLog instance
+ * \param name              Unique name (matching names can be compared across BatchResults).
+ * \param description       Textual description (shown in Candy).
+ * \param compressionMode   Compression mode
+ * \param imageFormat       Color format
+ * \param width             Width in pixels
+ * \param height            Height in pixels
+ * \param stride            Data stride (offset between rows)
+ * \param data              Pointer to pixel data
  * \return 0 if OK, otherwise <0
  *//*--------------------------------------------------------------------*/
-deBool qpTestLog_writeImage	(
-	qpTestLog*				log,
-	const char*				name,
-	const char*				description,
-	qpImageCompressionMode	compressionMode,
-	qpImageFormat			imageFormat,
-	int						width,
-	int						height,
-	int						stride,
-	const void*				data)
-{
-	char			widthStr[32];
-	char			heightStr[32];
-	qpXmlAttribute	attribs[8];
-	int				numAttribs			= 0;
-	Buffer			compressedBuffer;
-	const void*		writeDataPtr		= DE_NULL;
-	size_t			writeDataBytes		= ~(size_t)0;
-
-	DE_ASSERT(log && name);
-	DE_ASSERT(deInRange32(width, 1, 16384));
-	DE_ASSERT(deInRange32(height, 1, 16384));
-	DE_ASSERT(data);
-
-	if (log->flags & QP_TEST_LOG_EXCLUDE_IMAGES)
-		return DE_TRUE; /* Image not logged. */
-
-	Buffer_init(&compressedBuffer);
-
-	/* BEST compression mode defaults to PNG. */
-	if (compressionMode == QP_IMAGE_COMPRESSION_MODE_BEST)
-	{
+deBool qpTestLog_writeImage (
+    qpTestLog*              log,
+    const char*             name,
+    const char*             description,
+    qpImageCompressionMode  compressionMode,
+    qpImageFormat           imageFormat,
+    int                     width,
+    int                     height,
+    int                     stride,
+    const void*             data)
+{
+    char            widthStr[32];
+    char            heightStr[32];
+    qpXmlAttribute  attribs[8];
+    int             numAttribs          = 0;
+    Buffer          compressedBuffer;
+    const void*     writeDataPtr        = DE_NULL;
+    size_t          writeDataBytes      = ~(size_t)0;
+
+    DE_ASSERT(log && name);
+    DE_ASSERT(deInRange32(width, 1, 16384));
+    DE_ASSERT(deInRange32(height, 1, 16384));
+    DE_ASSERT(data);
+
+    if (log->flags & QP_TEST_LOG_EXCLUDE_IMAGES)
+        return DE_TRUE; /* Image not logged. */
+
+    Buffer_init(&compressedBuffer);
+
+    /* BEST compression mode defaults to PNG. */
+    if (compressionMode == QP_IMAGE_COMPRESSION_MODE_BEST)
+    {
 #if defined(QP_SUPPORT_PNG)
-		compressionMode = QP_IMAGE_COMPRESSION_MODE_PNG;
+        compressionMode = QP_IMAGE_COMPRESSION_MODE_PNG;
 #else
-		compressionMode = QP_IMAGE_COMPRESSION_MODE_NONE;
+        compressionMode = QP_IMAGE_COMPRESSION_MODE_NONE;
 #endif
-	}
+    }
 
 #if defined(QP_SUPPORT_PNG)
-	/* Try storing with PNG compression. */
-	if (compressionMode == QP_IMAGE_COMPRESSION_MODE_PNG)
-	{
-		deBool compressOk = compressImagePNG(&compressedBuffer, imageFormat, width, height, stride, data);
-		if (compressOk)
-		{
-			writeDataPtr	= compressedBuffer.data;
-			writeDataBytes	= compressedBuffer.size;
-		}
-		else
-		{
-			/* Fall-back to default compression. */
-			qpPrintf("WARNING: PNG compression failed -- storing image uncompressed.\n");
-			compressionMode	= QP_IMAGE_COMPRESSION_MODE_NONE;
-		}
-	}
+    /* Try storing with PNG compression. */
+    if (compressionMode == QP_IMAGE_COMPRESSION_MODE_PNG)
+    {
+        deBool compressOk = compressImagePNG(&compressedBuffer, imageFormat, width, height, stride, data);
+        if (compressOk)
+        {
+            writeDataPtr    = compressedBuffer.data;
+            writeDataBytes  = compressedBuffer.size;
+        }
+        else
+        {
+            /* Fall-back to default compression. */
+            qpPrintf("WARNING: PNG compression failed -- storing image uncompressed.\n");
+            compressionMode = QP_IMAGE_COMPRESSION_MODE_NONE;
+        }
+    }
 #endif
 
-	/* Handle image compression. */
-	switch (compressionMode)
-	{
-		case QP_IMAGE_COMPRESSION_MODE_NONE:
-		{
-			int pixelSize		= imageFormat == QP_IMAGE_FORMAT_RGB888 ? 3 : 4;
-			int packedStride	= pixelSize*width;
-
-			if (packedStride == stride)
-				writeDataPtr = data;
-			else
-			{
-				/* Need to re-pack pixels. */
-				if (Buffer_resize(&compressedBuffer, (size_t)(packedStride*height)))
-				{
-					int row;
-					for (row = 0; row < height; row++)
-						memcpy(&compressedBuffer.data[packedStride*row], &((const deUint8*)data)[row*stride], (size_t)(pixelSize*width));
-				}
-				else
-				{
-					qpPrintf("ERROR: Failed to pack pixels for writing.\n");
-					Buffer_deinit(&compressedBuffer);
-					return DE_FALSE;
-				}
-			}
-
-			writeDataBytes = (size_t)(packedStride*height);
-			break;
-		}
+    /* Handle image compression. */
+    switch (compressionMode)
+    {
+        case QP_IMAGE_COMPRESSION_MODE_NONE:
+        {
+            int pixelSize       = imageFormat == QP_IMAGE_FORMAT_RGB888 ? 3 : 4;
+            int packedStride    = pixelSize*width;
+
+            if (packedStride == stride)
+                writeDataPtr = data;
+            else
+            {
+                /* Need to re-pack pixels. */
+                if (Buffer_resize(&compressedBuffer, (size_t)(packedStride*height)))
+                {
+                    int row;
+                    for (row = 0; row < height; row++)
+                        memcpy(&compressedBuffer.data[packedStride*row], &((const deUint8*)data)[row*stride], (size_t)(pixelSize*width));
+                }
+                else
+                {
+                    qpPrintf("ERROR: Failed to pack pixels for writing.\n");
+                    Buffer_deinit(&compressedBuffer);
+                    return DE_FALSE;
+                }
+            }
+
+            writeDataBytes = (size_t)(packedStride*height);
+            break;
+        }
 
 #if defined(QP_SUPPORT_PNG)
-		case QP_IMAGE_COMPRESSION_MODE_PNG:
-			DE_ASSERT(writeDataPtr); /* Already handled. */
-			break;
+        case QP_IMAGE_COMPRESSION_MODE_PNG:
+            DE_ASSERT(writeDataPtr); /* Already handled. */
+            break;
 #endif
 
-		default:
-			qpPrintf("qpTestLog_writeImage(): Unknown compression mode: %s\n", QP_LOOKUP_STRING(s_qpImageCompressionModeMap, compressionMode));
-			Buffer_deinit(&compressedBuffer);
-			return DE_FALSE;
-	}
-
-	/* Fill in attributes. */
-	int32ToString(width, widthStr);
-	int32ToString(height, heightStr);
-	attribs[numAttribs++] = qpSetStringAttrib("Name", name);
-	attribs[numAttribs++] = qpSetStringAttrib("Width", widthStr);
-	attribs[numAttribs++] = qpSetStringAttrib("Height", heightStr);
-	attribs[numAttribs++] = qpSetStringAttrib("Format", QP_LOOKUP_STRING(s_qpImageFormatMap, imageFormat));
-	attribs[numAttribs++] = qpSetStringAttrib("CompressionMode", QP_LOOKUP_STRING(s_qpImageCompressionModeMap, compressionMode));
-	if (description) attribs[numAttribs++] = qpSetStringAttrib("Description", description);
-
-	/* \note Log lock is acquired after compression! */
-	deMutex_lock(log->lock);
-
-	/* <Image ID="result" Name="Foobar" Width="640" Height="480" Format="RGB888" CompressionMode="None">base64 data</Image> */
-	if (!qpXmlWriter_startElement(log->writer, "Image", numAttribs, attribs) ||
-		!qpXmlWriter_writeBase64(log->writer, (const deUint8*)writeDataPtr, writeDataBytes) ||
-		!qpXmlWriter_endElement(log->writer, "Image"))
-	{
-		qpPrintf("qpTestLog_writeImage(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		Buffer_deinit(&compressedBuffer);
-		return DE_FALSE;
-	}
-
-	deMutex_unlock(log->lock);
-
-	/* Free compressed data if allocated. */
-	Buffer_deinit(&compressedBuffer);
-
-	return DE_TRUE;
+        default:
+            qpPrintf("qpTestLog_writeImage(): Unknown compression mode: %s\n", QP_LOOKUP_STRING(s_qpImageCompressionModeMap, compressionMode));
+            Buffer_deinit(&compressedBuffer);
+            return DE_FALSE;
+    }
+
+    /* Fill in attributes. */
+    int32ToString(width, widthStr);
+    int32ToString(height, heightStr);
+    attribs[numAttribs++] = qpSetStringAttrib("Name", name);
+    attribs[numAttribs++] = qpSetStringAttrib("Width", widthStr);
+    attribs[numAttribs++] = qpSetStringAttrib("Height", heightStr);
+    attribs[numAttribs++] = qpSetStringAttrib("Format", QP_LOOKUP_STRING(s_qpImageFormatMap, imageFormat));
+    attribs[numAttribs++] = qpSetStringAttrib("CompressionMode", QP_LOOKUP_STRING(s_qpImageCompressionModeMap, compressionMode));
+    if (description) attribs[numAttribs++] = qpSetStringAttrib("Description", description);
+
+    /* \note Log lock is acquired after compression! */
+    deMutex_lock(log->lock);
+
+    /* <Image ID="result" Name="Foobar" Width="640" Height="480" Format="RGB888" CompressionMode="None">base64 data</Image> */
+    if (!qpXmlWriter_startElement(log->writer, "Image", numAttribs, attribs) ||
+        !qpXmlWriter_writeBase64(log->writer, (const deUint8*)writeDataPtr, writeDataBytes) ||
+        !qpXmlWriter_endElement(log->writer, "Image"))
+    {
+        qpPrintf("qpTestLog_writeImage(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        Buffer_deinit(&compressedBuffer);
+        return DE_FALSE;
+    }
+
+    deMutex_unlock(log->lock);
+
+    /* Free compressed data if allocated. */
+    Buffer_deinit(&compressedBuffer);
+
+    return DE_TRUE;
 }
 
 /*--------------------------------------------------------------------*//*!
  * \brief Write a OpenGL ES shader program into the log.
- * \param linkOk			Shader program link result, false on failure
- * \param linkInfoLog		Implementation provided linkage log
+ * \param linkOk            Shader program link result, false on failure
+ * \param linkInfoLog       Implementation provided linkage log
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_startShaderProgram (qpTestLog* log, deBool linkOk, const char* linkInfoLog)
 {
-	qpXmlAttribute	programAttribs[4];
-	int				numProgramAttribs = 0;
+    qpXmlAttribute  programAttribs[4];
+    int             numProgramAttribs = 0;
 
-	DE_ASSERT(log);
-	deMutex_lock(log->lock);
+    DE_ASSERT(log);
+    deMutex_lock(log->lock);
 
-	programAttribs[numProgramAttribs++] = qpSetStringAttrib("LinkStatus", linkOk ? "OK" : "Fail");
+    programAttribs[numProgramAttribs++] = qpSetStringAttrib("LinkStatus", linkOk ? "OK" : "Fail");
 
-	if (!qpXmlWriter_startElement(log->writer, "ShaderProgram", numProgramAttribs, programAttribs) ||
-		!qpXmlWriter_writeStringElement(log->writer, "InfoLog", linkInfoLog))
-	{
-		qpPrintf("qpTestLog_startShaderProgram(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    if (!qpXmlWriter_startElement(log->writer, "ShaderProgram", numProgramAttribs, programAttribs) ||
+        !qpXmlWriter_writeStringElement(log->writer, "InfoLog", linkInfoLog))
+    {
+        qpPrintf("qpTestLog_startShaderProgram(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	DE_ASSERT(ContainerStack_push(&log->containerStack, CONTAINERTYPE_SHADERPROGRAM));
+    DE_ASSERT(ContainerStack_push(&log->containerStack, CONTAINERTYPE_SHADERPROGRAM));
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 /*--------------------------------------------------------------------*//*!
  * \brief End shader program
- * \param log			qpTestLog instance
+ * \param log           qpTestLog instance
  * \return true if ok, false otherwise
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_endShaderProgram (qpTestLog* log)
 {
-	DE_ASSERT(log);
-	deMutex_lock(log->lock);
+    DE_ASSERT(log);
+    deMutex_lock(log->lock);
 
-	/* </ShaderProgram> */
-	if (!qpXmlWriter_endElement(log->writer, "ShaderProgram"))
-	{
-		qpPrintf("qpTestLog_endShaderProgram(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    /* </ShaderProgram> */
+    if (!qpXmlWriter_endElement(log->writer, "ShaderProgram"))
+    {
+        qpPrintf("qpTestLog_endShaderProgram(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	DE_ASSERT(ContainerStack_pop(&log->containerStack) == CONTAINERTYPE_SHADERPROGRAM);
+    DE_ASSERT(ContainerStack_pop(&log->containerStack) == CONTAINERTYPE_SHADERPROGRAM);
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 /*--------------------------------------------------------------------*//*!
  * \brief Write a OpenGL ES shader into the log.
- * \param type				Shader type
- * \param source			Shader source
- * \param compileOk			Shader compilation result, false on failure
- * \param infoLog			Implementation provided shader compilation log
+ * \param type              Shader type
+ * \param source            Shader source
+ * \param compileOk         Shader compilation result, false on failure
+ * \param infoLog           Implementation provided shader compilation log
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_writeShader (qpTestLog* log, qpShaderType type, const char* source, deBool compileOk, const char* infoLog)
 {
-	const char*		tagName				= QP_LOOKUP_STRING(s_qpShaderTypeMap, type);
-	const char*		sourceStr			= ((log->flags & QP_TEST_LOG_EXCLUDE_SHADER_SOURCES) == 0 || !compileOk) ? source : "";
-	int				numShaderAttribs	= 0;
-	qpXmlAttribute	shaderAttribs[4];
+    const char*     tagName             = QP_LOOKUP_STRING(s_qpShaderTypeMap, type);
+    const char*     sourceStr           = ((log->flags & QP_TEST_LOG_EXCLUDE_SHADER_SOURCES) == 0 || !compileOk) ? source : "";
+    int             numShaderAttribs    = 0;
+    qpXmlAttribute  shaderAttribs[4];
 
-	deMutex_lock(log->lock);
+    deMutex_lock(log->lock);
 
-	DE_ASSERT(source);
-	DE_ASSERT(ContainerStack_getTop(&log->containerStack) == CONTAINERTYPE_SHADERPROGRAM);
+    DE_ASSERT(source);
+    DE_ASSERT(ContainerStack_getTop(&log->containerStack) == CONTAINERTYPE_SHADERPROGRAM);
 
-	shaderAttribs[numShaderAttribs++]	= qpSetStringAttrib("CompileStatus", compileOk ? "OK" : "Fail");
+    shaderAttribs[numShaderAttribs++]   = qpSetStringAttrib("CompileStatus", compileOk ? "OK" : "Fail");
 
-	if (!qpXmlWriter_startElement(log->writer, tagName, numShaderAttribs, shaderAttribs) ||
-		!qpXmlWriter_writeStringElement(log->writer, "ShaderSource", sourceStr) ||
-		!qpXmlWriter_writeStringElement(log->writer, "InfoLog", infoLog) ||
-		!qpXmlWriter_endElement(log->writer, tagName))
-	{
-		qpPrintf("qpTestLog_writeShader(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    if (!qpXmlWriter_startElement(log->writer, tagName, numShaderAttribs, shaderAttribs) ||
+        !qpXmlWriter_writeStringElement(log->writer, "ShaderSource", sourceStr) ||
+        !qpXmlWriter_writeStringElement(log->writer, "InfoLog", infoLog) ||
+        !qpXmlWriter_endElement(log->writer, tagName))
+    {
+        qpPrintf("qpTestLog_writeShader(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 /*--------------------------------------------------------------------*//*!
@@ -1053,28 +1053,28 @@ deBool qpTestLog_writeShader (qpTestLog* log, qpShaderType type, const char* sou
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_startEglConfigSet (qpTestLog* log, const char* name, const char* description)
 {
-	qpXmlAttribute	attribs[4];
-	int				numAttribs = 0;
+    qpXmlAttribute  attribs[4];
+    int             numAttribs = 0;
 
-	DE_ASSERT(log && name);
-	deMutex_lock(log->lock);
+    DE_ASSERT(log && name);
+    deMutex_lock(log->lock);
 
-	attribs[numAttribs++] = qpSetStringAttrib("Name", name);
-	if (description)
-		attribs[numAttribs++] = qpSetStringAttrib("Description", description);
+    attribs[numAttribs++] = qpSetStringAttrib("Name", name);
+    if (description)
+        attribs[numAttribs++] = qpSetStringAttrib("Description", description);
 
-	/* <EglConfigSet Name="<name>"> */
-	if (!qpXmlWriter_startElement(log->writer, "EglConfigSet", numAttribs, attribs))
-	{
-		qpPrintf("qpTestLog_startEglImageSet(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    /* <EglConfigSet Name="<name>"> */
+    if (!qpXmlWriter_startElement(log->writer, "EglConfigSet", numAttribs, attribs))
+    {
+        qpPrintf("qpTestLog_startEglImageSet(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	DE_ASSERT(ContainerStack_push(&log->containerStack, CONTAINERTYPE_EGLCONFIGSET));
+    DE_ASSERT(ContainerStack_push(&log->containerStack, CONTAINERTYPE_EGLCONFIGSET));
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 /*--------------------------------------------------------------------*//*!
@@ -1082,21 +1082,21 @@ deBool qpTestLog_startEglConfigSet (qpTestLog* log, const char* name, const char
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_endEglConfigSet (qpTestLog* log)
 {
-	DE_ASSERT(log);
-	deMutex_lock(log->lock);
+    DE_ASSERT(log);
+    deMutex_lock(log->lock);
 
-	/* <EglConfigSet Name="<name>"> */
-	if (!qpXmlWriter_endElement(log->writer, "EglConfigSet"))
-	{
-		qpPrintf("qpTestLog_endEglImageSet(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    /* <EglConfigSet Name="<name>"> */
+    if (!qpXmlWriter_endElement(log->writer, "EglConfigSet"))
+    {
+        qpPrintf("qpTestLog_endEglImageSet(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	DE_ASSERT(ContainerStack_pop(&log->containerStack) == CONTAINERTYPE_EGLCONFIGSET);
+    DE_ASSERT(ContainerStack_pop(&log->containerStack) == CONTAINERTYPE_EGLCONFIGSET);
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 /*--------------------------------------------------------------------*//*!
@@ -1105,111 +1105,111 @@ deBool qpTestLog_endEglConfigSet (qpTestLog* log)
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_writeEglConfig (qpTestLog* log, const qpEglConfigInfo* config)
 {
-	qpXmlAttribute	attribs[64];
-	int				numAttribs = 0;
-
-	DE_ASSERT(log && config);
-	deMutex_lock(log->lock);
-
-	attribs[numAttribs++] = qpSetIntAttrib		("BufferSize", config->bufferSize);
-	attribs[numAttribs++] = qpSetIntAttrib		("RedSize", config->redSize);
-	attribs[numAttribs++] = qpSetIntAttrib		("GreenSize", config->greenSize);
-	attribs[numAttribs++] = qpSetIntAttrib		("BlueSize", config->blueSize);
-	attribs[numAttribs++] = qpSetIntAttrib		("LuminanceSize", config->luminanceSize);
-	attribs[numAttribs++] = qpSetIntAttrib		("AlphaSize", config->alphaSize);
-	attribs[numAttribs++] = qpSetIntAttrib		("AlphaMaskSize", config->alphaMaskSize);
-	attribs[numAttribs++] = qpSetBoolAttrib		("BindToTextureRGB", config->bindToTextureRGB);
-	attribs[numAttribs++] = qpSetBoolAttrib		("BindToTextureRGBA", config->bindToTextureRGBA);
-	attribs[numAttribs++] = qpSetStringAttrib	("ColorBufferType", config->colorBufferType);
-	attribs[numAttribs++] = qpSetStringAttrib	("ConfigCaveat", config->configCaveat);
-	attribs[numAttribs++] = qpSetIntAttrib		("ConfigID", config->configID);
-	attribs[numAttribs++] = qpSetStringAttrib	("Conformant", config->conformant);
-	attribs[numAttribs++] = qpSetIntAttrib		("DepthSize", config->depthSize);
-	attribs[numAttribs++] = qpSetIntAttrib		("Level", config->level);
-	attribs[numAttribs++] = qpSetIntAttrib		("MaxPBufferWidth", config->maxPBufferWidth);
-	attribs[numAttribs++] = qpSetIntAttrib		("MaxPBufferHeight", config->maxPBufferHeight);
-	attribs[numAttribs++] = qpSetIntAttrib		("MaxPBufferPixels", config->maxPBufferPixels);
-	attribs[numAttribs++] = qpSetIntAttrib		("MaxSwapInterval", config->maxSwapInterval);
-	attribs[numAttribs++] = qpSetIntAttrib		("MinSwapInterval", config->minSwapInterval);
-	attribs[numAttribs++] = qpSetBoolAttrib		("NativeRenderable", config->nativeRenderable);
-	attribs[numAttribs++] = qpSetStringAttrib	("RenderableType", config->renderableType);
-	attribs[numAttribs++] = qpSetIntAttrib		("SampleBuffers", config->sampleBuffers);
-	attribs[numAttribs++] = qpSetIntAttrib		("Samples", config->samples);
-	attribs[numAttribs++] = qpSetIntAttrib		("StencilSize", config->stencilSize);
-	attribs[numAttribs++] = qpSetStringAttrib	("SurfaceTypes", config->surfaceTypes);
-	attribs[numAttribs++] = qpSetStringAttrib	("TransparentType", config->transparentType);
-	attribs[numAttribs++] = qpSetIntAttrib		("TransparentRedValue", config->transparentRedValue);
-	attribs[numAttribs++] = qpSetIntAttrib		("TransparentGreenValue", config->transparentGreenValue);
-	attribs[numAttribs++] = qpSetIntAttrib		("TransparentBlueValue", config->transparentBlueValue);
-	DE_ASSERT(numAttribs <= DE_LENGTH_OF_ARRAY(attribs));
-
-	if (!qpXmlWriter_startElement(log->writer, "EglConfig", numAttribs, attribs) ||
-		!qpXmlWriter_endElement(log->writer, "EglConfig"))
-	{
-		qpPrintf("qpTestLog_writeEglConfig(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
-
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    qpXmlAttribute  attribs[64];
+    int             numAttribs = 0;
+
+    DE_ASSERT(log && config);
+    deMutex_lock(log->lock);
+
+    attribs[numAttribs++] = qpSetIntAttrib      ("BufferSize", config->bufferSize);
+    attribs[numAttribs++] = qpSetIntAttrib      ("RedSize", config->redSize);
+    attribs[numAttribs++] = qpSetIntAttrib      ("GreenSize", config->greenSize);
+    attribs[numAttribs++] = qpSetIntAttrib      ("BlueSize", config->blueSize);
+    attribs[numAttribs++] = qpSetIntAttrib      ("LuminanceSize", config->luminanceSize);
+    attribs[numAttribs++] = qpSetIntAttrib      ("AlphaSize", config->alphaSize);
+    attribs[numAttribs++] = qpSetIntAttrib      ("AlphaMaskSize", config->alphaMaskSize);
+    attribs[numAttribs++] = qpSetBoolAttrib     ("BindToTextureRGB", config->bindToTextureRGB);
+    attribs[numAttribs++] = qpSetBoolAttrib     ("BindToTextureRGBA", config->bindToTextureRGBA);
+    attribs[numAttribs++] = qpSetStringAttrib   ("ColorBufferType", config->colorBufferType);
+    attribs[numAttribs++] = qpSetStringAttrib   ("ConfigCaveat", config->configCaveat);
+    attribs[numAttribs++] = qpSetIntAttrib      ("ConfigID", config->configID);
+    attribs[numAttribs++] = qpSetStringAttrib   ("Conformant", config->conformant);
+    attribs[numAttribs++] = qpSetIntAttrib      ("DepthSize", config->depthSize);
+    attribs[numAttribs++] = qpSetIntAttrib      ("Level", config->level);
+    attribs[numAttribs++] = qpSetIntAttrib      ("MaxPBufferWidth", config->maxPBufferWidth);
+    attribs[numAttribs++] = qpSetIntAttrib      ("MaxPBufferHeight", config->maxPBufferHeight);
+    attribs[numAttribs++] = qpSetIntAttrib      ("MaxPBufferPixels", config->maxPBufferPixels);
+    attribs[numAttribs++] = qpSetIntAttrib      ("MaxSwapInterval", config->maxSwapInterval);
+    attribs[numAttribs++] = qpSetIntAttrib      ("MinSwapInterval", config->minSwapInterval);
+    attribs[numAttribs++] = qpSetBoolAttrib     ("NativeRenderable", config->nativeRenderable);
+    attribs[numAttribs++] = qpSetStringAttrib   ("RenderableType", config->renderableType);
+    attribs[numAttribs++] = qpSetIntAttrib      ("SampleBuffers", config->sampleBuffers);
+    attribs[numAttribs++] = qpSetIntAttrib      ("Samples", config->samples);
+    attribs[numAttribs++] = qpSetIntAttrib      ("StencilSize", config->stencilSize);
+    attribs[numAttribs++] = qpSetStringAttrib   ("SurfaceTypes", config->surfaceTypes);
+    attribs[numAttribs++] = qpSetStringAttrib   ("TransparentType", config->transparentType);
+    attribs[numAttribs++] = qpSetIntAttrib      ("TransparentRedValue", config->transparentRedValue);
+    attribs[numAttribs++] = qpSetIntAttrib      ("TransparentGreenValue", config->transparentGreenValue);
+    attribs[numAttribs++] = qpSetIntAttrib      ("TransparentBlueValue", config->transparentBlueValue);
+    DE_ASSERT(numAttribs <= DE_LENGTH_OF_ARRAY(attribs));
+
+    if (!qpXmlWriter_startElement(log->writer, "EglConfig", numAttribs, attribs) ||
+        !qpXmlWriter_endElement(log->writer, "EglConfig"))
+    {
+        qpPrintf("qpTestLog_writeEglConfig(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
+
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 /*--------------------------------------------------------------------*//*!
  * \brief Start section in log.
- * \param log			qpTestLog instance
- * \param name			Section name
- * \param description	Human readable description
+ * \param log           qpTestLog instance
+ * \param name          Section name
+ * \param description   Human readable description
  * \return true if ok, false otherwise
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_startSection (qpTestLog* log, const char* name, const char* description)
 {
-	qpXmlAttribute	attribs[2];
-	int				numAttribs = 0;
+    qpXmlAttribute  attribs[2];
+    int             numAttribs = 0;
 
-	DE_ASSERT(log && name);
-	deMutex_lock(log->lock);
+    DE_ASSERT(log && name);
+    deMutex_lock(log->lock);
 
-	attribs[numAttribs++] = qpSetStringAttrib("Name", name);
-	if (description)
-		attribs[numAttribs++] = qpSetStringAttrib("Description", description);
+    attribs[numAttribs++] = qpSetStringAttrib("Name", name);
+    if (description)
+        attribs[numAttribs++] = qpSetStringAttrib("Description", description);
 
-	/* <Section Name="<name>" Description="<description>"> */
-	if (!qpXmlWriter_startElement(log->writer, "Section", numAttribs, attribs))
-	{
-		qpPrintf("qpTestLog_startSection(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    /* <Section Name="<name>" Description="<description>"> */
+    if (!qpXmlWriter_startElement(log->writer, "Section", numAttribs, attribs))
+    {
+        qpPrintf("qpTestLog_startSection(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	DE_ASSERT(ContainerStack_push(&log->containerStack, CONTAINERTYPE_SECTION));
+    DE_ASSERT(ContainerStack_push(&log->containerStack, CONTAINERTYPE_SECTION));
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 /*--------------------------------------------------------------------*//*!
  * \brief End section in log.
- * \param log			qpTestLog instance
+ * \param log           qpTestLog instance
  * \return true if ok, false otherwise
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_endSection (qpTestLog* log)
 {
-	DE_ASSERT(log);
-	deMutex_lock(log->lock);
+    DE_ASSERT(log);
+    deMutex_lock(log->lock);
 
-	/* </Section> */
-	if (!qpXmlWriter_endElement(log->writer, "Section"))
-	{
-		qpPrintf("qpTestLog_endSection(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    /* </Section> */
+    if (!qpXmlWriter_endElement(log->writer, "Section"))
+    {
+        qpPrintf("qpTestLog_endSection(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	DE_ASSERT(ContainerStack_pop(&log->containerStack) == CONTAINERTYPE_SECTION);
+    DE_ASSERT(ContainerStack_pop(&log->containerStack) == CONTAINERTYPE_SECTION);
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 /*--------------------------------------------------------------------*//*!
@@ -1217,20 +1217,20 @@ deBool qpTestLog_endSection (qpTestLog* log)
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_writeKernelSource (qpTestLog* log, const char* source)
 {
-	const char*		sourceStr	= (log->flags & QP_TEST_LOG_EXCLUDE_SHADER_SOURCES) != 0 ? "" : source;
+    const char*     sourceStr   = (log->flags & QP_TEST_LOG_EXCLUDE_SHADER_SOURCES) != 0 ? "" : source;
 
-	DE_ASSERT(log);
-	deMutex_lock(log->lock);
+    DE_ASSERT(log);
+    deMutex_lock(log->lock);
 
-	if (!qpXmlWriter_writeStringElement(log->writer, "KernelSource", sourceStr))
-	{
-		qpPrintf("qpTestLog_writeKernelSource(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    if (!qpXmlWriter_writeStringElement(log->writer, "KernelSource", sourceStr))
+    {
+        qpPrintf("qpTestLog_writeKernelSource(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 /*--------------------------------------------------------------------*//*!
@@ -1238,21 +1238,21 @@ deBool qpTestLog_writeKernelSource (qpTestLog* log, const char* source)
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_writeSpirVAssemblySource (qpTestLog* log, const char* source)
 {
-	const char* const	sourceStr	= (log->flags & QP_TEST_LOG_EXCLUDE_SHADER_SOURCES) != 0 ? "" : source;
+    const char* const   sourceStr   = (log->flags & QP_TEST_LOG_EXCLUDE_SHADER_SOURCES) != 0 ? "" : source;
 
-	deMutex_lock(log->lock);
+    deMutex_lock(log->lock);
 
-	DE_ASSERT(ContainerStack_getTop(&log->containerStack) == CONTAINERTYPE_SHADERPROGRAM);
+    DE_ASSERT(ContainerStack_getTop(&log->containerStack) == CONTAINERTYPE_SHADERPROGRAM);
 
-	if (!qpXmlWriter_writeStringElement(log->writer, "SpirVAssemblySource", sourceStr))
-	{
-		qpPrintf("qpTestLog_writeSpirVAssemblySource(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    if (!qpXmlWriter_writeStringElement(log->writer, "SpirVAssemblySource", sourceStr))
+    {
+        qpPrintf("qpTestLog_writeSpirVAssemblySource(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 /*--------------------------------------------------------------------*//*!
@@ -1260,222 +1260,222 @@ deBool qpTestLog_writeSpirVAssemblySource (qpTestLog* log, const char* source)
  *//*--------------------------------------------------------------------*/
 deBool qpTestLog_writeCompileInfo (qpTestLog* log, const char* name, const char* description, deBool compileOk, const char* infoLog)
 {
-	int				numAttribs = 0;
-	qpXmlAttribute	attribs[3];
+    int             numAttribs = 0;
+    qpXmlAttribute  attribs[3];
 
-	DE_ASSERT(log && name && description && infoLog);
-	deMutex_lock(log->lock);
+    DE_ASSERT(log && name && description && infoLog);
+    deMutex_lock(log->lock);
 
-	attribs[numAttribs++] = qpSetStringAttrib("Name", name);
-	attribs[numAttribs++] = qpSetStringAttrib("Description", description);
-	attribs[numAttribs++] = qpSetStringAttrib("CompileStatus", compileOk ? "OK" : "Fail");
+    attribs[numAttribs++] = qpSetStringAttrib("Name", name);
+    attribs[numAttribs++] = qpSetStringAttrib("Description", description);
+    attribs[numAttribs++] = qpSetStringAttrib("CompileStatus", compileOk ? "OK" : "Fail");
 
-	if (!qpXmlWriter_startElement(log->writer, "CompileInfo", numAttribs, attribs) ||
-		!qpXmlWriter_writeStringElement(log->writer, "InfoLog", infoLog) ||
-		!qpXmlWriter_endElement(log->writer, "CompileInfo"))
-	{
-		qpPrintf("qpTestLog_writeCompileInfo(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    if (!qpXmlWriter_startElement(log->writer, "CompileInfo", numAttribs, attribs) ||
+        !qpXmlWriter_writeStringElement(log->writer, "InfoLog", infoLog) ||
+        !qpXmlWriter_endElement(log->writer, "CompileInfo"))
+    {
+        qpPrintf("qpTestLog_writeCompileInfo(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 deBool qpTestLog_startSampleList (qpTestLog* log, const char* name, const char* description)
 {
-	int				numAttribs = 0;
-	qpXmlAttribute	attribs[2];
+    int             numAttribs = 0;
+    qpXmlAttribute  attribs[2];
 
-	DE_ASSERT(log && name && description);
-	deMutex_lock(log->lock);
+    DE_ASSERT(log && name && description);
+    deMutex_lock(log->lock);
 
-	attribs[numAttribs++] = qpSetStringAttrib("Name", name);
-	attribs[numAttribs++] = qpSetStringAttrib("Description", description);
+    attribs[numAttribs++] = qpSetStringAttrib("Name", name);
+    attribs[numAttribs++] = qpSetStringAttrib("Description", description);
 
-	if (!qpXmlWriter_startElement(log->writer, "SampleList", numAttribs, attribs))
-	{
-		qpPrintf("qpTestLog_startSampleList(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    if (!qpXmlWriter_startElement(log->writer, "SampleList", numAttribs, attribs))
+    {
+        qpPrintf("qpTestLog_startSampleList(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	DE_ASSERT(ContainerStack_push(&log->containerStack, CONTAINERTYPE_SAMPLELIST));
+    DE_ASSERT(ContainerStack_push(&log->containerStack, CONTAINERTYPE_SAMPLELIST));
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 deBool qpTestLog_startSampleInfo (qpTestLog* log)
 {
-	DE_ASSERT(log);
-	deMutex_lock(log->lock);
+    DE_ASSERT(log);
+    deMutex_lock(log->lock);
 
-	if (!qpXmlWriter_startElement(log->writer, "SampleInfo", 0, DE_NULL))
-	{
-		qpPrintf("qpTestLog_startSampleInfo(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    if (!qpXmlWriter_startElement(log->writer, "SampleInfo", 0, DE_NULL))
+    {
+        qpPrintf("qpTestLog_startSampleInfo(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	DE_ASSERT(ContainerStack_push(&log->containerStack, CONTAINERTYPE_SAMPLEINFO));
+    DE_ASSERT(ContainerStack_push(&log->containerStack, CONTAINERTYPE_SAMPLEINFO));
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 deBool qpTestLog_writeValueInfo (qpTestLog* log, const char* name, const char* description, const char* unit, qpSampleValueTag tag)
 {
-	const char*		tagName		= QP_LOOKUP_STRING(s_qpSampleValueTagMap, tag);
-	int				numAttribs	= 0;
-	qpXmlAttribute	attribs[4];
+    const char*     tagName     = QP_LOOKUP_STRING(s_qpSampleValueTagMap, tag);
+    int             numAttribs  = 0;
+    qpXmlAttribute  attribs[4];
 
-	DE_ASSERT(log && name && description && tagName);
-	deMutex_lock(log->lock);
+    DE_ASSERT(log && name && description && tagName);
+    deMutex_lock(log->lock);
 
-	DE_ASSERT(ContainerStack_getTop(&log->containerStack) == CONTAINERTYPE_SAMPLEINFO);
+    DE_ASSERT(ContainerStack_getTop(&log->containerStack) == CONTAINERTYPE_SAMPLEINFO);
 
-	attribs[numAttribs++] = qpSetStringAttrib("Name", name);
-	attribs[numAttribs++] = qpSetStringAttrib("Description", description);
-	attribs[numAttribs++] = qpSetStringAttrib("Tag", tagName);
+    attribs[numAttribs++] = qpSetStringAttrib("Name", name);
+    attribs[numAttribs++] = qpSetStringAttrib("Description", description);
+    attribs[numAttribs++] = qpSetStringAttrib("Tag", tagName);
 
-	if (unit)
-		attribs[numAttribs++] = qpSetStringAttrib("Unit", unit);
+    if (unit)
+        attribs[numAttribs++] = qpSetStringAttrib("Unit", unit);
 
-	if (!qpXmlWriter_startElement(log->writer, "ValueInfo", numAttribs, attribs) ||
-		!qpXmlWriter_endElement(log->writer, "ValueInfo"))
-	{
-		qpPrintf("qpTestLog_writeValueInfo(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    if (!qpXmlWriter_startElement(log->writer, "ValueInfo", numAttribs, attribs) ||
+        !qpXmlWriter_endElement(log->writer, "ValueInfo"))
+    {
+        qpPrintf("qpTestLog_writeValueInfo(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 deBool qpTestLog_endSampleInfo (qpTestLog* log)
 {
-	DE_ASSERT(log);
-	deMutex_lock(log->lock);
+    DE_ASSERT(log);
+    deMutex_lock(log->lock);
 
-	if (!qpXmlWriter_endElement(log->writer, "SampleInfo"))
-	{
-		qpPrintf("qpTestLog_endSampleInfo(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    if (!qpXmlWriter_endElement(log->writer, "SampleInfo"))
+    {
+        qpPrintf("qpTestLog_endSampleInfo(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	DE_ASSERT(ContainerStack_pop(&log->containerStack) == CONTAINERTYPE_SAMPLEINFO);
+    DE_ASSERT(ContainerStack_pop(&log->containerStack) == CONTAINERTYPE_SAMPLEINFO);
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 deBool qpTestLog_startSample (qpTestLog* log)
 {
-	DE_ASSERT(log);
-	deMutex_lock(log->lock);
+    DE_ASSERT(log);
+    deMutex_lock(log->lock);
 
-	DE_ASSERT(ContainerStack_getTop(&log->containerStack) == CONTAINERTYPE_SAMPLELIST);
+    DE_ASSERT(ContainerStack_getTop(&log->containerStack) == CONTAINERTYPE_SAMPLELIST);
 
-	if (!qpXmlWriter_startElement(log->writer, "Sample", 0, DE_NULL))
-	{
-		qpPrintf("qpTestLog_startSample(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    if (!qpXmlWriter_startElement(log->writer, "Sample", 0, DE_NULL))
+    {
+        qpPrintf("qpTestLog_startSample(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	DE_ASSERT(ContainerStack_push(&log->containerStack, CONTAINERTYPE_SAMPLE));
+    DE_ASSERT(ContainerStack_push(&log->containerStack, CONTAINERTYPE_SAMPLE));
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 deBool qpTestLog_writeValueFloat (qpTestLog* log, double value)
 {
-	char tmpString[512];
-	doubleToString(value, tmpString, (int)sizeof(tmpString));
+    char tmpString[512];
+    doubleToString(value, tmpString, (int)sizeof(tmpString));
 
-	deMutex_lock(log->lock);
+    deMutex_lock(log->lock);
 
-	DE_ASSERT(ContainerStack_getTop(&log->containerStack) == CONTAINERTYPE_SAMPLE);
+    DE_ASSERT(ContainerStack_getTop(&log->containerStack) == CONTAINERTYPE_SAMPLE);
 
-	if (!qpXmlWriter_writeStringElement(log->writer, "Value", &tmpString[0]))
-	{
-		qpPrintf("qpTestLog_writeSampleValue(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    if (!qpXmlWriter_writeStringElement(log->writer, "Value", &tmpString[0]))
+    {
+        qpPrintf("qpTestLog_writeSampleValue(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 deBool qpTestLog_writeValueInteger (qpTestLog* log, deInt64 value)
 {
-	char tmpString[64];
-	int64ToString(value, tmpString);
+    char tmpString[64];
+    int64ToString(value, tmpString);
 
-	deMutex_lock(log->lock);
+    deMutex_lock(log->lock);
 
-	DE_ASSERT(ContainerStack_getTop(&log->containerStack) == CONTAINERTYPE_SAMPLE);
+    DE_ASSERT(ContainerStack_getTop(&log->containerStack) == CONTAINERTYPE_SAMPLE);
 
-	if (!qpXmlWriter_writeStringElement(log->writer, "Value", &tmpString[0]))
-	{
-		qpPrintf("qpTestLog_writeSampleValue(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    if (!qpXmlWriter_writeStringElement(log->writer, "Value", &tmpString[0]))
+    {
+        qpPrintf("qpTestLog_writeSampleValue(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 deBool qpTestLog_endSample (qpTestLog* log)
 {
-	DE_ASSERT(log);
-	deMutex_lock(log->lock);
+    DE_ASSERT(log);
+    deMutex_lock(log->lock);
 
-	if (!qpXmlWriter_endElement(log->writer, "Sample"))
-	{
-		qpPrintf("qpTestLog_endSample(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    if (!qpXmlWriter_endElement(log->writer, "Sample"))
+    {
+        qpPrintf("qpTestLog_endSample(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	DE_ASSERT(ContainerStack_pop(&log->containerStack) == CONTAINERTYPE_SAMPLE);
+    DE_ASSERT(ContainerStack_pop(&log->containerStack) == CONTAINERTYPE_SAMPLE);
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 deBool qpTestLog_endSampleList (qpTestLog* log)
 {
-	DE_ASSERT(log);
-	deMutex_lock(log->lock);
+    DE_ASSERT(log);
+    deMutex_lock(log->lock);
 
-	if (!qpXmlWriter_endElement(log->writer, "SampleList"))
-	{
-		qpPrintf("qpTestLog_endSampleList(): Writing XML failed\n");
-		deMutex_unlock(log->lock);
-		return DE_FALSE;
-	}
+    if (!qpXmlWriter_endElement(log->writer, "SampleList"))
+    {
+        qpPrintf("qpTestLog_endSampleList(): Writing XML failed\n");
+        deMutex_unlock(log->lock);
+        return DE_FALSE;
+    }
 
-	DE_ASSERT(ContainerStack_pop(&log->containerStack) == CONTAINERTYPE_SAMPLELIST);
+    DE_ASSERT(ContainerStack_pop(&log->containerStack) == CONTAINERTYPE_SAMPLELIST);
 
-	deMutex_unlock(log->lock);
-	return DE_TRUE;
+    deMutex_unlock(log->lock);
+    return DE_TRUE;
 }
 
 deUint32 qpTestLog_getLogFlags (const qpTestLog* log)
 {
-	DE_ASSERT(log);
-	return log->flags;
+    DE_ASSERT(log);
+    return log->flags;
 }
 
 const char* qpGetTestResultName (qpTestResult result)
 {
-	return QP_LOOKUP_STRING(s_qpTestResultMap, result);
+    return QP_LOOKUP_STRING(s_qpTestResultMap, result);
 }
diff --git a/src/tests/perf_tests/MultiviewPerf.cpp b/src/tests/perf_tests/MultiviewPerf.cpp
index 8c106b493..c3d99d23d 100644
--- a/src/tests/perf_tests/MultiviewPerf.cpp
+++ b/src/tests/perf_tests/MultiviewPerf.cpp
@@ -273,7 +273,7 @@ void MultiviewCPUBoundBenchmark::initializeBenchmark()
         "{\n"
         "   vec4 v = vPosition;\n"
         "   v.xy += uOffset;\n"
-        "	gl_Position = v;\n"
+        "   gl_Position = v;\n"
         "}\n";
 
     const std::string &fs =
@@ -371,7 +371,7 @@ void MultiviewGPUBoundBenchmark::initializeBenchmark()
         "   frag_Col3 = vert_Col3;\n"
         "   frag_Col4 = vert_Col4;\n"
         "   frag_Col5 = vert_Col5;\n"
-        "	gl_Position = vPosition;\n"
+        "   gl_Position = vPosition;\n"
         "}\n";
 
     const std::string &fs =
diff --git a/src/tests/third_party/rapidjson/include/rapidjson/prettywriter.h b/src/tests/third_party/rapidjson/include/rapidjson/prettywriter.h
index ce2dac5a1..1d7c70f02 100644
--- a/src/tests/third_party/rapidjson/include/rapidjson/prettywriter.h
+++ b/src/tests/third_party/rapidjson/include/rapidjson/prettywriter.h
@@ -89,7 +89,7 @@ public:
     }
 
     bool Key(const Ch* str, SizeType length, bool copy = false) { return String(str, length, copy); }
-	
+    
     bool EndObject(SizeType memberCount = 0) {
         (void)memberCount;
         RAPIDJSON_ASSERT(Base::level_stack_.GetSize() >= sizeof(typename Base::Level));
diff --git a/src/tests/third_party/rapidjson/include/rapidjson/reader.h b/src/tests/third_party/rapidjson/include/rapidjson/reader.h
index 08425eb9e..bc5cdcf2d 100644
--- a/src/tests/third_party/rapidjson/include/rapidjson/reader.h
+++ b/src/tests/third_party/rapidjson/include/rapidjson/reader.h
@@ -261,23 +261,23 @@ void SkipWhitespace(InputStream& is) {
 #ifdef RAPIDJSON_SSE42
 //! Skip whitespace with SSE 4.2 pcmpistrm instruction, testing 16 8-byte characters at once.
 inline const char *SkipWhitespace_SIMD(const char* p) {
-	// Fast return for single non-whitespace
-	if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
-		++p;
-	else
-		return p;
-
-	// 16-byte align to the next boundary
-	const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & ~15);
-	while (p != nextAligned)
-		if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
-			++p;
-		else
-			return p;
+    // Fast return for single non-whitespace
+    if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
+        ++p;
+    else
+        return p;
+
+    // 16-byte align to the next boundary
+    const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & ~15);
+    while (p != nextAligned)
+        if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
+            ++p;
+        else
+            return p;
 
     // The rest of string using SIMD
-	static const char whitespace[16] = " \n\r\t";
-	const __m128i w = _mm_loadu_si128((const __m128i *)&whitespace[0]);
+    static const char whitespace[16] = " \n\r\t";
+    const __m128i w = _mm_loadu_si128((const __m128i *)&whitespace[0]);
 
     for (;; p += 16) {
         const __m128i s = _mm_load_si128((const __m128i *)p);
@@ -298,31 +298,31 @@ inline const char *SkipWhitespace_SIMD(const char* p) {
 
 //! Skip whitespace with SSE2 instructions, testing 16 8-byte characters at once.
 inline const char *SkipWhitespace_SIMD(const char* p) {
-	// Fast return for single non-whitespace
-	if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
-		++p;
-	else
-		return p;
+    // Fast return for single non-whitespace
+    if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
+        ++p;
+    else
+        return p;
 
     // 16-byte align to the next boundary
-	const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & ~15);
-	while (p != nextAligned)
-		if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
-			++p;
-		else
-			return p;
+    const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & ~15);
+    while (p != nextAligned)
+        if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
+            ++p;
+        else
+            return p;
 
     // The rest of string
-	static const char whitespaces[4][17] = {
-		"                ",
-		"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
-		"\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r",
-		"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"};
-
-		const __m128i w0 = _mm_loadu_si128((const __m128i *)&whitespaces[0][0]);
-		const __m128i w1 = _mm_loadu_si128((const __m128i *)&whitespaces[1][0]);
-		const __m128i w2 = _mm_loadu_si128((const __m128i *)&whitespaces[2][0]);
-		const __m128i w3 = _mm_loadu_si128((const __m128i *)&whitespaces[3][0]);
+    static const char whitespaces[4][17] = {
+        "                ",
+        "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
+        "\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r",
+        "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"};
+
+        const __m128i w0 = _mm_loadu_si128((const __m128i *)&whitespaces[0][0]);
+        const __m128i w1 = _mm_loadu_si128((const __m128i *)&whitespaces[1][0]);
+        const __m128i w2 = _mm_loadu_si128((const __m128i *)&whitespaces[2][0]);
+        const __m128i w3 = _mm_loadu_si128((const __m128i *)&whitespaces[3][0]);
 
     for (;; p += 16) {
         const __m128i s = _mm_load_si128((const __m128i *)p);
diff --git a/src/tests/third_party/rapidjson/include/rapidjson/writer.h b/src/tests/third_party/rapidjson/include/rapidjson/writer.h
index 6daa78330..98931fe31 100644
--- a/src/tests/third_party/rapidjson/include/rapidjson/writer.h
+++ b/src/tests/third_party/rapidjson/include/rapidjson/writer.h
@@ -134,7 +134,7 @@ public:
     }
 
     bool Key(const Ch* str, SizeType length, bool copy = false) { return String(str, length, copy); }
-	
+    
     bool EndObject(SizeType memberCount = 0) {
         (void)memberCount;
         RAPIDJSON_ASSERT(level_stack_.GetSize() >= sizeof(Level));
diff --git a/include/EGL/eglplatform.h b/include/EGL/eglplatform.h
index 333448be348..47d18093c96 100644
--- a/include/EGL/eglplatform.h
+++ b/include/EGL/eglplatform.h
@@ -100,7 +100,7 @@ typedef struct ANativeWindow*           EGLNativeWindowType;
 typedef struct egl_native_pixmap_t*     EGLNativePixmapType;
 typedef void*                           EGLNativeDisplayType;
 
-#elif defined(USE_OZONE)
+#elif defined(USE_OZONE) || defined(USE_WPE)
 
 typedef intptr_t EGLNativeDisplayType;
 typedef intptr_t EGLNativeWindowType;
